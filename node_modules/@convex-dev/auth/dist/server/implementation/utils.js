import { sha256 as rawSha256 } from "oslo/crypto";
import { encodeHex } from "oslo/encoding";
export const TOKEN_SUB_CLAIM_DIVIDER = "|";
export const REFRESH_TOKEN_DIVIDER = "|";
export function stringToNumber(value) {
    return value !== undefined ? Number(value) : undefined;
}
export async function sha256(input) {
    return encodeHex(await rawSha256(new TextEncoder().encode(input)));
}
export function logError(error) {
    logWithLevel(LOG_LEVELS.ERROR, error instanceof Error
        ? error.message + "\n" + error.stack?.replace("\\n", "\n")
        : error);
}
export const LOG_LEVELS = {
    ERROR: "ERROR",
    WARN: "WARN",
    INFO: "INFO",
    DEBUG: "DEBUG",
};
export function logWithLevel(level, ...args) {
    const configuredLogLevel = LOG_LEVELS[process.env.AUTH_LOG_LEVEL ?? "INFO"] ?? "INFO";
    switch (level) {
        case "ERROR":
            console.error(...args);
            break;
        case "WARN":
            if (configuredLogLevel !== "ERROR") {
                console.warn(...args);
            }
            break;
        case "INFO":
            if (configuredLogLevel === "INFO" || configuredLogLevel === "DEBUG") {
                console.info(...args);
            }
            break;
        case "DEBUG":
            if (configuredLogLevel === "DEBUG") {
                console.debug(...args);
            }
            break;
    }
}
export function maybeRedact(value) {
    if (value === "") {
        return "";
    }
    const shouldRedact = process.env.AUTH_LOG_SECRETS !== "true";
    if (shouldRedact) {
        if (value.length < 6) {
            return "<redacted>";
        }
        return (value.substring(0, 3) + "<redacted>" + value.substring(value.length - 3));
    }
    else {
        return value;
    }
}

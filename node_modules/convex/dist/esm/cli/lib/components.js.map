{
  "version": 3,
  "sources": ["../../../../src/cli/lib/components.ts"],
  "sourcesContent": ["import path from \"path\";\nimport { Context, changeSpinner, logMessage } from \"../../bundler/context.js\";\nimport {\n  ProjectConfig,\n  configFromProjectConfig,\n  getFunctionsDirectoryPath,\n  readProjectConfig,\n} from \"./config.js\";\nimport { finishPush, startPush, waitForSchema } from \"./deploy2.js\";\nimport { version } from \"../version.js\";\nimport { PushOptions, runNonComponentsPush } from \"./push.js\";\nimport { ensureHasConvexDependency, functionsDir } from \"./utils/utils.js\";\nimport {\n  bundleDefinitions,\n  bundleImplementations,\n  componentGraph,\n} from \"./components/definition/bundle.js\";\nimport { isComponentDirectory } from \"./components/definition/directoryStructure.js\";\nimport {\n  doFinalComponentCodegen,\n  doInitialComponentCodegen,\n  CodegenOptions,\n  doInitCodegen,\n  doCodegen,\n} from \"./codegen.js\";\nimport {\n  AppDefinitionConfig,\n  ComponentDefinitionConfig,\n} from \"./deployApi/definitionConfig.js\";\nimport { typeCheckFunctionsInMode, TypeCheckMode } from \"./typecheck.js\";\nimport { withTmpDir } from \"../../bundler/fs.js\";\nimport { ROOT_DEFINITION_FILENAME } from \"./components/constants.js\";\nimport { handleDebugBundlePath } from \"./debugBundlePath.js\";\nimport chalk from \"chalk\";\nimport { StartPushResponse } from \"./deployApi/startPush.js\";\nimport {\n  deploymentSelectionFromOptions,\n  fetchDeploymentCredentialsProvisionProd,\n} from \"./api.js\";\n\nexport async function runCodegen(ctx: Context, options: CodegenOptions) {\n  // This also ensures the current directory is the project root.\n  await ensureHasConvexDependency(ctx, \"codegen\");\n\n  const { configPath, projectConfig } = await readProjectConfig(ctx);\n  const functionsDirectoryPath = functionsDir(configPath, projectConfig);\n  const componentRootPath = path.resolve(\n    path.join(functionsDirectoryPath, ROOT_DEFINITION_FILENAME),\n  );\n  if (ctx.fs.exists(componentRootPath)) {\n    const deploymentSelection = deploymentSelectionFromOptions(options);\n    const credentials = await fetchDeploymentCredentialsProvisionProd(\n      ctx,\n      deploymentSelection,\n    );\n\n    await startComponentsPushAndCodegen(ctx, projectConfig, configPath, {\n      ...options,\n      ...credentials,\n      generateCommonJSApi: options.commonjs,\n      verbose: options.dryRun,\n    });\n  } else {\n    if (options.init) {\n      await doInitCodegen(ctx, functionsDirectoryPath, false, {\n        dryRun: options.dryRun,\n        debug: options.debug,\n      });\n    }\n\n    if (options.typecheck !== \"disable\") {\n      logMessage(ctx, chalk.gray(\"Running TypeScript typecheck\u2026\"));\n    }\n\n    await doCodegen(ctx, functionsDirectoryPath, options.typecheck, {\n      dryRun: options.dryRun,\n      debug: options.debug,\n      generateCommonJSApi: options.commonjs,\n    });\n  }\n}\n\nexport async function runPush(ctx: Context, options: PushOptions) {\n  const { configPath, projectConfig } = await readProjectConfig(ctx);\n  const convexDir = functionsDir(configPath, projectConfig);\n  const componentRootPath = path.resolve(\n    path.join(convexDir, ROOT_DEFINITION_FILENAME),\n  );\n  if (ctx.fs.exists(componentRootPath)) {\n    await runComponentsPush(ctx, options, configPath, projectConfig);\n  } else {\n    await runNonComponentsPush(ctx, options, configPath, projectConfig);\n  }\n}\n\nasync function startComponentsPushAndCodegen(\n  ctx: Context,\n  projectConfig: ProjectConfig,\n  configPath: string,\n  options: {\n    typecheck: TypeCheckMode;\n    adminKey: string;\n    url: string;\n    verbose: boolean;\n    debugBundlePath?: string;\n    dryRun: boolean;\n    generateCommonJSApi?: boolean;\n    debug: boolean;\n    writePushRequest?: string;\n  },\n): Promise<StartPushResponse | null> {\n  const verbose = options.verbose || options.dryRun;\n  const convexDir = await getFunctionsDirectoryPath(ctx);\n\n  // '.' means use the process current working directory, it's the default behavior.\n  // Spelling it out here to be explicit for a future where this code can run\n  // from other directories.\n  // In esbuild the working directory is used to print error messages and resolving\n  // relatives paths passed to it. It generally doesn't matter for resolving imports,\n  // imports are resolved from the file where they are written.\n  const absWorkingDir = path.resolve(\".\");\n  const isComponent = isComponentDirectory(ctx, convexDir, true);\n  if (isComponent.kind === \"err\") {\n    return await ctx.crash({\n      exitCode: 1,\n      errorType: \"invalid filesystem data\",\n      printedMessage: `Invalid component root directory (${isComponent.why}): ${convexDir}`,\n    });\n  }\n  const rootComponent = isComponent.component;\n\n  changeSpinner(ctx, \"Traversing component definitions...\");\n  // Create a list of relevant component directories. These are just for knowing\n  // while directories to bundle in bundleDefinitions and bundleImplementations.\n  // This produces a bundle in memory as a side effect but it's thrown away.\n  //\n  // This is the very first time we traverse the component graph.\n  // We're just traversing to discover\n  const { components, dependencyGraph } = await componentGraph(\n    ctx,\n    absWorkingDir,\n    rootComponent,\n    verbose,\n  );\n\n  changeSpinner(ctx, \"Generating server code...\");\n  await withTmpDir(async (tmpDir) => {\n    await doInitialComponentCodegen(ctx, tmpDir, rootComponent, options);\n    for (const directory of components.values()) {\n      await doInitialComponentCodegen(ctx, tmpDir, directory, options);\n    }\n  });\n\n  changeSpinner(ctx, \"Bundling component definitions...\");\n  // This bundles everything but the actual function definitions\n  const {\n    appDefinitionSpecWithoutImpls,\n    componentDefinitionSpecsWithoutImpls,\n  } = await bundleDefinitions(\n    ctx,\n    absWorkingDir,\n    dependencyGraph,\n    rootComponent,\n    // Note that this *includes* the root component.\n    [...components.values()],\n  );\n\n  changeSpinner(ctx, \"Bundling component schemas and implementations...\");\n  const { appImplementation, componentImplementations } =\n    await bundleImplementations(\n      ctx,\n      rootComponent,\n      [...components.values()],\n      projectConfig.node.externalPackages,\n      verbose,\n    );\n  if (options.debugBundlePath) {\n    const { config: localConfig } = await configFromProjectConfig(\n      ctx,\n      projectConfig,\n      configPath,\n      verbose,\n    );\n    // TODO(ENG-6972): Actually write the bundles for components.\n    await handleDebugBundlePath(ctx, options.debugBundlePath, localConfig);\n    logMessage(\n      ctx,\n      `Wrote bundle and metadata for modules in the root to ${options.debugBundlePath}. Skipping rest of push.`,\n    );\n    return null;\n  }\n\n  // We're just using the version this CLI is running with for now.\n  // This could be different than the version of `convex` the app runs with\n  // if the CLI is installed globally.\n  // TODO: This should be the version of the `convex` package used by each\n  // component, and may be different for each component.\n  const udfServerVersion = version;\n\n  const appDefinition: AppDefinitionConfig = {\n    ...appDefinitionSpecWithoutImpls,\n    ...appImplementation,\n    udfServerVersion,\n  };\n\n  const componentDefinitions: ComponentDefinitionConfig[] = [];\n  for (const componentDefinition of componentDefinitionSpecsWithoutImpls) {\n    const impl = componentImplementations.filter(\n      (impl) => impl.definitionPath === componentDefinition.definitionPath,\n    )[0];\n    if (!impl) {\n      return await ctx.crash({\n        exitCode: 1,\n        errorType: \"fatal\",\n        printedMessage: `missing! couldn't find ${componentDefinition.definitionPath} in ${componentImplementations.map((impl) => impl.definitionPath).toString()}`,\n      });\n    }\n    componentDefinitions.push({\n      ...componentDefinition,\n      ...impl,\n      udfServerVersion,\n    });\n  }\n  const startPushRequest = {\n    adminKey: options.adminKey,\n    dryRun: false,\n    functions: projectConfig.functions,\n    appDefinition,\n    componentDefinitions,\n    nodeDependencies: appImplementation.externalNodeDependencies,\n  };\n  if (options.writePushRequest) {\n    const pushRequestPath = path.resolve(options.writePushRequest);\n    ctx.fs.writeUtf8File(\n      `${pushRequestPath}.json`,\n      JSON.stringify(startPushRequest),\n    );\n    return null;\n  }\n\n  const startPushResponse = await startPush(\n    ctx,\n    options.url,\n    startPushRequest,\n    verbose,\n  );\n\n  verbose && console.log(\"startPush:\");\n  verbose && console.dir(startPushResponse, { depth: null });\n\n  changeSpinner(ctx, \"Finalizing code generation...\");\n  await withTmpDir(async (tmpDir) => {\n    await doFinalComponentCodegen(\n      ctx,\n      tmpDir,\n      rootComponent,\n      rootComponent,\n      startPushResponse,\n      options,\n    );\n    for (const directory of components.values()) {\n      await doFinalComponentCodegen(\n        ctx,\n        tmpDir,\n        rootComponent,\n        directory,\n        startPushResponse,\n        options,\n      );\n    }\n  });\n\n  changeSpinner(ctx, \"Running TypeScript...\");\n  await typeCheckFunctionsInMode(ctx, options.typecheck, rootComponent.path);\n  for (const directory of components.values()) {\n    await typeCheckFunctionsInMode(ctx, options.typecheck, directory.path);\n  }\n\n  return startPushResponse;\n}\n\nexport async function runComponentsPush(\n  ctx: Context,\n  options: PushOptions,\n  configPath: string,\n  projectConfig: ProjectConfig,\n) {\n  const verbose = options.verbose || options.dryRun;\n  await ensureHasConvexDependency(ctx, \"push\");\n\n  if (options.dryRun) {\n    return await ctx.crash({\n      exitCode: 1,\n      errorType: \"fatal\",\n      printedMessage: \"dryRun not allowed yet\",\n    });\n  }\n\n  const startPushResponse = await startComponentsPushAndCodegen(\n    ctx,\n    projectConfig,\n    configPath,\n    options,\n  );\n  if (!startPushResponse) {\n    return;\n  }\n\n  changeSpinner(ctx, \"Waiting for schema...\");\n  await waitForSchema(ctx, options.adminKey, options.url, startPushResponse);\n\n  const finishPushResponse = await finishPush(\n    ctx,\n    options.adminKey,\n    options.url,\n    startPushResponse,\n  );\n  verbose && console.log(\"finishPush:\", finishPushResponse);\n}\n"],
  "mappings": "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",
  "names": ["impl"]
}

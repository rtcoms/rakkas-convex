"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var components_exports = {};
__export(components_exports, {
  runCodegen: () => runCodegen,
  runComponentsPush: () => runComponentsPush,
  runPush: () => runPush
});
module.exports = __toCommonJS(components_exports);
var import_path = __toESM(require("path"), 1);
var import_context = require("../../bundler/context.js");
var import_config = require("./config.js");
var import_deploy2 = require("./deploy2.js");
var import_version = require("../version.js");
var import_push = require("./push.js");
var import_utils = require("./utils/utils.js");
var import_bundle = require("./components/definition/bundle.js");
var import_directoryStructure = require("./components/definition/directoryStructure.js");
var import_codegen = require("./codegen.js");
var import_typecheck = require("./typecheck.js");
var import_fs = require("../../bundler/fs.js");
var import_constants = require("./components/constants.js");
var import_debugBundlePath = require("./debugBundlePath.js");
var import_chalk = __toESM(require("chalk"), 1);
var import_api = require("./api.js");
async function runCodegen(ctx, options) {
  await (0, import_utils.ensureHasConvexDependency)(ctx, "codegen");
  const { configPath, projectConfig } = await (0, import_config.readProjectConfig)(ctx);
  const functionsDirectoryPath = (0, import_utils.functionsDir)(configPath, projectConfig);
  const componentRootPath = import_path.default.resolve(
    import_path.default.join(functionsDirectoryPath, import_constants.ROOT_DEFINITION_FILENAME)
  );
  if (ctx.fs.exists(componentRootPath)) {
    const deploymentSelection = (0, import_api.deploymentSelectionFromOptions)(options);
    const credentials = await (0, import_api.fetchDeploymentCredentialsProvisionProd)(
      ctx,
      deploymentSelection
    );
    await startComponentsPushAndCodegen(ctx, projectConfig, configPath, {
      ...options,
      ...credentials,
      generateCommonJSApi: options.commonjs,
      verbose: options.dryRun
    });
  } else {
    if (options.init) {
      await (0, import_codegen.doInitCodegen)(ctx, functionsDirectoryPath, false, {
        dryRun: options.dryRun,
        debug: options.debug
      });
    }
    if (options.typecheck !== "disable") {
      (0, import_context.logMessage)(ctx, import_chalk.default.gray("Running TypeScript typecheck\u2026"));
    }
    await (0, import_codegen.doCodegen)(ctx, functionsDirectoryPath, options.typecheck, {
      dryRun: options.dryRun,
      debug: options.debug,
      generateCommonJSApi: options.commonjs
    });
  }
}
async function runPush(ctx, options) {
  const { configPath, projectConfig } = await (0, import_config.readProjectConfig)(ctx);
  const convexDir = (0, import_utils.functionsDir)(configPath, projectConfig);
  const componentRootPath = import_path.default.resolve(
    import_path.default.join(convexDir, import_constants.ROOT_DEFINITION_FILENAME)
  );
  if (ctx.fs.exists(componentRootPath)) {
    await runComponentsPush(ctx, options, configPath, projectConfig);
  } else {
    await (0, import_push.runNonComponentsPush)(ctx, options, configPath, projectConfig);
  }
}
async function startComponentsPushAndCodegen(ctx, projectConfig, configPath, options) {
  const verbose = options.verbose || options.dryRun;
  const convexDir = await (0, import_config.getFunctionsDirectoryPath)(ctx);
  const absWorkingDir = import_path.default.resolve(".");
  const isComponent = (0, import_directoryStructure.isComponentDirectory)(ctx, convexDir, true);
  if (isComponent.kind === "err") {
    return await ctx.crash({
      exitCode: 1,
      errorType: "invalid filesystem data",
      printedMessage: `Invalid component root directory (${isComponent.why}): ${convexDir}`
    });
  }
  const rootComponent = isComponent.component;
  (0, import_context.changeSpinner)(ctx, "Traversing component definitions...");
  const { components, dependencyGraph } = await (0, import_bundle.componentGraph)(
    ctx,
    absWorkingDir,
    rootComponent,
    verbose
  );
  (0, import_context.changeSpinner)(ctx, "Generating server code...");
  await (0, import_fs.withTmpDir)(async (tmpDir) => {
    await (0, import_codegen.doInitialComponentCodegen)(ctx, tmpDir, rootComponent, options);
    for (const directory of components.values()) {
      await (0, import_codegen.doInitialComponentCodegen)(ctx, tmpDir, directory, options);
    }
  });
  (0, import_context.changeSpinner)(ctx, "Bundling component definitions...");
  const {
    appDefinitionSpecWithoutImpls,
    componentDefinitionSpecsWithoutImpls
  } = await (0, import_bundle.bundleDefinitions)(
    ctx,
    absWorkingDir,
    dependencyGraph,
    rootComponent,
    // Note that this *includes* the root component.
    [...components.values()]
  );
  (0, import_context.changeSpinner)(ctx, "Bundling component schemas and implementations...");
  const { appImplementation, componentImplementations } = await (0, import_bundle.bundleImplementations)(
    ctx,
    rootComponent,
    [...components.values()],
    projectConfig.node.externalPackages,
    verbose
  );
  if (options.debugBundlePath) {
    const { config: localConfig } = await (0, import_config.configFromProjectConfig)(
      ctx,
      projectConfig,
      configPath,
      verbose
    );
    await (0, import_debugBundlePath.handleDebugBundlePath)(ctx, options.debugBundlePath, localConfig);
    (0, import_context.logMessage)(
      ctx,
      `Wrote bundle and metadata for modules in the root to ${options.debugBundlePath}. Skipping rest of push.`
    );
    return null;
  }
  const udfServerVersion = import_version.version;
  const appDefinition = {
    ...appDefinitionSpecWithoutImpls,
    ...appImplementation,
    udfServerVersion
  };
  const componentDefinitions = [];
  for (const componentDefinition of componentDefinitionSpecsWithoutImpls) {
    const impl = componentImplementations.filter(
      (impl2) => impl2.definitionPath === componentDefinition.definitionPath
    )[0];
    if (!impl) {
      return await ctx.crash({
        exitCode: 1,
        errorType: "fatal",
        printedMessage: `missing! couldn't find ${componentDefinition.definitionPath} in ${componentImplementations.map((impl2) => impl2.definitionPath).toString()}`
      });
    }
    componentDefinitions.push({
      ...componentDefinition,
      ...impl,
      udfServerVersion
    });
  }
  const startPushRequest = {
    adminKey: options.adminKey,
    dryRun: false,
    functions: projectConfig.functions,
    appDefinition,
    componentDefinitions,
    nodeDependencies: appImplementation.externalNodeDependencies
  };
  if (options.writePushRequest) {
    const pushRequestPath = import_path.default.resolve(options.writePushRequest);
    ctx.fs.writeUtf8File(
      `${pushRequestPath}.json`,
      JSON.stringify(startPushRequest)
    );
    return null;
  }
  const startPushResponse = await (0, import_deploy2.startPush)(
    ctx,
    options.url,
    startPushRequest,
    verbose
  );
  verbose && console.log("startPush:");
  verbose && console.dir(startPushResponse, { depth: null });
  (0, import_context.changeSpinner)(ctx, "Finalizing code generation...");
  await (0, import_fs.withTmpDir)(async (tmpDir) => {
    await (0, import_codegen.doFinalComponentCodegen)(
      ctx,
      tmpDir,
      rootComponent,
      rootComponent,
      startPushResponse,
      options
    );
    for (const directory of components.values()) {
      await (0, import_codegen.doFinalComponentCodegen)(
        ctx,
        tmpDir,
        rootComponent,
        directory,
        startPushResponse,
        options
      );
    }
  });
  (0, import_context.changeSpinner)(ctx, "Running TypeScript...");
  await (0, import_typecheck.typeCheckFunctionsInMode)(ctx, options.typecheck, rootComponent.path);
  for (const directory of components.values()) {
    await (0, import_typecheck.typeCheckFunctionsInMode)(ctx, options.typecheck, directory.path);
  }
  return startPushResponse;
}
async function runComponentsPush(ctx, options, configPath, projectConfig) {
  const verbose = options.verbose || options.dryRun;
  await (0, import_utils.ensureHasConvexDependency)(ctx, "push");
  if (options.dryRun) {
    return await ctx.crash({
      exitCode: 1,
      errorType: "fatal",
      printedMessage: "dryRun not allowed yet"
    });
  }
  const startPushResponse = await startComponentsPushAndCodegen(
    ctx,
    projectConfig,
    configPath,
    options
  );
  if (!startPushResponse) {
    return;
  }
  (0, import_context.changeSpinner)(ctx, "Waiting for schema...");
  await (0, import_deploy2.waitForSchema)(ctx, options.adminKey, options.url, startPushResponse);
  const finishPushResponse = await (0, import_deploy2.finishPush)(
    ctx,
    options.adminKey,
    options.url,
    startPushResponse
  );
  verbose && console.log("finishPush:", finishPushResponse);
}
//# sourceMappingURL=components.js.map

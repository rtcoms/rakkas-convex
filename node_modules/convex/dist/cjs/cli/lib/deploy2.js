"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var deploy2_exports = {};
__export(deploy2_exports, {
  finishPush: () => finishPush,
  startPush: () => startPush,
  waitForSchema: () => waitForSchema
});
module.exports = __toCommonJS(deploy2_exports);
var import_context = require("../../bundler/context.js");
var import_utils = require("./utils/utils.js");
var import_startPush = require("./deployApi/startPush.js");
async function startPush(ctx, url, request, verbose) {
  if (verbose) {
    const custom = (_k, s) => typeof s === "string" ? s.slice(0, 40) + (s.length > 40 ? "..." : "") : s;
    console.log(JSON.stringify(request, custom, 2));
  }
  const onError = (err) => {
    if (err.toString() === "TypeError: fetch failed") {
      (0, import_context.changeSpinner)(ctx, `Fetch failed, is ${url} correct? Retrying...`);
    }
  };
  const fetch = (0, import_utils.deploymentFetch)(url, request.adminKey, onError);
  (0, import_context.changeSpinner)(ctx, "Analyzing and deploying source code...");
  try {
    const response = await fetch("/api/deploy2/start_push", {
      body: JSON.stringify(request),
      method: "POST"
    });
    return import_startPush.startPushResponse.parse(await response.json());
  } catch (error) {
    (0, import_context.logFailure)(ctx, "Error: Unable to start push to " + url);
    return await (0, import_utils.logAndHandleFetchError)(ctx, error);
  }
}
async function waitForSchema(ctx, adminKey, url, startPush2) {
  const fetch = (0, import_utils.deploymentFetch)(url, adminKey);
  try {
    const response = await fetch("/api/deploy2/wait_for_schema", {
      body: JSON.stringify({
        adminKey,
        schemaChange: startPush2.schemaChange,
        dryRun: false
      }),
      method: "POST"
    });
    return await response.json();
  } catch (error) {
    (0, import_context.logFailure)(ctx, "Error: Unable to wait for schema from " + url);
    return await (0, import_utils.logAndHandleFetchError)(ctx, error);
  }
}
async function finishPush(ctx, adminKey, url, startPush2) {
  const fetch = (0, import_utils.deploymentFetch)(url, adminKey);
  (0, import_context.changeSpinner)(ctx, "Finalizing push...");
  try {
    const response = await fetch("/api/deploy2/finish_push", {
      body: JSON.stringify({
        adminKey,
        startPush: startPush2,
        dryRun: false
      }),
      method: "POST"
    });
    return await response.json();
  } catch (error) {
    (0, import_context.logFailure)(ctx, "Error: Unable to finish push to " + url);
    return await (0, import_utils.logAndHandleFetchError)(ctx, error);
  }
}
//# sourceMappingURL=deploy2.js.map

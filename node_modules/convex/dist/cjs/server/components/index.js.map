{
  "version": 3,
  "sources": ["../../../../src/server/components/index.ts"],
  "sourcesContent": ["import {\n  Infer,\n  ObjectType,\n  PropertyValidators,\n  convexToJson,\n  jsonToConvex,\n} from \"../../values/index.js\";\nimport {\n  AnyFunctionReference,\n  FunctionReference,\n  FunctionType,\n} from \"../api.js\";\nimport { getFunctionAddress } from \"../impl/actions_impl.js\";\nimport { performAsyncSyscall, performSyscall } from \"../impl/syscall.js\";\nimport { DefaultFunctionArgs, EmptyObject } from \"../registration.js\";\nimport {\n  AppDefinitionAnalysis,\n  ComponentDefinitionAnalysis,\n  ComponentDefinitionType,\n  HttpMount,\n} from \"./definition.js\";\n\nexport const toReferencePath = Symbol.for(\"toReferencePath\");\n\nexport function extractReferencePath(reference: any): string | null {\n  return reference[toReferencePath] ?? null;\n}\n\nexport function isFunctionHandle(s: string): boolean {\n  return s.startsWith(\"function://\");\n}\n\n/**\n * @internal\n */\nexport type FunctionHandle<\n  Type extends FunctionType,\n  Args extends DefaultFunctionArgs = any,\n  ReturnType = any,\n> = string & FunctionReference<Type, \"internal\", Args, ReturnType>;\n\n/**\n * @internal\n */\nexport async function createFunctionHandle<\n  Type extends FunctionType,\n  Args extends DefaultFunctionArgs,\n  ReturnType,\n>(\n  functionReference: FunctionReference<\n    Type,\n    \"public\" | \"internal\",\n    Args,\n    ReturnType\n  >,\n): Promise<FunctionHandle<Type, Args, ReturnType>> {\n  const address = getFunctionAddress(functionReference);\n  return await performAsyncSyscall(\"1.0/createFunctionHandle\", { ...address });\n}\n\ninterface ComponentExports {\n  [key: string]: FunctionReference<any, any, any, any> | ComponentExports;\n}\n\n/**\n * @internal\n */\nexport interface InitCtx {}\n\n/**\n * An object of this type should be the default export of a\n * convex.config.ts file in a component definition directory.\n *\n * @internal\n */ // eslint-disable-next-line @typescript-eslint/ban-types\nexport type ComponentDefinition<\n  Args extends PropertyValidators = EmptyObject,\n  Exports extends ComponentExports = any,\n> = {\n  /**\n   * Install a component with the given definition in this component definition.\n   *\n   * Takes a component definition, an optional name, and the args it requires.\n   *\n   * For editor tooling this method expects a {@link ComponentDefinition}\n   * but at runtime the object that is imported will be a {@link ImportedComponentDefinition}\n   */\n  install<Definition extends ComponentDefinition<any, any>>(\n    definition: Definition,\n    options: {\n      name?: string;\n      // TODO we have to do the \"arguments are optional if empty, otherwise required\"\n      args?: ObjectType<ComponentDefinitionArgs<Definition>>;\n    },\n  ): InstalledComponent<Definition>;\n\n  installWithInit<Definition extends ComponentDefinition<any, any>>(\n    definition: Definition,\n    options: {\n      name?: string;\n      onInit: (\n        ctx: InitCtx,\n        args: ObjectType<Args>,\n      ) => ObjectType<ComponentDefinitionArgs<Definition>>;\n    },\n  ): InstalledComponent<Definition>;\n\n  mount(exports: ComponentExports): void;\n\n  /**\n   * Mount a component's HTTP router at a given path prefix.\n   */\n  mountHttp(pathPrefix: string, component: InstalledComponent<any>): void;\n\n  // TODO this will be needed once components are responsible for building interfaces for themselves\n  /**\n   * @internal\n   */\n  __args: Args;\n\n  /**\n   * @internal\n   */\n  __exports: Exports;\n};\n\ntype ComponentDefinitionArgs<T extends ComponentDefinition<any, any>> =\n  T[\"__args\"];\ntype ComponentDefinitionExports<T extends ComponentDefinition<any, any>> =\n  T[\"__exports\"];\n\n/**\n * An object of this type should be the default export of a\n * convex.config.ts file in a component-aware convex directory.\n *\n * @internal\n */\nexport type AppDefinition = {\n  /**\n   * Install a component with the given definition in this component definition.\n   *\n   * Takes a component definition, an optional name, and the args it requires.\n   *\n   * For editor tooling this method expects a {@link ComponentDefinition}\n   * but at runtime the object that is imported will be a {@link ImportedComponentDefinition}\n   */\n  install<Definition extends ComponentDefinition<any, any>>(\n    definition: Definition,\n    options: {\n      name?: string;\n      args?: ObjectType<ComponentDefinitionArgs<Definition>>;\n    },\n  ): InstalledComponent<Definition>;\n\n  mount(exports: ComponentExports): void;\n\n  /**\n   * Mount a component's HTTP router at a given path prefix.\n   */\n  mountHttp(pathPrefix: string, component: InstalledComponent<any>): void;\n};\n\ninterface ExportTree {\n  // Tree with serialized `Reference`s as leaves.\n  [key: string]: string | ExportTree;\n}\n\ntype CommonDefinitionData = {\n  _isRoot: boolean;\n  _childComponents: [\n    string,\n    ImportedComponentDefinition,\n    Record<string, any> | null,\n  ][];\n  _httpMounts: Record<string, HttpMount>;\n  _exportTree: ExportTree;\n};\n\ntype ComponentDefinitionData = CommonDefinitionData & {\n  _args: PropertyValidators;\n  _name: string;\n  _onInitCallbacks: Record<string, (argsStr: string) => string>;\n};\ntype AppDefinitionData = CommonDefinitionData;\n\n/**\n * Used to refer to an already-installed component.\n */\nclass InstalledComponent<Definition extends ComponentDefinition<any, any>> {\n  /**\n   * @internal\n   */\n  _definition: Definition;\n\n  /**\n   * @internal\n   */\n  _name: string;\n\n  /**\n   * @internal\n   */\n  [toReferencePath]: string;\n\n  constructor(definition: Definition, name: string) {\n    this._definition = definition;\n    this._name = name;\n    this[toReferencePath] = `_reference/childComponent/${name}`;\n  }\n\n  get exports(): ComponentDefinitionExports<Definition> {\n    return createExports(this._name, []);\n  }\n}\n\nfunction createExports(name: string, pathParts: string[]): any {\n  const handler: ProxyHandler<any> = {\n    get(_, prop: string | symbol) {\n      if (typeof prop === \"string\") {\n        const newParts = [...pathParts, prop];\n        return createExports(name, newParts);\n      } else if (prop === toReferencePath) {\n        let reference = `_reference/childComponent/${name}`;\n        for (const part of pathParts) {\n          reference += `/${part}`;\n        }\n        return reference;\n      } else {\n        return undefined;\n      }\n    },\n  };\n  return new Proxy({}, handler);\n}\n\nfunction install<Definition extends ComponentDefinition<any>>(\n  this: CommonDefinitionData,\n  definition: Definition,\n  options: {\n    name?: string;\n    args?: Infer<ComponentDefinitionArgs<Definition>>;\n  } = {},\n): InstalledComponent<Definition> {\n  // At runtime an imported component will have this shape.\n  const importedComponentDefinition =\n    definition as unknown as ImportedComponentDefinition;\n  if (typeof importedComponentDefinition.componentDefinitionPath !== \"string\") {\n    throw new Error(\n      \"Component definition does not have the required componentDefinitionPath property. This code only works in Convex runtime.\",\n    );\n  }\n  const name =\n    options.name ||\n    importedComponentDefinition.componentDefinitionPath.split(\"/\").pop()!;\n  this._childComponents.push([\n    name,\n    importedComponentDefinition,\n    options.args ?? {},\n  ]);\n  return new InstalledComponent(definition, name);\n}\n\nfunction installWithInit<Definition extends ComponentDefinition<any>>(\n  this: ComponentDefinitionData,\n  definition: Definition,\n  options: {\n    name?: string;\n    onInit: (ctx: InitCtx, args: any) => any;\n  },\n): InstalledComponent<Definition> {\n  // At runtime an imported component will have this shape.\n  const importedComponentDefinition =\n    definition as unknown as ImportedComponentDefinition;\n  if (typeof importedComponentDefinition.componentDefinitionPath !== \"string\") {\n    throw new Error(\n      \"Component definition does not have the required componentDefinitionPath property. This code only works in Convex runtime.\",\n    );\n  }\n  const name =\n    options.name ||\n    importedComponentDefinition.componentDefinitionPath.split(\"/\").pop()!;\n  this._childComponents.push([name, importedComponentDefinition, null]);\n  this._onInitCallbacks[name] = (s) => invokeOnInit(s, options.onInit);\n  return new InstalledComponent(definition, name);\n}\n\nfunction invokeOnInit(\n  argsStr: string,\n  onInit: (ctx: InitCtx, args: any) => any,\n): string {\n  const argsJson = JSON.parse(argsStr);\n  const args = jsonToConvex(argsJson);\n  const result = onInit({}, args);\n  return JSON.stringify(convexToJson(result));\n}\n\nfunction mount(this: CommonDefinitionData, exports: any) {\n  function visit(definition: CommonDefinitionData, path: string[], value: any) {\n    const valueReference = value[toReferencePath];\n    if (valueReference) {\n      if (!path.length) {\n        throw new Error(\"Empty export path\");\n      }\n      let current = definition._exportTree;\n      for (const part of path.slice(0, -1)) {\n        let next = current[part];\n        if (typeof next === \"string\") {\n          throw new Error(\n            `Mount path ${path.join(\".\")} collides with existing export`,\n          );\n        }\n        if (!next) {\n          next = {};\n          current[part] = next;\n        }\n        current = next;\n      }\n      const last = path[path.length - 1];\n      if (current[last]) {\n        throw new Error(\n          `Mount path ${path.join(\".\")} collides with existing export`,\n        );\n      }\n      current[last] = valueReference;\n    } else {\n      for (const [key, child] of Object.entries(value)) {\n        visit(definition, [...path, key], child);\n      }\n    }\n  }\n  if (exports[toReferencePath]) {\n    throw new Error(`Cannot mount another component's exports at the root`);\n  }\n  visit(this, [], exports);\n}\n\nfunction mountHttp(\n  this: CommonDefinitionData,\n  pathPrefix: string,\n  component: InstalledComponent<any>,\n) {\n  if (!pathPrefix.startsWith(\"/\")) {\n    throw new Error(`Path prefix '${pathPrefix}' does not start with a /`);\n  }\n  if (!pathPrefix.endsWith(\"/\")) {\n    throw new Error(`Path prefix '${pathPrefix}' must end with a /`);\n  }\n  if (this._httpMounts[pathPrefix]) {\n    throw new Error(`Path '${pathPrefix}' is already mounted.`);\n  }\n  const path = extractReferencePath(component);\n  if (!path) {\n    throw new Error(\"`mountHttp` must be called with an `InstalledComponent`.\");\n  }\n  this._httpMounts[pathPrefix] = path;\n}\n\n// At runtime when you import a ComponentDefinition, this is all it is\n/**\n * @internal\n */\nexport type ImportedComponentDefinition = {\n  componentDefinitionPath: string;\n};\n\nfunction exportAppForAnalysis(\n  this: ComponentDefinition<any> & AppDefinitionData,\n): AppDefinitionAnalysis {\n  const definitionType = { type: \"app\" as const };\n  const childComponents = serializeChildComponents(this._childComponents);\n  return {\n    definitionType,\n    childComponents: childComponents as any,\n    httpMounts: this._httpMounts,\n    exports: serializeExportTree(this._exportTree),\n  };\n}\n\nfunction serializeExportTree(tree: ExportTree): any {\n  const branch: any[] = [];\n  for (const [key, child] of Object.entries(tree)) {\n    let node;\n    if (typeof child === \"string\") {\n      node = { type: \"leaf\", leaf: child };\n    } else {\n      node = serializeExportTree(child);\n    }\n    branch.push([key, node]);\n  }\n  return { type: \"branch\", branch };\n}\n\nfunction serializeChildComponents(\n  childComponents: [\n    string,\n    ImportedComponentDefinition,\n    Record<string, any> | null,\n  ][],\n): {\n  name: string;\n  path: string;\n  args: [string, { type: \"value\"; value: string }][] | null;\n}[] {\n  return childComponents.map(([name, definition, p]) => {\n    let args: [string, { type: \"value\"; value: string }][] | null = null;\n    if (p !== null) {\n      args = [];\n      for (const [name, value] of Object.entries(p)) {\n        if (value !== undefined) {\n          args.push([\n            name,\n            { type: \"value\", value: JSON.stringify(convexToJson(value)) },\n          ]);\n        }\n      }\n    }\n    // we know that components carry this extra information\n    const path = definition.componentDefinitionPath;\n    if (!path)\n      throw new Error(\n        \"no .componentPath for component definition \" +\n          JSON.stringify(definition, null, 2),\n      );\n\n    return {\n      name: name!,\n      path: path!,\n      args,\n    };\n  });\n}\n\nfunction exportComponentForAnalysis(\n  this: ComponentDefinition<any> & ComponentDefinitionData,\n): ComponentDefinitionAnalysis {\n  const args: [string, { type: \"value\"; value: string }][] = Object.entries(\n    this._args,\n  ).map(([name, validator]) => [\n    name,\n    {\n      type: \"value\",\n      value: JSON.stringify(validator.json),\n    },\n  ]);\n  const definitionType: ComponentDefinitionType = {\n    type: \"childComponent\" as const,\n    name: this._name,\n    args,\n  };\n  const childComponents = serializeChildComponents(this._childComponents);\n  return {\n    name: this._name,\n    definitionType,\n    childComponents: childComponents as any,\n    httpMounts: this._httpMounts,\n    exports: serializeExportTree(this._exportTree),\n  };\n}\n\n// This is what is actually contained in a ComponentDefinition.\ntype RuntimeComponentDefinition = Omit<\n  ComponentDefinition<any, any>,\n  \"__args\" | \"__exports\"\n> &\n  ComponentDefinitionData & {\n    export: () => ComponentDefinitionAnalysis;\n  };\ntype RuntimeAppDefinition = AppDefinition &\n  AppDefinitionData & {\n    export: () => AppDefinitionAnalysis;\n  };\n\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function defineComponent<\n  Args extends PropertyValidators = EmptyObject,\n  Exports extends ComponentExports = any,\n>(\n  name: string,\n  options: { args?: Args } = {},\n): ComponentDefinition<Args, Exports> {\n  const ret: RuntimeComponentDefinition = {\n    _isRoot: false,\n    _name: name,\n    _args: options.args || {},\n    _childComponents: [],\n    _httpMounts: {},\n    _exportTree: {},\n    _onInitCallbacks: {},\n\n    export: exportComponentForAnalysis,\n    install,\n    installWithInit,\n    mount,\n    mountHttp,\n\n    // pretend to conform to ComponentDefinition, which temporarily expects __args\n    ...({} as { __args: any; __exports: any }),\n  };\n  return ret as any as ComponentDefinition<Args, Exports>;\n}\n\n/**\n * Experimental - DO NOT USE.\n */\n// TODO Make this not experimental.\nexport function defineApp(): AppDefinition {\n  const ret: RuntimeAppDefinition = {\n    _isRoot: true,\n    _childComponents: [],\n    _httpMounts: {},\n    _exportTree: {},\n\n    export: exportAppForAnalysis,\n    install,\n    mount,\n    mountHttp,\n  };\n  return ret as AppDefinition;\n}\n\ntype AnyInterfaceType = {\n  [key: string]: AnyInterfaceType;\n} & AnyFunctionReference;\nexport type AnyComponentReference = Record<string, AnyInterfaceType>;\n\ntype AnyChildComponents = Record<string, AnyComponentReference>;\n\n/**\n * @internal\n */\nexport function currentSystemUdfInComponent(\n  componentId: string,\n): AnyComponentReference {\n  return {\n    [toReferencePath]: `_reference/currentSystemUdfInComponent/${componentId}`,\n  };\n}\n\nfunction createChildComponents(\n  root: string,\n  pathParts: string[],\n): AnyChildComponents {\n  const handler: ProxyHandler<object> = {\n    get(_, prop: string | symbol) {\n      if (typeof prop === \"string\") {\n        const newParts = [...pathParts, prop];\n        return createChildComponents(root, newParts);\n      } else if (prop === toReferencePath) {\n        if (pathParts.length < 1) {\n          const found = [root, ...pathParts].join(\".\");\n          throw new Error(\n            `API path is expected to be of the form \\`${root}.childComponent.functionName\\`. Found: \\`${found}\\``,\n          );\n        }\n        return `_reference/childComponent/` + pathParts.join(\"/\");\n      } else {\n        return undefined;\n      }\n    },\n  };\n  return new Proxy({}, handler);\n}\n\n/**\n *\n * @internal\n */\nexport function createComponentArg(): (ctx: any, name: string) => any {\n  return (ctx: any, name: string) => {\n    const result = performSyscall(\"1.0/componentArgument\", {\n      name,\n    });\n    return (jsonToConvex(result) as any).value;\n  };\n}\n\n/**\n * @internal\n */\nexport const componentsGeneric = () => createChildComponents(\"components\", []);\n\n/**\n * @internal\n */\nexport type AnyComponents = AnyChildComponents;\n"],
  "mappings": "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",
  "names": ["name"]
}

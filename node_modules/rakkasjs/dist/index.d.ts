import { H as HeadProps, U as UseQueryOptions, a as UseMutationOptions, b as UseMutationIdleResult, c as UseMutationLoadingResult, d as UseMutationErrorResult, e as UseMutationSuccessResult, A as ActionResult, Q as QueryResult, f as UseMutationResult, E as EventSourceResult } from './hattip-handler-DUB3s5pu.js';
export { s as ActionContext, t as ActionHandler, B as BaseRouteConfig, C as CommonHooks, y as CommonPluginFactory, x as CommonPluginOptions, m as HeadersFunction, L as Layout, i as LayoutProps, $ as Link, W as LinkProps, r as LookupHookResult, M as MutationFunction, _ as NavigationOptions, g as Page, w as PageContext, P as PageLocals, h as PageProps, p as PageRouteGuard, q as PageRouteGuardContext, j as PreloadContext, l as PreloadFunction, k as PreloadResult, n as PrerenderFunction, o as PrerenderResult, D as QueryClient, z as QueryFn, R as RakkasBrowserGlobal, a9 as Redirect, a7 as RedirectProps, a8 as ResponseHeaders, a6 as ResponseHeadersProps, v as RouteConfig, u as RouteConfigExport, S as ServerSidePageContext, a0 as StyledLink, X as StyledLinkProps, Z as UseLocationResult, K as UseMutationMethods, O as UseMutationsOptions, T as UseMutationsResult, Y as UseSubmitOptions, a5 as cancelLastNavigation, a3 as navigate, a2 as prefetchRoute, J as queryOptions, a4 as useLocation, N as useMutation, V as useMutations, I as usePageContext, F as useQuery, G as useQueryClient, a1 as useSubmit } from './hattip-handler-DUB3s5pu.js';
import React, { ReactElement, ReactNode, FC, PropsWithChildren, ComponentType, FunctionComponent, Component, ErrorInfo, FormEvent } from 'react';
import { RequestContext } from '@hattip/compose';
export { RequestContext, Locals as ServerSideLocals } from '@hattip/compose';
import { FallbackProps as FallbackProps$1 } from 'react-error-boundary';
import 'vite';
import '@hattip/core';

/**
 * Control head tags in your document head.
 */
declare function useHead(props: HeadProps): void;
declare function Head(props: HeadProps): ReactElement;

type NavigationBlockerResult = {
    isBlocking: false;
    leave?: undefined;
    stay?: undefined;
} | {
    isBlocking: true;
    leave(): void;
    stay(): void;
};
/**
 * Add a navigation blocker.
 *
 * When a navigation blocker is active, the hook will return an object with
 * `isBlocking` set to `true`. The `leave` method will allow the navigation to
 * proceed, while the `stay` method will keep the navigation from happening.
 *
 * @param condition Whether to block navigation
 */
declare function useNavigationBlocker(condition: boolean): NavigationBlockerResult;

/** {@link ClientOnly} props */
interface ClientOnlyProps {
    /** Fallback to be rendered during SSR */
    fallback: ReactNode;
    /** Content to be rendered on client-side */
    children: ReactNode;
}
/** Opt out of server-side rendering */
declare function ClientOnly(props: ClientOnlyProps): ReactNode;
/**
 * @deprecated {@link ClientOnly} now has the exact same functionality.
 */
declare const ClientSuspense: typeof ClientOnly;

/** @see https://github.com/bvaughn/react-error-boundary */
declare const ErrorBoundary: FC<PropsWithChildren<ErrorBoundaryProps>>;

declare const useErrorBoundary: <TError = any>() => UseErrorBoundaryApi<TError>;
type FallbackProps = {
    error: any;
    resetErrorBoundary: (...args: any[]) => void;
};
type ErrorBoundarySharedProps = PropsWithChildren<{
    onError?: (error: Error, info: ErrorInfo) => void;
    onReset?: (details: {
        reason: "imperative-api";
        args: any[];
    } | {
        reason: "keys";
        prev: any[] | undefined;
        next: any[] | undefined;
    }) => void;
    resetKeys?: any[];
}>;
type ErrorBoundaryPropsWithComponent = ErrorBoundarySharedProps & {
    fallback?: never;
    FallbackComponent: ComponentType<FallbackProps>;
    fallbackRender?: never;
};
type ErrorBoundaryPropsWithRender = ErrorBoundarySharedProps & {
    fallback?: never;
    FallbackComponent?: never;
    fallbackRender: FallbackRender;
};
type ErrorBoundaryPropsWithFallback = ErrorBoundarySharedProps & {
    fallback: ReactElement<unknown, string | FunctionComponent | typeof Component> | null;
    FallbackComponent?: never;
    fallbackRender?: never;
};
type ErrorBoundaryProps = ErrorBoundaryPropsWithFallback | ErrorBoundaryPropsWithComponent | ErrorBoundaryPropsWithRender;
type UseErrorBoundaryApi<TError> = {
    resetBoundary: () => void;
    showBoundary: (error: TError) => void;
};
type FallbackRender = (props: FallbackProps) => ReactNode;

declare function DefaultErrorPage(props: FallbackProps$1): React.JSX.Element;

/**
 * Hook for getting the route parameters.
 */
declare function useRouteParams<T extends Record<string, string>>(): T;

/**
 * Hook for getting the request context. Returns undefined on the client.
 */
declare function useRequestContext(): RequestContext<unknown> | undefined;
/** Callback passed to useServerSide/runServerside family of functions */
type ServerSideFunction<T> = (context: RunServerSideContext) => T | Promise<T>;
interface RunServerSideContext extends RequestContext {
    /** Response headers. Especially useful for setting cache control headers. */
    headers: Headers;
}
/** Options for {@link runServerSideQuery} */
interface RunServerSideQueryOptions {
    /**
     * Unique ID for this query. Rakkas will generate a unique ID if not provided.
     * This must be a string literal that is unique across the entire application.
     */
    uniqueId?: string;
    /**
     * If true, a POST request will be sent instead of GET. It may be useful
     * when the query requires a large amount of data to be sent from the
     * client. The down side is that it cannot be prerendered or cached so it
     * shouldn't be used when rendering static pages.
     */
    usePostMethod?: boolean;
}
/** Options for {@link runServerSideMutation} */
interface RunServerSideMutationOptions {
    /**
     * Unique ID for this mutation. Rakkas will generate a unique ID if not provided.
     * This must be a string literal that is unique across the entire application.
     */
    uniqueId?: string;
}
/** Options for {@link useServerSideQuery} */
interface UseServerSideQueryOptions<T = unknown, Enabled extends boolean = true, InitialData extends T | undefined = undefined, PlaceholderData = undefined> extends UseQueryOptions<T, Enabled, InitialData, PlaceholderData> {
    /**
     * Unique ID for this query. Rakkas will generate a unique ID if not provided.
     * This must be a string literal that is unique across the entire application.
     */
    uniqueId?: string;
    /** Query key. Rakkas will generate a unique key if not provided. */
    queryKey?: string;
    /** @deprecated use `queryKey` instead. */
    key?: string;
    /**
     * If true, a POST request will be sent instead of GET. It may be useful
     * when the query requires a large amount of data to be sent from the
     * client. The down side is that it cannot be prerendered or cached so it
     * shouldn't be used when rendering static pages.
     */
    usePostMethod?: boolean;
}
/** Options for {@link useServerSideMutation} */
interface UseServerSideMutationOptions<T = unknown, V = unknown> extends UseMutationOptions<T, V> {
    /**
     * Unique ID for this mutation. Rakkas will generate a unique ID if not provided.
     * This must be a string literal that is unique across the entire application.
     */
    uniqueId?: string;
}
type UseFormMutationResult<T> = {
    action: string;
    submitHandler(event: FormEvent<HTMLFormElement>): void;
} & (UseMutationIdleResult | UseMutationLoadingResult | UseMutationErrorResult | UseMutationSuccessResult<T>);
type UseFormMutationFn<T> = (context: RunServerSideContext) => ActionResult<T> | Promise<ActionResult<T>>;

/**
 * Hook for running a piece of code on the server to fetch data. The callback
 * will always run on the server. When the hook is rendered on the client,
 * Rakkas will send a request to the server. You can think of this hook as a
 * convenience wrapper around {@link useQuery} and {@link runServerSideQuery}.
 *
 * @param fn The function to run on the server
 * @param options Options for the query
 */
declare const useServerSideQuery: <T, Enabled extends boolean = true, InitialData extends T | undefined = undefined, PlaceholderData = undefined>(fn: ServerSideFunction<T>, options?: UseServerSideQueryOptions<T, Enabled, InitialData, PlaceholderData>) => QueryResult<T, Enabled, InitialData, PlaceholderData>;
/**
 * Runs a piece of code on the server. The callback will always run the server.
 * When the hook is rendered on the client, Rakkas will send a request to the
 * server.
 *
 * @param context The request context
 * @param fn The function to run on the server
 * @param options Options for the query
 */
declare const runServerSideQuery: <T>(context: RequestContext | undefined, fn: ServerSideFunction<T>, options?: RunServerSideQueryOptions) => Promise<T>;
/**
 * Runs a piece of code on the server. The callback will always run the server.
 * When the hook is rendered on the client, Rakkas will send a request to the
 * server. The difference between this and {@link runServerSideQuery} is that
 * `runServerSideMutation` can only run on the client and, as such, it doesn't
 * need a request context argument.
 *
 * @param fn The function to run on the server
 */
declare const runServerSideMutation: <T>(fn: ServerSideFunction<T>, options?: RunServerSideMutationOptions) => Promise<T>;
/**
 * Hook for running a piece of code on the server to modify some data. When the
 * hook is rendered, Rakkas will send a request to the server and the callback
 * will always run on the server. You can think of this hook as a convenience
 * wrapper around {@link useMutation} and {@link runServerSideMutation}.
 *
 * @param fn The function to run on the server
 * @param options Options for the mutation
 */
declare const useServerSideMutation: <T, V = void>(fn: (context: RunServerSideContext, vars: V) => T | Promise<T>, options?: UseServerSideMutationOptions<T, V>) => UseMutationResult<T, V>;
declare const useFormMutation: <T>(fn: UseFormMutationFn<T>, options?: UseServerSideMutationOptions<T, void>) => UseFormMutationResult<T>;
declare const useServerSentEvents: <T>(fn: ServerSideFunction<ReadableStream<T>>) => EventSourceResult<T>;

declare function getRequestContext(): RequestContext | undefined;

export { ActionResult, ClientOnly, type ClientOnlyProps, ClientSuspense, DefaultErrorPage, ErrorBoundary, type ErrorBoundaryProps, type ErrorBoundaryPropsWithComponent, type ErrorBoundaryPropsWithFallback, type ErrorBoundaryPropsWithRender, type FallbackProps, Head, HeadProps, QueryResult, type RunServerSideContext, type RunServerSideMutationOptions, type RunServerSideQueryOptions, type ServerSideFunction, type UseErrorBoundaryApi, type UseFormMutationFn, type UseFormMutationResult, UseMutationErrorResult, UseMutationIdleResult, UseMutationLoadingResult, UseMutationOptions, UseMutationResult, UseMutationSuccessResult, UseQueryOptions, type UseServerSideMutationOptions, type UseServerSideQueryOptions, getRequestContext, runServerSideMutation as runSSM, runServerSideQuery as runSSQ, runServerSideMutation, runServerSideQuery, useErrorBoundary, useFormMutation, useHead, useNavigationBlocker, useRequestContext, useRouteParams, useServerSentEvents as useSSE, useServerSideMutation as useSSM, useServerSideQuery as useSSQ, useServerSentEvents, useServerSideMutation, useServerSideQuery };

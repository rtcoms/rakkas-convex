import {
  ClientOnly,
  ClientSuspense,
  DefaultErrorPage,
  ErrorBoundary,
  Head,
  Link,
  Redirect,
  ResponseHeaders,
  StyledLink,
  cancelLastNavigation,
  encodeFileNameSafe,
  navigate,
  prefetchRoute,
  queryOptions,
  useErrorBoundary,
  useEventSource,
  useHead,
  useLocation,
  useMutation,
  useMutations,
  useNavigationBlocker,
  usePageContext,
  useQuery,
  useQueryClient,
  useRequestContext,
  useRouteParams,
  useSubmit
} from "./chunk-AC6BWNGT.js";
import {
  __commonJS,
  __toESM
} from "./chunk-JSBRDJBE.js";

// ../../node_modules/.pnpm/@brillout+json-serializer@0.5.13/node_modules/@brillout/json-serializer/dist/cjs/types.js
var require_types = __commonJS({
  "../../node_modules/.pnpm/@brillout+json-serializer@0.5.13/node_modules/@brillout/json-serializer/dist/cjs/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.types = void 0;
    var types = [
      ts({
        is: (val) => val === void 0,
        match: (str) => str === "!undefined",
        serialize: () => "!undefined",
        deserialize: () => void 0
      }),
      ts({
        is: (val) => val === Infinity,
        match: (str) => str === "!Infinity",
        serialize: () => "!Infinity",
        deserialize: () => Infinity
      }),
      ts({
        is: (val) => val === -Infinity,
        match: (str) => str === "!-Infinity",
        serialize: () => "!-Infinity",
        deserialize: () => -Infinity
      }),
      ts({
        is: (val) => typeof val === "number" && isNaN(val),
        match: (str) => str === "!NaN",
        serialize: () => "!NaN",
        deserialize: () => NaN
      }),
      ts({
        is: (val) => val instanceof Date,
        match: (str) => str.startsWith("!Date:"),
        serialize: (val) => "!Date:" + val.toISOString(),
        deserialize: (str) => new Date(str.slice("!Date:".length))
      }),
      ts({
        is: (val) => typeof val === "bigint",
        match: (str) => str.startsWith("!BigInt:"),
        serialize: (val) => "!BigInt:" + val.toString(),
        deserialize: (str) => {
          if (typeof BigInt === "undefined") {
            throw new Error("Your JavaScript environement does not support BigInt. Consider adding a polyfill.");
          }
          return BigInt(str.slice("!BigInt:".length));
        }
      }),
      ts({
        is: (val) => val instanceof RegExp,
        match: (str) => str.startsWith("!RegExp:"),
        serialize: (val) => "!RegExp:" + val.toString(),
        deserialize: (str) => {
          str = str.slice("!RegExp:".length);
          const args = str.match(/\/(.*)\/(.*)?/);
          const pattern = args[1];
          const flags = args[2];
          return new RegExp(pattern, flags);
        }
      }),
      ts({
        is: (val) => val instanceof Map,
        match: (str) => str.startsWith("!Map:"),
        serialize: (val, serializer) => "!Map:" + serializer(Array.from(val.entries())),
        deserialize: (str, deserializer) => new Map(deserializer(str.slice("!Map:".length)))
      }),
      ts({
        is: (val) => val instanceof Set,
        match: (str) => str.startsWith("!Set:"),
        serialize: (val, serializer) => "!Set:" + serializer(Array.from(val.values())),
        deserialize: (str, deserializer) => new Set(deserializer(str.slice("!Set:".length)))
      }),
      // Avoid collisions with the special strings defined above
      ts({
        is: (val) => typeof val === "string" && val.startsWith("!"),
        match: (str) => str.startsWith("!"),
        serialize: (val) => "!" + val,
        deserialize: (str) => str.slice(1)
      })
    ];
    exports.types = types;
    function ts(t) {
      return t;
    }
  }
});

// ../../node_modules/.pnpm/@brillout+json-serializer@0.5.13/node_modules/@brillout/json-serializer/dist/cjs/utils/isReactElement.js
var require_isReactElement = __commonJS({
  "../../node_modules/.pnpm/@brillout+json-serializer@0.5.13/node_modules/@brillout/json-serializer/dist/cjs/utils/isReactElement.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isReactElement = void 0;
    function isReactElement(value) {
      return typeof value === "object" && value !== null && String(value["$$typeof"]) === "Symbol(react.element)";
    }
    exports.isReactElement = isReactElement;
  }
});

// ../../node_modules/.pnpm/@brillout+json-serializer@0.5.13/node_modules/@brillout/json-serializer/dist/cjs/utils/isCallable.js
var require_isCallable = __commonJS({
  "../../node_modules/.pnpm/@brillout+json-serializer@0.5.13/node_modules/@brillout/json-serializer/dist/cjs/utils/isCallable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isCallable = void 0;
    function isCallable(thing) {
      return thing instanceof Function || typeof thing === "function";
    }
    exports.isCallable = isCallable;
  }
});

// ../../node_modules/.pnpm/@brillout+json-serializer@0.5.13/node_modules/@brillout/json-serializer/dist/cjs/utils/isObject.js
var require_isObject = __commonJS({
  "../../node_modules/.pnpm/@brillout+json-serializer@0.5.13/node_modules/@brillout/json-serializer/dist/cjs/utils/isObject.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isObject = void 0;
    function isObject(value) {
      if (typeof value !== "object" || value === null) {
        return false;
      }
      if (Array.isArray(value)) {
        return false;
      }
      return true;
    }
    exports.isObject = isObject;
  }
});

// ../../node_modules/.pnpm/@brillout+json-serializer@0.5.13/node_modules/@brillout/json-serializer/dist/cjs/utils/replacerWithPath.js
var require_replacerWithPath = __commonJS({
  "../../node_modules/.pnpm/@brillout+json-serializer@0.5.13/node_modules/@brillout/json-serializer/dist/cjs/utils/replacerWithPath.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.replacerWithPath = void 0;
    function replacerWithPath(replacer) {
      const pathMap = /* @__PURE__ */ new WeakMap();
      return function(key, value) {
        var _a;
        const pathPrevious = (_a = pathMap.get(this)) !== null && _a !== void 0 ? _a : [];
        const path = [...pathPrevious];
        if (key !== "") {
          const pathEntry = !Array.isArray(this) ? key : parseInt(key, 10);
          path.push(pathEntry);
        }
        if (isIterable(value))
          pathMap.set(value, path);
        return replacer.call(this, key, value, path);
      };
    }
    exports.replacerWithPath = replacerWithPath;
    function isIterable(value) {
      return value === Object(value);
    }
  }
});

// ../../node_modules/.pnpm/@brillout+json-serializer@0.5.13/node_modules/@brillout/json-serializer/dist/cjs/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/.pnpm/@brillout+json-serializer@0.5.13/node_modules/@brillout/json-serializer/dist/cjs/stringify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isJsonSerializerError = exports.stringify = void 0;
    var types_1 = require_types();
    var isReactElement_1 = require_isReactElement();
    var isCallable_1 = require_isCallable();
    var isObject_1 = require_isObject();
    var replacerWithPath_1 = require_replacerWithPath();
    function stringify3(value, {
      forbidReactElements,
      space,
      valueName,
      sortObjectKeys,
      // Used by Vike: https://github.com/vikejs/vike/blob/b4ba6b70e6bdc2e1f460c0d2e4c3faae5d0a733c/vike/node/plugin/plugins/importUserCode/v1-design/getConfigValuesSerialized.ts#L78
      replacer: replacerUserProvided
    } = {}) {
      const serializer = (val) => JSON.stringify(val, (0, replacerWithPath_1.replacerWithPath)(replacer), space);
      return serializer(value);
      function replacer(key, value2, path) {
        {
          const ret = replacerUserProvided === null || replacerUserProvided === void 0 ? void 0 : replacerUserProvided.call(this, key, value2);
          if (ret)
            return ret.replacement;
        }
        if (forbidReactElements && (0, isReactElement_1.isReactElement)(value2)) {
          throw genErr({
            value: value2,
            valueType: "React element",
            path,
            rootValueName: valueName
          });
        }
        if ((0, isCallable_1.isCallable)(value2)) {
          const functionName = value2.name;
          throw genErr({
            value: value2,
            valueType: "function",
            path,
            rootValueName: valueName,
            problematicValueName: path.length === 0 ? functionName : void 0
          });
        }
        const valueOriginal = this[key];
        for (const { is, serialize } of types_1.types.slice().reverse()) {
          if (is(valueOriginal)) {
            return serialize(valueOriginal, serializer);
          }
        }
        if (sortObjectKeys && (0, isObject_1.isObject)(value2)) {
          const copy = {};
          Object.keys(value2).sort().forEach((key2) => {
            copy[key2] = value2[key2];
          });
          value2 = copy;
        }
        return value2;
      }
    }
    exports.stringify = stringify3;
    function genErr({ value, valueType, path, rootValueName, problematicValueName }) {
      const subjectName = getSubjectName({ path, rootValueName, problematicValueName });
      const messageCore = `cannot serialize ${subjectName} because it's a ${valueType}`;
      const err = new Error(`[@brillout/json-serializer](https://github.com/brillout/json-serializer) ${messageCore}.`);
      const pathString = getPathString(path, true);
      const errAddendum = {
        [stamp]: true,
        messageCore,
        value,
        path,
        pathString,
        subjectName
      };
      Object.assign(err, errAddendum);
      return err;
    }
    var stamp = "_isJsonSerializerError";
    function isJsonSerializerError(thing) {
      return (0, isObject_1.isObject)(thing) && thing[stamp] === true;
    }
    exports.isJsonSerializerError = isJsonSerializerError;
    function getSubjectName({ path, rootValueName, problematicValueName }) {
      const pathString = getPathString(path, !rootValueName);
      let subjectName;
      if (!pathString) {
        subjectName = rootValueName || problematicValueName || "value";
      } else {
        if (problematicValueName) {
          subjectName = problematicValueName + " at ";
        } else {
          subjectName = "";
        }
        subjectName = subjectName + (rootValueName || "") + pathString;
      }
      return subjectName;
    }
    function getPathString(path, canBeFirstKey) {
      const pathString = path.map((key, i) => {
        if (typeof key === "number") {
          return `[${key}]`;
        }
        if (i === 0 && canBeFirstKey && isKeyDotNotationCompatible(key)) {
          return key;
        }
        return getPropAccessNotation(key);
      }).join("");
      return pathString;
    }
    function getPropAccessNotation(key) {
      return typeof key === "string" && isKeyDotNotationCompatible(key) ? `.${key}` : `[${JSON.stringify(key)}]`;
    }
    function isKeyDotNotationCompatible(key) {
      return /^[a-z0-9\$_]+$/i.test(key);
    }
  }
});

// src/features/run-server-side/lib-client.tsx
var import_stringify2 = __toESM(require_stringify(), 1);

// src/features/run-server-side/implementation/use-form-action.ts
var import_stringify = __toESM(require_stringify(), 1);
function useFormAction(desc) {
  const { current: url } = useLocation();
  const [callSiteId, closure] = desc;
  const stringified = closure.map((x) => (0, import_stringify.stringify)(x));
  let closurePath = stringified.map(encodeFileNameSafe).join("/");
  if (closurePath) closurePath = "/" + closurePath;
  const actionPath = callSiteId + closurePath;
  const actionUrl = new URL(url);
  actionUrl.searchParams.set("_action", actionPath);
  return actionUrl;
}

// src/features/run-server-side/lib-client.tsx
function runSSQImpl(_, desc, options = {}) {
  const [callSiteId, closure] = desc;
  const stringified = closure.map((x) => (0, import_stringify2.stringify)(x));
  return sendRequest(callSiteId, stringified, options.usePostMethod ?? false);
}
function useSSQImpl(desc, options = {}) {
  const [callSiteId, closure] = desc;
  const {
    // eslint-disable-next-line deprecation/deprecation
    key: oldKey,
    queryKey,
    usePostMethod = false,
    ...useQueryOptions
  } = options;
  const userKey = queryKey ?? oldKey;
  const stringified = closure.map((x) => (0, import_stringify2.stringify)(x));
  const key = userKey ?? `$ss:${callSiteId}:${stringified}`;
  return useQuery(
    key,
    () => sendRequest(callSiteId, stringified, usePostMethod),
    useQueryOptions
  );
}
function useSSEImpl(desc) {
  const [callSiteId, closure] = desc;
  const stringified = closure.map((x) => (0, import_stringify2.stringify)(x));
  let closurePath = stringified.map(encodeFileNameSafe).join("/");
  if (closurePath) closurePath = "/" + closurePath;
  const url = "/_app/data/" + callSiteId + closurePath + "/d.js";
  return useEventSource(url);
}
function runSSMImpl(desc) {
  const [callSiteId, closure, vars] = desc;
  const stringified = closure.map((x) => (0, import_stringify2.stringify)(x));
  return sendRequest(callSiteId, stringified, true, vars);
}
function useFormMutationImpl(desc, options) {
  const action = useFormAction(desc).href;
  const submit = useSubmit(options);
  return {
    action,
    ...submit
  };
}
function useSSMImpl(desc, options) {
  return useMutation((vars) => runSSMImpl([...desc, vars]), options);
}
function sendRequest(callSiteId, stringified, usePostMethod, vars) {
  let response;
  const prefix = "/_app/data/";
  if (usePostMethod) {
    response = fetch(prefix + callSiteId, {
      method: "POST",
      body: "[[" + stringified.join(",") + "]" + (vars !== void 0 ? "," + (0, import_stringify2.stringify)(vars) : "") + "]",
      headers: {
        "Content-Type": "application/x.brillout-json-serializer+json"
      }
    });
  } else {
    let closurePath = stringified.map(encodeFileNameSafe).join("/");
    if (closurePath) closurePath = "/" + closurePath;
    response = fetch(prefix + callSiteId + closurePath + "/d.js");
  }
  return response.then(async (r) => {
    if (!r.ok) {
      if (r.status === 404) {
        window.location.reload();
        await new Promise(() => {
        });
      }
      const message = await r.text();
      throw new Error(message || r.statusText);
    }
    const text = await r.text();
    return (0, eval)("(" + text + ")");
  });
}
var useServerSideQuery = useSSQImpl;
var runServerSideQuery = runSSQImpl;
var runServerSideMutation = runSSMImpl;
var useServerSideMutation = useSSMImpl;
var useFormMutation = useFormMutationImpl;
var useServerSentEvents = useSSEImpl;

// src/features/async-local-request-context/lib-client.ts
function getRequestContext() {
  return void 0;
}
export {
  ClientOnly,
  ClientSuspense,
  DefaultErrorPage,
  ErrorBoundary,
  Head,
  Link,
  Redirect,
  ResponseHeaders,
  StyledLink,
  cancelLastNavigation,
  getRequestContext,
  navigate,
  prefetchRoute,
  queryOptions,
  runServerSideMutation as runSSM,
  runServerSideQuery as runSSQ,
  runServerSideMutation,
  runServerSideQuery,
  useErrorBoundary,
  useFormMutation,
  useHead,
  useLocation,
  useMutation,
  useMutations,
  useNavigationBlocker,
  usePageContext,
  useQuery,
  useQueryClient,
  useRequestContext,
  useRouteParams,
  useServerSentEvents as useSSE,
  useServerSideMutation as useSSM,
  useServerSideQuery as useSSQ,
  useServerSentEvents,
  useServerSideMutation,
  useServerSideQuery,
  useSubmit
};

import {
  DEFAULT_QUERY_OPTIONS,
  ErrorBoundary,
  Head,
  HeadContext,
  IsomorphicContext,
  LocationContext,
  Redirect,
  RenderedUrlContext,
  RouteParamsContext,
  client_hooks_default,
  createNamedContext,
  defineClientHooks,
  initialize,
  navigationResolve,
  prefetcher,
  restoreScrollPosition,
  sortHooks,
  useLocation
} from "./chunk-AC6BWNGT.js";
import "./chunk-JSBRDJBE.js";

// src/runtime/client-entry.tsx
import React5, { startTransition, StrictMode } from "react";
import { hydrateRoot, createRoot } from "react-dom/client";

// src/runtime/App.tsx
import React2, {
  useContext,
  useDeferredValue,
  useEffect,
  useReducer,
  useState
} from "react";

// src/runtime/feature-common-hooks.ts
import * as commonHooksModule from "rakkasjs:common-hooks";
import pluginFactories, {
  options as configOptions
} from "rakkasjs:plugin-common-hooks";
var commonHooks = [
  ...pluginFactories.map((factory, i) => {
    const { commonPluginOptions = {} } = commonHooksModule;
    return factory(commonPluginOptions, configOptions[i]);
  }),
  commonHooksModule.default
];

// src/internal/find-page.tsx
var beforePageLookupHandlers = sortHooks(
  commonHooks.map((hook) => hook.beforePageLookup)
);
async function findPage(routes, url, path, pageContext, notFound) {
  let rewritten;
  let renderedUrl = url;
  const lookupContext = { ...pageContext, url, renderedUrl };
  if (!notFound) {
    for (const handler of beforePageLookupHandlers) {
      let result = handler(lookupContext);
      if (result instanceof Promise) {
        result = await result;
      }
      if (!result) return void 0;
      if (result === true) continue;
      if ("redirect" in result) {
        const location2 = String(result.redirect);
        return { redirect: location2 };
      } else {
        renderedUrl = new URL(result.rewrite, renderedUrl);
        path = renderedUrl.pathname;
      }
    }
  }
  do {
    rewritten = false;
    outer: for (const route of routes) {
      const re = route[0];
      const match = path.match(re);
      if (!match) continue;
      const params = unescapeParams(match.groups || {}, route[3]);
      const guardContext = { ...pageContext, url, renderedUrl, params };
      const guards = route[2] || [];
      for (const guard of guards) {
        let result = guard(guardContext);
        if (result instanceof Promise) {
          result = await result;
        }
        if (!result) {
          continue outer;
        } else if (result === true) {
          continue;
        } else if ("rewrite" in result) {
          renderedUrl = new URL(result.rewrite, renderedUrl);
          path = renderedUrl.pathname;
          if (url.href !== renderedUrl.href) {
            rewritten = true;
          }
          break outer;
        } else {
          return result;
        }
      }
      return {
        route,
        params,
        renderedUrl
      };
    }
  } while (rewritten);
}
function unescapeParams(params, rest) {
  for (const [key, value] of Object.entries(params)) {
    if (key === rest) continue;
    params[key] = decodeURIComponent(value);
  }
  return params;
}

// src/features/pages/Default404Page.tsx
import React from "react";
function Default404Page() {
  return import.meta.env.DEV ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Head, { title: "Not Found" }), /* @__PURE__ */ React.createElement("h1", null, "Not Found"), /* @__PURE__ */ React.createElement("p", null, "This is Rakkas's default 404 page. It will ", /* @__PURE__ */ React.createElement("b", null, "not be available"), " ", "when you build your application for production and a bare \u201CNot Found\u201D message will be displayed instead."), /* @__PURE__ */ React.createElement("p", null, "Create a ", /* @__PURE__ */ React.createElement("code", null, "$404.page.jsx"), " in your ", /* @__PURE__ */ React.createElement("code", null, "routes"), " ", "directory to provide a custom 404 page.")) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Head, { title: "Not Found" }), /* @__PURE__ */ React.createElement("h1", null, "Not Found"));
}

// src/runtime/App.tsx
function useCurrentUrl() {
  const ssrHref = useContext(LocationContext);
  return new URL(import.meta.env.SSR ? ssrHref : location.href);
}
function App(props) {
  const [id, setId] = useState("initial");
  const currentUrl = useCurrentUrl();
  if (typeof rakkas !== "undefined") {
    rakkas.setNextId = setId;
  }
  const lastRoute = useContext(RouteContext);
  const [updateCounter, update] = useReducer(
    (old) => old + 1 & 268435455,
    0
  );
  const forcedUpdate = (lastRoute.updateCounter || 0) !== updateCounter;
  const actionData = import.meta.env.SSR ? props.ssrActionData : history.state?.actionData;
  if (!import.meta.env.SSR) rakkas.update = update;
  const pageContext = useContext(IsomorphicContext);
  pageContext.actionData = actionData;
  if (!import.meta.env.SSR) {
    prefetcher.prefetch = function prefetch(location2, preload) {
      const url = new URL(location2, currentUrl);
      url.hash = "";
      if (url.origin !== window.location.origin) return;
      loadRoute(
        pageContext,
        url,
        lastRoute.found,
        false,
        actionData,
        props.ssrMeta,
        props.ssrPreloaded,
        props.ssrModules,
        preload ? "preload" : true
      ).catch((e) => {
        console.error(e);
      });
    };
  }
  if ("error" in lastRoute) {
    throw lastRoute.error;
  }
  if (!lastRoute.last || lastRoute.last.id !== void 0 && lastRoute.last.id !== id || forcedUpdate) {
    lastRoute.updateCounter = updateCounter;
    throw loadRoute(
      pageContext,
      currentUrl,
      lastRoute.found,
      false,
      actionData,
      props.ssrMeta,
      props.ssrPreloaded,
      props.ssrModules
    ).then((route) => {
      lastRoute.last = route && { id, ...route };
    }).catch(async () => {
      window.location.reload();
      await new Promise(() => {
      });
    });
  }
  lastRoute.last.id = id;
  const app = lastRoute.last.app;
  return app;
}
var RouteContext = createNamedContext(
  "RouteContext",
  {
    updateCounter: 0
  }
);
async function loadRoute(pageContext, url, lastFound, try404, actionData, ssrMeta, ssrPreloaded, ssrModules, prefetchOnly = false) {
  let found = lastFound;
  const { pathname: originalPathname } = url;
  let updatedComponents;
  if (!found || import.meta.hot) {
    const prodModule = await import("rakkasjs:client-page-routes");
    const routes = prodModule.default;
    const notFoundRoutes = prodModule.notFoundRoutes;
    let pathname = url.pathname;
    const result = await findPage(routes, url, pathname, pageContext, false);
    if (result && "redirect" in result) {
      const location2 = String(result.redirect);
      return {
        pathname: originalPathname,
        search: url.search,
        actionData,
        app: /* @__PURE__ */ React2.createElement(
          Redirect,
          {
            href: location2,
            status: result.status,
            permanent: result.permanent
          }
        )
      };
    }
    found = result;
    while (!found) {
      if (prefetchOnly) return;
      if (!try404) {
        location.assign(url.href);
        await new Promise(() => {
        });
      }
      if (!pathname.endsWith("/")) {
        pathname += "/";
      }
      const result2 = await findPage(
        notFoundRoutes,
        url,
        pathname + "$404",
        pageContext,
        true
      );
      if (result2 && "redirect" in result2) {
        location.assign(result2.redirect);
        await new Promise(() => {
        });
      }
      found = result2;
      if (!found && pathname === "/") {
        found = {
          params: {},
          route: [
            /^\/$/,
            [async () => ({ default: Default404Page })],
            [],
            void 0,
            []
          ],
          renderedUrl: url
        };
      }
      pathname = pathname.split("/").slice(0, -2).join("/") || "/";
    }
  }
  const importers = found.route[1];
  const preloadContext = {
    ...pageContext,
    url,
    renderedUrl: found.renderedUrl,
    params: found.params
  };
  const promises = importers.map(
    async (importer, i) => Promise.resolve(ssrModules?.[importers.length - 1 - i] || importer()).then(
      async (module) => {
        if (prefetchOnly === true) return;
        const preload = import.meta.hot && updatedComponents ? updatedComponents[i]?.preload : module.default?.preload;
        try {
          if (!import.meta.env.SSR && i === rakkas.actionErrorIndex) {
            delete rakkas.actionErrorIndex;
            throw new Error("Action error");
          }
          const preloaded2 = ssrPreloaded?.[i] ?? await preload?.(preloadContext);
          return [module.default, preloaded2];
        } catch (preloadError) {
          return [
            () => {
              throw preloadError;
            }
          ];
        }
      }
    )
  );
  const layoutStack = await Promise.all(promises);
  if (prefetchOnly) return;
  let meta;
  let preloaded = ssrPreloaded;
  if (import.meta.env.SSR) {
    meta = ssrMeta;
  } else {
    preloaded = layoutStack.map((r) => r[1]).reverse();
    meta = {};
    preloaded.forEach(
      (p) => typeof p?.meta === "function" ? p.meta(meta) : Object.assign(meta, p?.meta)
    );
  }
  const components = layoutStack.map(
    (m) => m[0] || (({ children }) => children)
  );
  const errorFiles = /* @__PURE__ */ new Set();
  let app = components.reduce(
    (prev, Component, i) => {
      if (import.meta.env.DEV && typeof Component === "object") {
        errorFiles.add(Component.moduleId);
        Component = ({ children }) => children;
      }
      const preloadResult = preloaded[components.length - i - 1];
      return /* @__PURE__ */ React2.createElement(React2.Fragment, null, preloadResult?.head && /* @__PURE__ */ React2.createElement(Head, { ...preloadResult.head }), /* @__PURE__ */ React2.createElement(
        Component,
        {
          url,
          renderedUrl: found.renderedUrl,
          params: found.params,
          meta,
          actionData
        },
        prev
      ));
    },
    null
  );
  if (import.meta.env.DEV && !import.meta.env.SSR && errorFiles.size) {
    const message = `The following files don't have a default export:

${[
      ...errorFiles
    ].join("\n")}`;
    await (0, eval)(`(async (message) => {
			const { ErrorOverlay } = await import("/@vite/client");
			document.querySelectorAll("vite-error-overlay").forEach((n) => n.close());
			const error = new Error(message);
			error.stack = message;
			document.body.appendChild(new ErrorOverlay(error))
		})`)(message);
  }
  const preloadedRedirect = preloaded.find((p) => p?.redirect)?.redirect;
  app = /* @__PURE__ */ React2.createElement(RenderedUrlContext.Provider, { value: found.renderedUrl }, /* @__PURE__ */ React2.createElement(RouteParamsContext.Provider, { value: found.params }, preloadedRedirect && /* @__PURE__ */ React2.createElement(Redirect, { ...preloadedRedirect }), app, /* @__PURE__ */ React2.createElement(Finish, null)));
  return {
    pathname: originalPathname,
    search: url.search,
    actionData,
    app
  };
}
var initialNavigationEventEmitted = false;
function Finish() {
  const resolve = navigationResolve;
  useEffect(() => {
    resolve?.();
    if (!initialNavigationEventEmitted) {
      initialNavigationEventEmitted = true;
      rakkas.emitNavigationEvent?.(new URL(location.href));
    }
  }, [resolve]);
  return /* @__PURE__ */ React2.createElement(Scroll, null);
}
function Scroll() {
  const { pending } = useLocation();
  const href = useDeferredValue(pending?.href);
  useEffect(() => {
    if (!href) {
      restoreScrollPosition();
    }
  }, [href]);
  return null;
}
if (import.meta.hot) {
  import.meta.hot.accept("/@id/rakkasjs:client-page-routes", () => {
  });
}

// src/features/head/client-hooks.tsx
import React3 from "react";
var client_hooks_default2 = defineClientHooks({
  wrapApp(app) {
    return /* @__PURE__ */ React3.createElement(HeadContext.Provider, { value: { stack: rakkas.headTagStack } }, app);
  }
});

// src/features/client-side-navigation/client-hooks.tsx
import React4 from "react";
var client_hooks_default3 = defineClientHooks({
  beforeStart() {
    initialize();
  },
  wrapApp(app) {
    return /* @__PURE__ */ React4.createElement(LocationContext.Provider, { value: location.href }, app);
  }
});

// src/features/isomorphic-fetch/client-hooks.ts
var client_hooks_default4 = defineClientHooks({
  extendPageContext(ctx) {
    ctx.fetch = (input, init) => fetch(input, init);
  }
});

// src/runtime/feature-client-hooks.tsx
var featureClientHooks = [
  client_hooks_default,
  client_hooks_default2,
  client_hooks_default3,
  client_hooks_default4
];

// src/runtime/client-entry.tsx
import ErrorComponent from "rakkasjs:error-page";
import factories, {
  options as configOptions2
} from "rakkasjs:plugin-client-hooks";
import * as commonHooksModule2 from "rakkasjs:common-hooks";
async function startClient(options = {}, pluginOptions = {}) {
  Object.assign(DEFAULT_QUERY_OPTIONS, options.defaultQueryOptions);
  const { commonPluginOptions = {} } = commonHooksModule2;
  const hooks = [
    ...factories.map(
      (factory, i) => factory(pluginOptions, commonPluginOptions, configOptions2[i])
    ),
    ...featureClientHooks
  ];
  const beforeStartHandlers = sortHooks([
    ...hooks.map((hook) => hook.beforeStart),
    options.hooks?.beforeStart
  ]);
  for (const handler of beforeStartHandlers) {
    await handler();
  }
  const pageContext = {
    url: new URL(window.location.href),
    locals: {}
  };
  const extendPageContextHandlers = sortHooks([
    ...hooks.map((hook) => hook.extendPageContext),
    options.hooks?.extendPageContext,
    ...commonHooks.map((hook) => hook.extendPageContext)
  ]);
  for (const handler of extendPageContextHandlers) {
    await handler(pageContext);
  }
  const wrapAppHandlers = sortHooks([
    ...hooks.map((hook) => hook.wrapApp),
    options.hooks?.wrapApp,
    ...commonHooks.map((hook) => hook.wrapApp)
  ]).reverse();
  let app = /* @__PURE__ */ React5.createElement(App, null);
  for (const handler of wrapAppHandlers) {
    app = handler(app);
  }
  app = /* @__PURE__ */ React5.createElement(IsomorphicContext.Provider, { value: pageContext }, app);
  history.replaceState(
    {
      ...history.state,
      actionData: rakkas.actionData
    },
    ""
  );
  const route = await loadRoute(
    pageContext,
    new URL(window.location.href),
    void 0,
    true,
    rakkas.actionData
  ).catch((error) => {
    return { error };
  });
  app = /* @__PURE__ */ React5.createElement(RouteContext.Provider, { value: "error" in route ? route : { last: route } }, /* @__PURE__ */ React5.createElement(ErrorBoundary, { FallbackComponent: ErrorComponent }, app));
  if (import.meta.env.DEV && process.env.RAKKAS_STRICT_MODE === "true") {
    app = /* @__PURE__ */ React5.createElement(StrictMode, null, app);
  }
  const container = document.getElementById("root");
  const onNavigateHooks = sortHooks([
    ...hooks.map((hook) => hook.onNavigation),
    options.hooks?.onNavigation
  ]);
  rakkas.emitNavigationEvent = (url) => {
    for (const hook of onNavigateHooks) {
      hook(url);
    }
  };
  if (rakkas.clientRender) {
    createRoot(container).render(app);
  } else {
    startTransition(() => {
      hydrateRoot(container, app);
    });
  }
}
export {
  startClient
};

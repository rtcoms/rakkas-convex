// src/internal/route-utils.ts
function routeToRegExp(route) {
  route = route.replace(/\\|--/g, "/");
  let restParamName;
  const restMatch = route.match(/\/\[\.\.\.([a-zA-Z_][a-zA-Z0-9_]*)\]$/);
  if (restMatch) {
    const [rest, restName] = restMatch;
    route = route.slice(0, -rest.length);
    restParamName = restName;
  }
  return [
    new RegExp(
      "^" + route.split("/").map(
        (segment) => (
          /* Split subsegments. E.g. hello-[name]-[surname] => hello-, [name], -, [surname]*/
          segment.split(/(?=\[)|(?<=\])/g).map((sub) => {
            if (sub.startsWith("[")) {
              return sub;
            }
            return normalizePathSegment(sub);
          }).join("")
        )
      ).join("/").replace(
        // Escape special characters
        /[\\^$*+?.()|[\]{}]/g,
        (x) => `\\${x}`
      ).replace(
        /\\\[[a-zA-Z_][a-zA-Z0-9_]*\\]/g,
        (name) => `(?<${name.slice(2, -2)}>[^/]*)`
      ) + (restParamName ? `(?<${restParamName}>(\\/.*)?$)` : "\\/?$")
    ),
    restParamName
  ];
}
function sortRoutes(routes) {
  const processedRoutes1 = routes.map((route) => ({
    original: route,
    dynamicCount: route[0].match(/\[/g)?.length || 0,
    isRest: !!route[0].match(/\/\[\.\.\.([a-zA-Z_][a-zA-Z0-9_]*)\]$/),
    segments: route[0].split("/").map((seg) => ({
      content: seg,
      paramCount: seg.split("[").length - 1
    }))
  }));
  const processedRoutes = processedRoutes1.sort((a, b) => {
    const restDiff = Number(a.isRest) - Number(b.isRest);
    if (restDiff !== 0) {
      return restDiff;
    }
    const dynamicOrder = a.dynamicCount - b.dynamicCount;
    if (dynamicOrder) return dynamicOrder;
    const aSegments = a.segments;
    const bSegments = b.segments;
    for (let i = 0; i < aSegments.length; i++) {
      const aSegment = aSegments[i];
      const bSegment = bSegments[i];
      const result = compareSegments(aSegment, bSegment);
      if (result !== 0) return result;
    }
    return 0;
  });
  return processedRoutes.map((route) => route.original);
}
function compareSegments(a, b) {
  const definedOrder = Number(a === void 0) - Number(b === void 0);
  if (definedOrder) return definedOrder;
  return a.paramCount - b.paramCount || // Alphabetical order
  a.content.localeCompare(b.content);
}
var PATH_CHARS = /[A-Za-z0-9-._~!$&'()*+,;=:@[\]]/;
function normalizePathSegment(segment) {
  const result = segment.normalize("NFC").replace(
    /%(?:[0-9a-fA-F]{2})|[^A-Za-z0-9-._~!$&'()*+,;=:@[\]]/gu,
    (match) => {
      if (match.length < 3) {
        return encodeURIComponent(match);
      } else if (match[1] <= "7") {
        const decoded = decodeURIComponent(match);
        if (decoded.match(PATH_CHARS)) {
          return decoded;
        }
      }
      return match.toUpperCase();
    }
  );
  if (result === ".") {
    return "%2E";
  } else if (result === "..") {
    return "%2E%2E";
  }
  return result;
}

export {
  routeToRegExp,
  sortRoutes,
  normalizePathSegment
};

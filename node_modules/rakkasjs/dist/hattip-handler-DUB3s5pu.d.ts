import { RequestContext, RequestHandler } from '@hattip/compose';
import React, { ComponentType, ReactNode, ReactElement, AnchorHTMLAttributes, CSSProperties, FormEvent } from 'react';
import { ResolvedConfig } from 'vite';
import { HattipHandler } from '@hattip/core';

/** Navigation options */
interface NavigationOptions {
    /** Replace the current history entry */
    replace?: boolean;
    /** Restore scroll position (or scroll to top) */
    scroll?: boolean;
    /** Custom user data to be stored in the history entry */
    data?: any;
    /** Action data */
    actionData?: any;
}
/**
 * Navigate, using client-side navigation if possible.
 * @param to URL to navigate to
 * @param options Navigation options
 * @returns Whether the navigation was completed or cancelled
 */
declare function navigate(to: string | Readonly<URL>, options?: NavigationOptions): Promise<boolean>;
/** Return value of useLocation */
interface UseLocationResult {
    /** The URL of the current page before any rewrites */
    current: URL;
    /** The URL of the current page after rewrites */
    rendered: URL;
    /** The URL of the page that is being navigated to, if any */
    pending?: URL;
}
declare function useLocation(): UseLocationResult;
/** Cancel the last navigation. Returns a function to redo the navigation. */
declare function cancelLastNavigation(): number;

interface HeadProps {
    viewport?: string;
    title?: string;
    description?: string;
    canonical?: string;
    "og:title"?: string;
    "og:description"?: string;
    "og:image"?: string;
    "og:url"?: string;
    "og:type"?: string;
    "twitter:card"?: string;
    "twitter:title"?: string;
    "twitter:description"?: string;
    "twitter:image"?: string;
    htmlAttributes?: CommonAttributes;
    headAttributes?: CommonAttributes;
    bodyAttributes?: CommonAttributes;
    elements?: HeadElement[];
}
type HeadElement = HtmlAttributes | HeadAttributes | BodyAttributes | TitleElement | MetaElement | BaseElement | LinkElement | StyleElement | ScriptElement | NoScriptElement | TemplateElement | RemoveElement;
interface RemoveElement {
    tagName: "remove";
    key: string;
    remove: true;
}
interface HtmlAttributes extends CommonAttributes {
    tagName: "html";
}
interface HeadAttributes extends CommonAttributes {
    tagName: "head";
}
interface BodyAttributes extends CommonAttributes {
    tagName: "body";
}
interface TitleElement extends CommonAttributes {
    tagName: "title";
    textContent: string;
}
type MetaElement = MetaCharsetTag | MetaHttpEquivTag | MetaNameTag | MetaPropertyTag | MetaOgTag;
interface MetaCharsetTag extends CommonAttributes {
    tagName?: "meta";
    charset: string;
    itemprop?: never;
}
interface MetaHttpEquivTag extends CommonAttributes {
    tagName?: "meta";
    "http-equiv": string;
    content: string;
    itemprop?: never;
}
interface MetaNameTag extends CommonAttributes {
    tagName?: "meta";
    name: string;
    content: string;
    itemprop?: never;
}
interface MetaOgTag extends CommonAttributes {
    tagName?: "meta";
    property: string;
    content: string;
    itemprop?: never;
}
interface MetaPropertyTag extends CommonAttributes {
    tagName?: "meta";
    itemprop: string;
    content: string;
}
interface BaseElement extends CommonAttributes {
    tagName: "base";
    href: string;
    target?: "_blank" | "_self" | "_parent" | "_top" | (string & {}) | false;
}
type LinkElement = PreloadLinkTag | StyleLinkTag | OtherLinkTag;
type PreloadLinkTag = ImagePreloadLinkTag | OtherPreloadLinkTag;
interface ImagePreloadLinkTag extends CommonLinkAttributes {
    tagName: "link";
    rel: "preload";
    as: "image";
    imagesizes?: string | false;
    imagesrcset?: string | false;
}
interface OtherPreloadLinkTag extends CommonLinkAttributes {
    tagName: "link";
    rel: "preload";
    as: "audio" | "document" | "embed" | "fetch" | "font" | "object" | "script" | "style" | "track" | "video" | "worker" | (string & {});
}
interface StyleLinkTag extends CommonLinkAttributes {
    tagName: "link";
    rel: "stylesheet";
    disabled?: boolean;
}
interface OtherLinkTag extends CommonLinkAttributes {
    tagName: "link";
    rel: "alternate" | "archives" | "author" | "canonical" | "dns-prefetch" | "first" | "help" | "icon" | "index" | "last" | "license" | "manifest" | "modulepreload" | "next" | "pingback" | "preconnect" | "prefetch" | "preload" | "prev" | "search" | "shortlink" | "apple-touch-icon" | (string & {});
}
interface CommonLinkAttributes extends CommonAttributes {
    blocking?: boolean;
    crossorigin?: "anonymous" | "use-credentials" | boolean;
    fetchpriority?: "auto" | "high" | "low" | false;
    href: string;
    hreflang?: string | false;
    integrity?: string | false;
    media?: string | false;
    referrerpolicy?: "no-referrer" | "no-referrer-when-downgrade" | "origin" | "origin-when-cross-origin" | "same-origin" | "strict-origin" | "strict-origin-when-cross-origin" | "unsafe-url" | false;
    sizes?: string | false;
    type?: string | false;
    color?: string | false;
}
interface StyleElement extends CommonAttributes {
    tagName: "style";
    textContent: string;
    blocking?: boolean;
    media?: string | false;
    nonce?: string | false;
    title?: string | false;
}
interface ScriptElement extends CommonAttributes {
    tagName: "script";
    async?: boolean;
    blocking?: boolean;
    crossorigin?: "anonymous" | "use-credentials" | boolean;
    defer?: boolean;
    fetchpriority?: "auto" | "high" | "low" | false;
    integrity?: string | false;
    nomodule?: boolean;
    referrerpolicy?: "no-referrer" | "no-referrer-when-downgrade" | "origin" | "origin-when-cross-origin" | "same-origin" | "strict-origin" | "strict-origin-when-cross-origin" | "unsafe-url" | false;
    src?: string | false;
    type?: "importmap" | "module" | "text/javascript" | (string & {}) | false;
    textContent?: string;
}
interface NoScriptElement extends CommonAttributes {
    tagName: "noscript";
    children: Array<HtmlAttributes | HeadAttributes | BodyAttributes | MetaHttpEquivTag | MetaNameTag | BaseElement | LinkElement | StyleElement | ScriptElement>;
}
interface TemplateElement extends CommonAttributes {
    tagName: "template";
    innerHTML: string;
    shadowroot?: "open" | "closed" | false;
}
interface CommonAttributes {
    accesskey?: string | false;
    autocapitalize?: "off" | "none" | "on" | "sentences" | "words" | "characters" | (string & {}) | false;
    autofocus?: boolean;
    class?: string | false;
    contenteditable?: boolean;
    [key: `data-${string}`]: string | boolean;
    dir?: "ltr" | "rtl" | "auto" | (string & {}) | false;
    draggable?: boolean;
    enterkeyhint?: "enter" | "done" | "go" | "next" | "previous" | "search" | "send" | (string & {}) | false;
    exportparts?: string | false;
    hidden?: boolean;
    id?: string | false;
    inert?: boolean;
    inputmode?: "decimal" | "email" | "none" | "numeric" | "search" | "tel" | "text" | "url" | (string & {}) | false;
    is?: string | false;
    itemid?: string | false;
    itemprop?: string | false;
    itemref?: string | false;
    itemscope?: boolean;
    itemtype?: string | false;
    lang?: string | false;
    nonce?: string | false;
    part?: string | false;
    popover?: string | false;
    slot?: string | false;
    spellcheck?: boolean;
    style?: string | false;
    tabindex?: number;
    title?: string | false;
    translate?: "yes" | "no" | (string & {}) | false;
    virtualkeyboardpolicy?: "auto" | "manual" | (string & {}) | false;
    "xml:lang"?: string | false;
    "xmlns:base"?: string | false;
}

/** An object for storing stuff local to your app */
interface PageLocals {
}
/** A browser global for holding Rakkas specific stuff */
interface RakkasBrowserGlobal {
    cache?: Record<string, any>;
    actionErrorIndex?: number;
    actionData?: any;
    clientRender?: boolean;
    update?: () => void;
    navigate?: typeof navigate;
    headTagStack: (HeadProps & {
        order: number;
    })[];
    headOrder: number;
    setNextId?: (id: string) => void;
    emitNavigationEvent?: (url: URL) => void;
}
declare global {
    /** A browser global for holding Rakkas specific stuff */
    const rakkas: RakkasBrowserGlobal;
}

/** A page component default exported from a page module */
type Page<P = Record<string, string>, M = Record<string, unknown>> = ComponentType<PageProps<P, M>> & {
    /** Function to be called before rendering the page */
    preload?: PreloadFunction<P, M>;
};
/** A layout component default exported from a layout module. */
type Layout<P = Record<string, string>, M = Record<string, unknown>> = ComponentType<LayoutProps<P, M>> & {
    /** Function to be called before rendering the layout */
    preload?: PreloadFunction<P, M>;
};
/** Props passed to a page component */
interface PageProps<P = Record<string, string>, M = Record<string, unknown>> {
    /** Current URL before rewrites */
    url: URL;
    /** Rendered URL after rewrites */
    renderedUrl: URL;
    /** Route parameters */
    params: P;
    /** Action data */
    actionData?: any;
    /** Page meta data coming from the preload functions */
    meta: M;
}
/** Props passed to a layout component */
interface LayoutProps<P = Record<string, string>, M = Record<string, unknown>> extends PageProps<P, M> {
    children: ReactNode;
}
/** Function to be called before each time loading a page or layout.
 *
 * Usage:
 * ```
 * 	MyPageOrLayoutComponent.preload = (context: PreloadContext) => {
 * 		return {
 * 			meta: {
 * 				someKey: "Some metadata to be passed to the pages and layouts",
 * 			},
 * 			head: { title: "My Page Title", description: "My page description" },
 * 		};
 * 	};
 * ```
 * You can also handle redirections by returning a
 * {@link PreloadResult["redirect"] redirect} prop.
 */
type PreloadFunction<P = Record<string, string>, M = Record<string, unknown>> = (context: PreloadContext<P>) => PreloadResult<M> | void | Promise<PreloadResult<M> | void>;
/** Arguments passed to the action function */
interface ActionContext<P = Record<string, string>> extends PageContext {
    /** Route parameters */
    params: P;
    /** Request context */
    requestContext: RequestContext;
}
/** Arguments passed to the preload function */
interface PreloadContext<P = Record<string, string>> extends PageContext {
    /** The URL before rewrites */
    url: URL;
    /** The URL after rewrites */
    renderedUrl: URL;
    /** Route parameters */
    params: P;
    /** Action data */
    actionData?: any;
}
/**
 * Arguments passed to server-side page functions like `headers`,
 * `prerender`, and `action`
 */
type ServerSidePageContext<P = Record<string, string>> = PreloadContext<P> & {
    requestContext: RequestContext;
};
/** Return type of a preload function */
interface PreloadResult<M = Record<string, unknown>> {
    /** Metadata passed to page and layout components. */
    meta?: Partial<M> | ((prevMeta: M) => M);
    /** Head tags rendered for the page. Use the <Head /> component. */
    head?: HeadProps;
    /** Redirection */
    redirect?: RedirectProps;
}
interface PageRouteGuardContext<P = Record<string, string>> extends PageContext {
    /** The URL before rewrites */
    url: URL;
    /** The URL after rewrites */
    renderedUrl: URL;
    /** Dynamic path parameters */
    params: P;
}
/** Page guard */
type PageRouteGuard<P = Record<string, string>> = (ctx: PageRouteGuardContext<P>) => LookupHookResult | Promise<LookupHookResult>;
type ActionHandler<T> = (pageContext: ActionContext) => ActionResult<T> | Promise<ActionResult<T>>;
/** Function to set response headers */
type HeadersFunction<M = Record<string, unknown>> = (context: ServerSidePageContext, meta: M) => ResponseHeadersProps | Promise<ResponseHeadersProps>;
/** Function to control static prerendering behavior */
type PrerenderFunction<M = Record<string, unknown>> = (context: ServerSidePageContext, meta: M) => PrerenderResult | Promise<PrerenderResult>;
/** Return type of the prerender function */
interface PrerenderResult {
    /** Should this page be prerendered? Defaults to true */
    shouldPrerender?: boolean;
    /** Should the prerenderer crawl this page? Defaults to the value of prerender */
    shouldCrawl?: boolean;
    /** More links to prerender */
    links?: (URL | string)[];
}
interface LookupHookContext extends PageContext {
    /** The URL before rewrites */
    url: URL;
    /** The URL after rewrites */
    renderedUrl: URL;
}
/**
 * Return type of the beforeXxxLookup hooks.
 *
 * - `true` continues with the lookup
 * - `false` skips the lookup
 * - `{ redirect: string | URL }` redirects to the given URL
 * - `{ rewrite: string | URL }` rewrites the URL to the given URL
 */
type LookupHookResult = boolean | Redirection | {
    /** Render this URL instead of the requested one */
    rewrite: string | URL;
};
/** Redirection */
interface Redirection {
    /** Location to redirect to */
    redirect: string | URL;
    /** Whether the redirect is permanent @default false */
    permanent?: boolean;
    /** The status code to use (hes precedence over `permanent`) */
    status?: number;
    /** Set response headers */
    headers?: Record<string, string | string[]> | ((headers: Headers) => void);
}
type ActionResult<T> = {
    /** The data */
    data: T;
    /** Redirect to another URL */
    redirect?: string | URL;
    /** The status code */
    status?: number;
    /** Response headers */
    headers?: Record<string, string | string[]> | ((headers: Headers) => void);
};
type RouteConfigExport = RouteConfig | ((config: ResolvedConfig) => RouteConfig | Promise<RouteConfig>);
interface RouteConfig extends BaseRouteConfig {
    defaults?: BaseRouteConfig;
}
interface BaseRouteConfig {
    disabled?: boolean;
    renderingMode?: "hydrate" | "server" | "client";
}
/** Context within which the page is being rendered */
interface PageContext {
    /** Isomorphic fetch function */
    fetch: typeof fetch;
    /** Query client used by useQuery */
    queryClient: QueryClient;
    /** Request context, only defined on the server */
    requestContext?: RequestContext;
    /** Application-specific stuff */
    locals: PageLocals;
    /** Page action data */
    actionData?: any;
}

type HookDefinition<F extends Function> = F | {
    order?: "pre" | "post";
    handler: F;
};

/** Page hooks common to the server and client */
interface CommonHooks {
    /** Called before the page is rendered. It can be used to add custom
     * properties to the page context. This is always called *after* the
     * server-side or client-side `extendPageContext` hooks.
     */
    extendPageContext?: HookDefinition<(ctx: PageContext) => void>;
    /**
     * Called before attempting to match the URL to a page. It's used for
     * rewriting or redirecting the URL.
     */
    beforePageLookup?: HookDefinition<(ctx: LookupHookContext) => LookupHookResult | Promise<LookupHookResult>>;
    /**
     * This hook is intended for wrapping the React app with provider
     * components. This is always called *after* the server-side or client-side
     * `wrapApp` hooks.
     */
    wrapApp?: HookDefinition<(app: ReactElement) => ReactElement>;
}
interface CommonPluginOptions {
}
type CommonPluginFactory = (options: CommonPluginOptions, configOptions: any) => CommonHooks;

/** useQuery options */
interface UseQueryOptions<T = unknown, Enabled extends boolean = true, InitialData extends T | undefined = undefined, PlaceholderData = undefined> {
    /**
     * Time in milliseconds after which the value will be evicted from the
     * cache when there are no subscribers. Use 0 for immediate eviction and
     * `Infinity` to disable.
     *
     * @default 300_000 (5 minutes)
     */
    cacheTime?: number;
    /**
     * Time in milliseconds after which a cached value will be considered
     * stale.
     *
     * @default 100
     */
    staleTime?: number;
    /**
     * Refetch the query when the component is mounted. If set to `true`, a stale
     * query will be refetched when the component is mounted. If set to `"always"`,
     * the query will be refetched when the component is mounted regardless of
     * staleness. `false` disables this behavior.
     *
     * @default true
     */
    refetchOnMount?: boolean | "always";
    /**
     * Refetch the query when the window gains focus. If set to `true`, the
     * query will be refetched on window focus if it is stale. If set to
     * `"always"`, the query will be refetched on window focus regardless of
     * staleness. `false` disables this behavior.
     *
     * @default false
     */
    refetchOnWindowFocus?: boolean | "always";
    /**
     * Continuously refetch every `refetchInterval` milliseconds. Set to false
     * to disable.
     *
     * @default false
     */
    refetchInterval?: number | false;
    /**
     * Perform continuous refetching even when the window is in the background.
     *
     * @default false
     */
    refetchIntervalInBackground?: boolean;
    /**
     * Refetch the query when the internet connection is restored. If set to
     * `true`, a stale query will be refetched when the internet connection is
     * restored. If set to `"always"`, the query will be refetched when the
     * internet connection is restored regardless of staleness. `false` disables
     * this behavior.
     *
     * @default false
     */
    refetchOnReconnect?: boolean | "always";
    /**
     * Set this to `false` to disable automatic refetching when the query mounts or changes query keys.
     * To refetch the query, use the `refetch` method returned from the `useQuery` instance.
     * Defaults to `true`.
     */
    enabled?: Enabled;
    /**
     * If set, this value will be used as the initial data for this query.
     */
    initialData?: InitialData;
    /**
     * If set, this value will be used as the placeholder data for this particular query observer while the query is still fetching and no initialData has been provided.
     */
    placeholderData?: PlaceholderData;
    /**
     * If set, any previous data will be kept when fetching new data because the query key changed.
     */
    keepPreviousData?: boolean;
    /**
     * Query tags that can be used to invalidate queries after a mutation.
     */
    tags?: string[] | Set<string>;
}
interface CompleteUseQueryOptions<T = unknown, Enabled extends boolean = true, InitialData extends T | undefined = undefined, PlaceholderData = undefined> extends UseQueryOptions<T, Enabled, InitialData, PlaceholderData> {
    queryKey: string;
    queryFn: QueryFn<T>;
}
declare function usePageContext(): PageContext;
/** Function passed to useQuery */
type QueryFn<T> = (ctx: PageContext) => T | Promise<T>;
declare const QUERY_BRAND: unique symbol;
type BrandedQueryKey<T> = string & {
    [QUERY_BRAND]: T;
};
/** Utility function to create typed queries and query factories */
declare function queryOptions<T, Enabled extends boolean = true, InitialData extends T | undefined = undefined, PlaceholderData = undefined>(options: CompleteUseQueryOptions<T, Enabled, InitialData, PlaceholderData>): CompleteUseQueryOptions<T, Enabled, InitialData, PlaceholderData> & {
    queryKey: string & BrandedQueryKey<T>;
};
/**
 * Fetches data
 */
declare function useQuery<T, Enabled extends boolean = true, InitialData extends T | undefined = undefined, PlaceholderData = undefined>(options: CompleteUseQueryOptions<T, Enabled, InitialData, PlaceholderData>): QueryResult<T, Enabled, InitialData, PlaceholderData>;
declare function useQuery<T, Enabled extends boolean = true, InitialData extends T | undefined = undefined, PlaceholderData = undefined>(key: string, fn: QueryFn<T>, options?: UseQueryOptions<T, Enabled, InitialData, PlaceholderData>): QueryResult<T, Enabled, InitialData, PlaceholderData>;
/** Return value of useQuery */
interface QueryResult<T, Enabled extends boolean = true, InitialData = undefined, PlaceholderData = undefined> {
    /** Fetched data */
    data: InitialData extends undefined ? Enabled extends true ? PlaceholderData extends undefined ? T : PlaceholderData | T : PlaceholderData | T : T;
    /** Refetch the data */
    refetch(): void;
    /** Is the data being refetched? */
    isRefetching: boolean;
    /** Update date of the last returned data */
    dataUpdatedAt?: number;
    /** Error thrown by the query when a refetch fails */
    error?: any;
}
interface EventSourceResult<T> {
    /** Last data */
    data?: T;
    /** Update date of the last returned data */
    dataUpdatedAt?: number;
}
/** Query client that manages the cache used by useQuery */
interface QueryClient {
    /** Get the data cached for the given key */
    getQueryData<Q extends string>(key: Q): Q extends BrandedQueryKey<infer T> ? T | undefined : any;
    /**
     * Set the data associated for the given key.
     * You can also pass a promise here.
     */
    setQueryData<Q extends string>(key: Q, data: Q extends BrandedQueryKey<infer T> ? T | Promise<T> : any): void;
    /**
     * Start fetching the data for the given key.
     */
    prefetchQuery<T>(options: PrefetchQueryOptions<T>): void;
    /** */
    ensureQueryData<T>(options: PrefetchQueryOptions<T>): Promise<Awaited<T>>;
    /**
     * Invalidate one or more queries.
     */
    invalidateQueries(keys?: string | string[] | Set<string> | ((key: string) => boolean)): void;
    /**
     * Invalidate queries by tag.
     */
    invalidateTags(tags: string[] | Set<string>): void;
}
interface PrefetchQueryOptions<T = any> {
    /** Query key */
    queryKey: string & BrandedQueryKey<Awaited<T>>;
    /** Query function */
    queryFn: QueryFn<T>;
    /**
     * Time in milliseconds after which the value will be evicted from the
     * cache when there are no subscribers. Use 0 for immediate eviction and
     * `Infinity` to disable.
     *
     * @default 300_000 (5 minutes)
     */
    cacheTime?: number;
    /**
     * Time in milliseconds after which a cached value will be considered
     * stale.
     *
     * @default 100
     */
    staleTime?: number;
    /**
     * Query tags that can be used to invalidate queries after a mutation.
     */
    tags?: string[] | Set<string>;
}
/** Access the query client that manages the cache used by useQuery */
declare function useQueryClient(): QueryClient;

/** Function passed to useMutation */
type MutationFunction<T, V> = (vars: V) => T | Promise<T>;
/** Options for useMutation */
interface UseMutationOptions<T, V> {
    /** Called just before the mutation starts */
    onMutate?(vars: V): void | Promise<void>;
    /** Called when the mutation fails */
    onError?(error: unknown): void;
    /** Called when the mutation ends (either error or success) */
    onSettled?(data?: T, error?: unknown): void;
    /** Called when the mutation completes successfully */
    onSuccess?(data: T): void;
    /** Query keys to invalidate when the mutation settles */
    invalidateKeys?: string[];
    /** Query tags to invalidate when the mutation settles */
    invalidateTags?: string[];
}
/** Initial mutation state */
interface UseMutationIdleResult {
    /** Mutation status */
    status: "idle";
    /** Data returned from the mutation */
    data?: undefined;
    /** Error thrown by the mutation */
    error?: undefined;
    /** Was there an error? */
    isError: false;
    /** Is the mutation in its initial state? */
    isIdle: true;
    /** Is the mutation currently underway? */
    isLoading: false;
    /** Did the last mutation complete successfully? */
    isSuccess: false;
}
/** Loading mutation state */
interface UseMutationLoadingResult {
    /** Mutation status */
    status: "loading";
    /** Data returned from the mutation */
    data?: undefined;
    /** Error thrown by from the mutation */
    error?: undefined;
    /** Was there an error? */
    isError: false;
    /** Is the mutation in its initial state? */
    isIdle: false;
    /** Is the mutation currently underway? */
    isLoading: true;
    /** Did the last mutation complete successfully? */
    isSuccess: false;
}
/** Failed mutation state */
interface UseMutationErrorResult {
    /** Mutation status */
    status: "error";
    /** Data returned from the mutation */
    data?: undefined;
    /** Error thrown by from the mutation */
    error: unknown;
    /** Was there an error? */
    isError: true;
    /** Is the mutation in its initial state? */
    isIdle: false;
    /** Is the mutation currently underway? */
    isLoading: false;
    /** Did the last mutation complete successfully? */
    isSuccess: false;
}
/** Successful mutation state */
interface UseMutationSuccessResult<T> {
    /** Mutation status */
    status: "success";
    /** Data returned from the mutation */
    data: T;
    /** Error thrown by from the mutation */
    error?: undefined;
    /** Was there an error? */
    isError: false;
    /** Is the mutation in its initial state? */
    isIdle: false;
    /** Is the mutation currently underway? */
    isLoading: false;
    /** Did the last mutation complete successfully? */
    isSuccess: true;
}
interface UseMutationMethods<T, V> {
    /** Fire the mutation */
    mutate(vars: V): void;
    /** Fire the mutation and await its result */
    mutateAsync(vars: V): Promise<T>;
    /** Reset the mutation to its initial state */
    reset(): void;
}
/** Return value of useMutation */
type UseMutationResult<T, V> = UseMutationMethods<T, V> & (UseMutationIdleResult | UseMutationLoadingResult | UseMutationErrorResult | UseMutationSuccessResult<T>);
/**
 * Performs a mutation
 * @template T Type of mutation result data
 * @template V Type of mutation variables
 * @param mutationFn Function that performs the mutation
 * @param [options] Mutation options
 * @returns mutation Mutation result
 */
declare function useMutation<T, V = void>(mutationFn: MutationFunction<T, V>, options?: UseMutationOptions<T, V>): UseMutationResult<T, V>;
/** Optinos for useMutation */
interface UseMutationsOptions<T, V> {
    /** Called just before the mutation starts */
    onMutate?(id: number, vars: V): void | Promise<void>;
    /** Called when the mutation fails */
    onError?(id: number, error: unknown): void;
    /** Called when the mutation ends (either error or success) */
    onSettled?(id: number, data?: T, error?: unknown): void;
    /** Called when the mutation completes successfully */
    onSuccess?(id: number, data: T): void;
    /** Query tags to invalidate when the mutation settles */
    invalidateTags?: string[] | Set<string> | ((id: number, data?: T, error?: unknown) => string[] | Set<string>);
}
/** Return value of useMutations */
interface UseMutationsResult<T, V> {
    /** Fire the mutation */
    mutate(vars: V): void;
    /** Fire the mutation and await its result */
    mutateAsync(vars: V): Promise<T>;
    /** Mutations that are currently underway */
    pending: {
        id: number;
        vars: V;
    }[];
}
/**
 * Performs a mutation that can be fired multiple times at once. Each triggered
 * mutation will have a unique ID that can be used to track it in the `pending`
 * array in the return value. You can use `onSuccess`, `onError`, and
 * `onSettled` to track the status of each mutation to provide loading states
 * or optimistic updates.
 *
 * @template T Type of mutation result data
 * @template V Type of mutation variables
 * @param mutationFn Function that performs the mutation
 * @param [options] Mutation options
 * @returns Mutation result
 */
declare function useMutations<T, V = void>(mutationFn: MutationFunction<T, V>, options?: UseMutationsOptions<T, V>): UseMutationsResult<T, V>;

/** {@link Link} props */
interface LinkProps extends AnchorHTMLAttributes<HTMLAnchorElement> {
    /** Data to be passed to the history entry */
    historyState?: any;
    /** Whether to replace the current history entry */
    replaceState?: boolean;
    /** Whether to disable scroll position restoration (or scroll to top) */
    noScroll?: boolean;
    /** Called when navigation starts */
    onNavigationStart?: () => void;
    /** Called when navigation ends or is cancelled */
    onNavigationEnd?: (completed: boolean) => void;
    /**
     * Whether and when to load the code for the new page. Options are:
     *
     * - `"eager"`: Load as soon as the link is rendered
     * - `"viewport"`: Load when the link enters the viewport
     * - `"idle"`: Load when the browser is idle (falls back to hover if `requestIdleCallback` is not available)
     * - `"hover"`: Load when the user hovers over the link
     * - `"tap"`: Load when the user taps or starts clicking on the link
     * - `"never"`: Only load when the link is clicked
     *
     * @default "hover"
     */
    prefetch?: "eager" | "viewport" | "idle" | "hover" | "tap" | "never";
    /**
     * Whether and when to preload the data for the new page. Note that you can't
     * preload without prefetching, so a more eager preload setting will also
     * prefetch the code. `true` means preload when the link is prefetched.
     */
    preload?: "eager" | "viewport" | "idle" | "hover" | "tap" | "never" | true;
}
/** Link component for client-side navigation */
declare const Link: React.ForwardRefExoticComponent<LinkProps & React.RefAttributes<HTMLAnchorElement>>;
/** {@link StyledLink} props */
interface StyledLinkProps extends LinkProps {
    /** Class to be added if `href` matches the current URL */
    activeClass?: string;
    /** Style to be added if `href` matches the current URL */
    activeStyle?: CSSProperties;
    /** Class to be added if navigation is underway because the user clicked on this link */
    pendingClass?: string;
    /** Style to be added if navigation is underway because the user clicked on this link */
    pendingStyle?: CSSProperties;
    /**
     * Custom comparison function for checking if the current URL matches this link
     * @param url  URL to be compared to `href`
     * @param href Value of `href` property, passed for convenience
     *
     * @returns true if the URL matches `href`
     */
    onCompareUrls?(url: URL, href: URL): boolean;
}
/**
 * Like {@link Link} but allows adding classes and/or styles based on whether this is the active URL.
 */
declare const StyledLink: React.ForwardRefExoticComponent<StyledLinkProps & React.RefAttributes<HTMLAnchorElement>>;
type UseSubmitResult<T = any> = {
    submitHandler(event: FormEvent<HTMLFormElement>): void;
} & (UseMutationIdleResult | UseMutationLoadingResult | UseMutationErrorResult | UseMutationSuccessResult<T>);
type UseSubmitOptions<T> = UseMutationOptions<T, {
    form: HTMLFormElement;
    formData: FormData;
}> & Omit<NavigationOptions, "actionData">;
declare function useSubmit<T>(options?: UseSubmitOptions<T>): UseSubmitResult<T>;
/**
 * Preload a page's code and possibly data.
 *
 * @param location URL of the page to preload
 * @param preload Whether to also preload the data
 */
declare function prefetchRoute(location?: URL | string, preload?: boolean): void;
declare global {
    interface PromiseConstructor {
        withResolvers<T>(): {
            promise: Promise<T>;
            resolve: (value: T) => void;
            reject: (reason: any) => void;
        };
    }
}

/** {@link Redirect} props */
interface RedirectProps {
    /** The URL to redirect to */
    href: string;
    /** Whether the redirect is permanent @default false */
    permanent?: boolean;
    /** The status code to use (hes precedence over `permanent`) */
    status?: number;
}
/**
 * Component for redirecting the user to a different URL.
 *
 * Note that if this component is deep inside a suspense boundary, it won't
 * be able to return a redirect response after the response stream has started
 * and it will attempt to redirect from the client using JavaScript. If
 * JavaScript is disabled, the redirect won't work in this case. For this
 * reason, either use this component at the top level of your page or layout,
 * or use the {@link PreloadFunction} to redirect before the response stream
 * starts.
 */
declare const Redirect: (props: RedirectProps) => ReactElement;
/** {@link ResponseHeaders} props */
interface ResponseHeadersProps {
    /** Status code */
    status?: number | ((currentStatus: number) => number);
    /** The headers to set */
    headers?: Record<string, string | string[]> | ((headers: Headers) => void);
    /**
     * Time to hold the render stream before returning the response. Set to
     * true to hold until the page is fully rendered, effectively disabling
     * streaming.
     */
    throttleRenderStream?: number | true;
}
/**
 * Component for setting response status, respnse headers, and throttling the
 * SSR stream.
 *
 * Note that if this component is deep inside a suspense boundary, it won't
 * be able to set the response headers after the response stream has started.
 * Rakkas disables streaming for bots, so this is usually not a problem for
 * SEO. But if you want to be absolutely sure that the headers are set, you
 * can export a {@link HeadersFunction headers()} function from your page
 * or layout to set the headers.
 */
declare const ResponseHeaders: (props: ResponseHeadersProps) => ReactElement;

declare module "@hattip/compose" {
    interface RequestContextExtensions {
        /** Dynamic path parameters */
        params: Record<string, string>;
        /** Isomorphic fetch function */
        fetch: typeof fetch;
        /**
         * Internal stuff, don't use it in user code.
         *
         * @internal
         */
        rakkas: {
            /** Server-side customiization hooks */
            hooks: ServerHooks[];
            /** Set to true when searching for a not found page */
            notFound: boolean;
            /** Head tags */
            head: HeadProps[];
        };
    }
}
/** Server-side customization hooks */
interface ServerHooks {
    /**
     * Hattip middleware handlers to insert at various stages of the request
     * processing chain
     */
    middleware?: {
        /** Middlewares to be run before everything */
        beforeAll?: Array<false | null | undefined | HookDefinition<RequestHandler>>;
        /** Middlewares to be run before matching pages */
        beforePages?: Array<false | null | undefined | HookDefinition<RequestHandler>>;
        /** Middlewares to be run before matching API routes */
        beforeApiRoutes?: Array<false | null | undefined | HookDefinition<RequestHandler>>;
        /** Middlewares to be run before not-found handling */
        beforeNotFound?: Array<false | null | undefined | HookDefinition<RequestHandler>>;
    };
    /** Create server-side page rendering hooks */
    createPageHooks?(ctx: RequestContext): PageRequestHooks;
}
interface ServerPluginOptions {
}
type ServerPluginFactory = (options: ServerPluginOptions, commonOptions: CommonPluginOptions, configOptions: any) => ServerHooks;
/** Hooks for customizing the page rendering on the server */
interface PageRequestHooks {
    /**
     * This is called before the page is rendered. It's used for adding custom
     * data to the page context.
     */
    extendPageContext?: HookDefinition<(ctx: PageContext) => void | Promise<void>>;
    /**
     * This hook is intended for wrapping the React app with provider
     * components on the server only.
     */
    wrapApp?: HookDefinition<(app: ReactElement) => ReactElement>;
    /**
     * Write to the document's head section.
     *
     * @deprecated Use `emitToSyncHeadScript`, `emitServerOnlyHeadElements` or
     * the normal Head component instead.
     */
    emitToDocumentHead?: HookDefinition<() => ReactElement | string | undefined>;
    /** Write to the document's head section */
    emitServerOnlyHeadElements?: HookDefinition<() => HeadElement[] | undefined>;
    /** Emit a piece of code to be inserted into a script tag in the head. */
    emitToSyncHeadScript?: HookDefinition<() => string | undefined>;
    /** Emit a chunk of HTML before each time React emits a chunk */
    emitBeforeSsrChunk?: HookDefinition<() => string | undefined>;
    /** Wrap React's SSR stream */
    wrapSsrStream?: HookDefinition<(stream: ReadableStream) => ReadableStream>;
}
/**
 * Creates a HatTip request handler. Call this to create a HatTip request
 * handler and default export it from your HatTip entry.
 */
declare function createRequestHandler<T>(userHooks?: ServerHooks, pluginOptions?: ServerPluginOptions): HattipHandler<T>;

export { Link as $, type ActionResult as A, type BaseRouteConfig as B, type CommonHooks as C, type QueryClient as D, type EventSourceResult as E, useQuery as F, useQueryClient as G, type HeadProps as H, usePageContext as I, queryOptions as J, type UseMutationMethods as K, type Layout as L, type MutationFunction as M, useMutation as N, type UseMutationsOptions as O, type PageLocals as P, type QueryResult as Q, type RakkasBrowserGlobal as R, type ServerSidePageContext as S, type UseMutationsResult as T, type UseQueryOptions as U, useMutations as V, type LinkProps as W, type StyledLinkProps as X, type UseSubmitOptions as Y, type UseLocationResult as Z, type NavigationOptions as _, type UseMutationOptions as a, StyledLink as a0, useSubmit as a1, prefetchRoute as a2, navigate as a3, useLocation as a4, cancelLastNavigation as a5, type ResponseHeadersProps as a6, type RedirectProps as a7, ResponseHeaders as a8, Redirect as a9, type HookDefinition as aa, type ServerHooks as ab, type ServerPluginOptions as ac, type ServerPluginFactory as ad, type PageRequestHooks as ae, createRequestHandler as af, type UseMutationIdleResult as b, type UseMutationLoadingResult as c, type UseMutationErrorResult as d, type UseMutationSuccessResult as e, type UseMutationResult as f, type Page as g, type PageProps as h, type LayoutProps as i, type PreloadContext as j, type PreloadResult as k, type PreloadFunction as l, type HeadersFunction as m, type PrerenderFunction as n, type PrerenderResult as o, type PageRouteGuard as p, type PageRouteGuardContext as q, type LookupHookResult as r, type ActionContext as s, type ActionHandler as t, type RouteConfigExport as u, type RouteConfig as v, type PageContext as w, type CommonPluginOptions as x, type CommonPluginFactory as y, type QueryFn as z };

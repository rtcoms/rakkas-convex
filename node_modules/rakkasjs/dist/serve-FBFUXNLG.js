import {
  cleanOptions,
  startTime
} from "./chunk-3VG2XVTH.js";
import {
  version
} from "./chunk-TTMWBCHJ.js";
import {
  routeToRegExp,
  sortRoutes
} from "./chunk-LXBE6FTZ.js";

// src/cli/serve.ts
import { performance } from "perf_hooks";
import {
  createServer,
  resolveConfig
} from "vite";
import pico2 from "picocolors";

// src/vite-plugin/inject-config.ts
import { spawn } from "child_process";
function injectConfig(options) {
  return {
    name: "rakkasjs:inject-config",
    enforce: "pre",
    async config(_, env) {
      if (!process.env.RAKKAS_BUILD_ID) {
        process.env.RAKKAS_BUILD_ID = env.command === "serve" ? "development" : await getBuildId();
      }
      if (options.adapter.disableStreaming) {
        process.env.RAKKAS_DISABLE_STREAMING = "true";
      } else {
        process.env.RAKKAS_DISABLE_STREAMING = "false";
      }
      const buildSteps = [
        {
          name: "client",
          config: {
            build: {
              outDir: "dist/client",
              rollupOptions: {
                input: {
                  index: "/rakkasjs:client-entry"
                }
              }
            }
          }
        },
        {
          name: "server",
          config: {
            build: {
              outDir: "dist/server",
              ssr: true,
              rollupOptions: {
                input: {
                  index: "/virtual:vavite-connect-server",
                  hattip: "rakkasjs:hattip-entry"
                }
              },
              target: "node18"
            }
          }
        }
      ];
      return {
        buildSteps,
        build: {
          assetsDir: "_app/assets"
        },
        ssr: {
          external: ["react-dom/server.browser"],
          noExternal: ["rakkasjs", "@vavite/expose-vite-dev-server"],
          optimizeDeps: {
            exclude: [
              "rakkasjs",
              "@vavite/expose-vite-dev-server",
              "rakkasjs:client-manifest",
              "rakkasjs:client-page-routes",
              "rakkasjs:api-routes",
              "rakkasjs:run-server-side:manifest",
              "rakkasjs:server-page-routes",
              "rakkasjs:error-page"
            ]
          }
        },
        appType: "custom",
        optimizeDeps: {
          include: ["react", "react-dom", "react-dom/client"],
          // TODO: Remove this when https://github.com/vitejs/vite/pull/8917 is merged
          exclude: [
            "rakkasjs",
            "rakkasjs:client-manifest",
            "rakkasjs:client-page-routes",
            "rakkasjs:api-routes",
            "rakkasjs:run-server-side:manifest",
            "rakkasjs:server-page-routes",
            "rakkasjs:error-page",
            "@vavite/expose-vite-dev-server"
          ]
        },
        envPrefix: ["VITE_", "RAKKAS_"],
        api: {
          rakkas: {
            prerender: options.prerender,
            adapter: options.adapter
          }
        },
        define: {
          "process.env.RAKKAS_STRICT_MODE": JSON.stringify(
            options.strictMode.toString()
          )
        }
      };
    }
  };
}
async function getBuildId() {
  return await new Promise((resolve, reject) => {
    const git = spawn("git", ["rev-parse", "HEAD"], {
      stdio: ["ignore", "pipe", "ignore"]
    });
    git.stdout.setEncoding("utf8");
    let output = "";
    git.stdout.on("data", (data) => {
      output += data;
    });
    git.on("error", (err) => reject(err));
    git.on("close", (code) => {
      if (code === 0) {
        resolve(output.trim().slice(0, 11));
      } else {
        reject(new Error());
      }
    });
  }).catch(() => {
    return Math.random().toString(36).substring(2, 15);
  });
}

// src/vite-plugin/prevent-vite-build.ts
function preventViteBuild() {
  let buildStepStartCalled = false;
  let prevent = false;
  return {
    name: "rakkasjs:prevent-vite-build",
    enforce: "pre",
    apply: "build",
    buildStepStart() {
      buildStepStartCalled = true;
    },
    configResolved(config) {
      if (config.buildSteps && config.mode !== "multibuild" && !buildStepStartCalled) {
        prevent = true;
      }
    },
    buildStart() {
      if (prevent) {
        throw new Error(
          "rakkas: Please use the 'rakkas' command instead of 'vite build' to build a Rakkas project."
        );
      }
    }
  };
}

// src/vite-plugin/index.ts
import { vaviteConnect } from "@vavite/connect";
import exposeViteDevServer from "@vavite/expose-vite-dev-server";

// src/vite-plugin/resolve-client-manifest.ts
import fs from "fs";
import path from "path";
function resolveClientManifest() {
  let resolvedConfig;
  let dev = false;
  return {
    name: "rakkasjs:resolve-client-manifest",
    enforce: "pre",
    resolveId(id, _, options) {
      if (id === "rakkasjs:client-manifest") {
        if (dev || !options.ssr) {
          return "\0virtual:" + id;
        } else {
          return this.resolve(
            path.resolve(resolvedConfig.root, "dist/manifest.json")
          );
        }
      }
    },
    load(id) {
      if (id === "\0virtual:rakkasjs:client-manifest") {
        return "export default undefined";
      }
    },
    config(config, env) {
      dev = env.command === "serve";
      if (!config.build?.ssr) {
        return {
          build: {
            manifest: "vite.manifest.json"
          }
        };
      }
    },
    configResolved(config) {
      resolvedConfig = config;
    },
    async closeBundle() {
      if (resolvedConfig.command === "serve" || resolvedConfig.build.ssr) {
        return;
      }
      const from = path.resolve(
        resolvedConfig.root,
        resolvedConfig.build.outDir,
        "vite.manifest.json"
      );
      await fs.promises.rename(from, resolvedConfig.root + "/dist/manifest.json").catch(() => {
      });
    }
  };
}

// src/vite-plugin/virtual-default-entry.ts
import path2 from "path";
function virtualDefaultEntry(options) {
  const { defaultContent, entry, virtualName, resolveName = true } = options;
  let fallback;
  return {
    name: "rakkasjs:default-entry",
    enforce: "pre",
    async configResolved(config) {
      if (resolveName) {
        fallback = path2.resolve(config.root, entry.slice(1) + ".default.js").replace(/\\/g, "/");
      } else {
        fallback = "\0virtual:rakkasjs:" + virtualName;
      }
    },
    async resolveId(id) {
      if (id === "rakkasjs:" + virtualName || id === "/rakkasjs:" + virtualName || id === entry + ".default.js") {
        const userEntry = await this.resolve(entry);
        return userEntry ?? fallback;
      }
    },
    async load(id) {
      if (id === fallback) {
        return defaultContent;
      }
    }
  };
}

// src/vite-plugin/index.ts
import { nodeLoaderPlugin } from "@vavite/node-loader/plugin";

// src/features/pages/vite-plugin.ts
import { transformAsync } from "@babel/core";

// src/features/run-server-side/implementation/transform/transform-client-page.ts
import "@babel/core";
import * as t2 from "@babel/types";

// src/features/run-server-side/implementation/transform/transform-utils.ts
import "@babel/core";
import * as t from "@babel/types";
var RUN_SERVER_SIDE_FUNCTION_NAMES = [
  "useServerSideQuery",
  "useServerSideMutation",
  "useServerSentEvents",
  "useSSQ",
  "useSSM",
  "useSSE",
  "runServerSideQuery",
  "runServerSideMutation",
  "runSSQ",
  "runSSM",
  "useFormMutation"
];
function isRunServerSideCall(expr, nameRef) {
  if (!expr.isCallExpression()) {
    return false;
  }
  const callee = expr.node.callee;
  if (t.isIdentifier(callee)) {
    const binding = expr.parentPath.scope.getBinding(callee.name);
    nameRef.name = binding?.path.node?.imported?.name;
    return !!(binding && binding.path.isImportSpecifier() && t.isIdentifier(binding.path.node.imported) && RUN_SERVER_SIDE_FUNCTION_NAMES.includes(
      binding.path.node.imported.name
    ) && binding.path.parentPath.isImportDeclaration() && binding.path.parentPath.node.source.value === "rakkasjs");
  } else if (t.isMemberExpression(callee)) {
    if (!t.isIdentifier(callee.object)) {
      return false;
    }
    const binding = expr.parentPath.scope.getBinding(callee.object.name);
    nameRef.name = callee.property?.name;
    return !!(binding && (binding.path.isImportDefaultSpecifier() || binding.path.isImportNamespaceSpecifier()) && binding.path.parentPath.isImportDeclaration() && binding.path.parentPath.node.source.value === "rakkasjs" && t.isIdentifier(callee.property) && RUN_SERVER_SIDE_FUNCTION_NAMES.includes(callee.property.name));
  }
  return false;
}
function getAlreadyUnreferenced(program) {
  const alreadyUnreferenced = /* @__PURE__ */ new Set();
  for (const [name, binding] of Object.entries(program.scope.bindings)) {
    if (!binding.referenced) {
      alreadyUnreferenced.add(name);
    }
  }
  return alreadyUnreferenced;
}
function removeUnreferenced(program, alreadyUnreferenced) {
  for (; ; ) {
    program.scope.crawl();
    let removed = false;
    for (const [name, binding] of Object.entries(program.scope.bindings)) {
      if (binding.referenced || alreadyUnreferenced.has(name)) {
        continue;
      }
      const parent = binding.path.parentPath;
      if (parent?.isImportDeclaration() && parent.node.specifiers.length === 1) {
        parent.remove();
      } else {
        binding.path.remove();
      }
      removed = true;
    }
    if (!removed) break;
  }
}
function extractUniqueId(optionsPath) {
  if (!optionsPath.isObjectExpression()) {
    throw optionsPath.buildCodeFrameError(
      "The `options` argument must be a literal object"
    );
  }
  const stableIdPath = optionsPath.get("properties").find(
    (prop) => prop.get("key")?.isIdentifier({
      name: "uniqueId"
    })
  );
  if (!stableIdPath) {
    return;
  }
  const value = stableIdPath.get("value");
  if (!value.isStringLiteral()) {
    throw value.buildCodeFrameError(
      "The `uniqueId` property of the `options` argument must be a string literal"
    );
  }
  return value.node.value;
}

// src/features/run-server-side/implementation/transform/transform-client-page.ts
function babelTransformClientSidePages() {
  return {
    visitor: {
      Program: {
        exit(program) {
          const alreadyUnreferenced = getAlreadyUnreferenced(program);
          let modified = false;
          program.traverse({
            ExportNamedDeclaration: {
              enter(path7) {
                if (t2.isFunctionDeclaration(path7.node.declaration) && SSR_EXPORTS.includes(path7.node.declaration.id.name)) {
                  path7.remove();
                  modified = true;
                } else if (t2.isVariableDeclaration(path7.node.declaration)) {
                  const declarations = path7.get("declaration").get("declarations");
                  for (const declaration of declarations) {
                    if (t2.isIdentifier(declaration.node.id) && SSR_EXPORTS.includes(declaration.node.id.name)) {
                      declaration.remove();
                      modified = true;
                    }
                  }
                } else if (path7.node.specifiers.length) {
                  const specifiers = path7.get("specifiers");
                  for (const specifier of specifiers) {
                    if (specifier.isExportSpecifier() && t2.isIdentifier(specifier.node.exported) && SSR_EXPORTS.includes(specifier.node.exported.name)) {
                      specifier.remove();
                      modified = true;
                    }
                  }
                }
              }
            }
          });
          if (modified) {
            removeUnreferenced(program, alreadyUnreferenced);
          }
        }
      }
    }
  };
}
var SSR_EXPORTS = ["headers", "prerender", "action"];

// src/features/pages/vite-plugin.ts
import { init, parse } from "es-module-lexer";
function pages() {
  let command;
  let sourcemap;
  let isPage;
  let isLayout;
  const transformSet = /* @__PURE__ */ new Set();
  return {
    name: "rakkasjs:strip-server-exports",
    api: {
      rakkas: {
        routesResolved(routes2) {
          const pages2 = routes2.filter(
            (r) => r.type === "page"
          );
          const pageSet = /* @__PURE__ */ new Set();
          const layoutSet = /* @__PURE__ */ new Set();
          for (const page of pages2) {
            pageSet.add(page.page);
            if (page.layouts) {
              for (const layout of page.layouts) {
                layoutSet.add(layout);
              }
            }
          }
          isPage = (id) => pageSet.has(id);
          isLayout = (id) => layoutSet.has(id);
        }
      }
    },
    enforce: "pre",
    configResolved(config) {
      command = config.command;
      sourcemap = !!config.build.sourcemap;
    },
    async resolveId(source, importer, options) {
      if (options.ssr) {
        return;
      }
      const resolved = await this.resolve(source, importer, {
        ...options,
        skipSelf: true
      });
      if (!resolved) return null;
      if (isPage(source) || isLayout(source)) {
        transformSet.add(resolved.id);
      } else {
        transformSet.delete(resolved.id);
      }
      return resolved;
    },
    transform: {
      order: "post",
      async handler(code, id, options) {
        if (options?.ssr || !transformSet.has(id)) return;
        const result = await transformAsync(code, {
          filename: id,
          code: true,
          plugins: [babelTransformClientSidePages()],
          sourceMaps: command === "serve" || sourcemap
        }).catch((error) => {
          this.error(error.message);
        });
        if (!result) {
          return null;
        }
        let output = result.code ?? "";
        if (command === "serve") {
          await init;
          const [, exports] = parse(output);
          if (!exports.some((e) => e.n === "default")) {
            output += `export default { moduleId: ${JSON.stringify(this.getModuleInfo(id)?.id ?? id)} };
`;
          }
          output += PAGE_HOT_RELOAD;
        }
        return {
          code: output,
          map: result.map
        };
      }
    }
  };
}
var PAGE_HOT_RELOAD = `
	if (import.meta.hot) {
		RefreshRuntime.__hmr_import(import.meta.url).then((currentExports) => {
			import.meta.hot.accept((nextExports) => {
				if (currentExports.default) {
					currentExports.default.preload = nextExports.default?.preload;
				}
				rakkas.update?.();
			});
		});
	}
`;

// src/features/run-server-side/vite-plugin.ts
import { transformAsync as transformAsync2 } from "@babel/core";

// src/features/run-server-side/implementation/transform/transform-server-side.ts
import "@babel/core";
import * as t3 from "@babel/types";
function babelTransformServerSideHooks({
  moduleId,
  uniqueIds
}) {
  let counter = 0;
  return {
    visitor: {
      Program: {
        exit(program) {
          const alreadyUnreferenced = getAlreadyUnreferenced(program);
          const hoisted = [];
          program.traverse({
            CallExpression: {
              exit(call) {
                const nameRef = {};
                if (!isRunServerSideCall(call, nameRef)) {
                  return;
                }
                const fnArgNo = nameRef.name === "runSSQ" || nameRef.name === "runServerSideQuery" ? 1 : 0;
                let fn = call.get(`arguments.${fnArgNo}`);
                let uniqueId;
                if (uniqueIds) {
                  const optionsArgNo = fnArgNo + 1;
                  const options = call.get(`arguments.${optionsArgNo}`);
                  uniqueId = options && extractUniqueId(options);
                  if (uniqueId) {
                    uniqueIds[counter] = uniqueId;
                  }
                }
                if (!fn.isArrowFunctionExpression() && !fn.isFunctionExpression()) {
                  fn = fn.replaceWith(
                    t3.arrowFunctionExpression(
                      [t3.restElement(t3.identifier("$runServerSideArgs$"))],
                      t3.callExpression(fn.node, [
                        t3.spreadElement(t3.identifier("$runServerSideArgs$"))
                      ])
                    )
                  )[0];
                }
                let body = fn.get("body");
                const identifiers = /* @__PURE__ */ new Set();
                if (body.type !== "BlockStatement") {
                  body = body.replaceWith(
                    t3.blockStatement([
                      t3.returnStatement(body.node)
                    ])
                  )[0];
                  fn.scope.parent.crawl();
                }
                body.traverse({
                  Identifier: {
                    exit(identifier3) {
                      const binding = fn.scope.parent.getBinding(
                        identifier3.node.name
                      );
                      if (program.scope.getBinding(identifier3.node.name)?.referencePaths.includes(identifier3)) {
                        return;
                      }
                      if (binding?.path.get("id") === identifier3 || binding?.referencePaths.includes(identifier3)) {
                        identifiers.add(identifier3.node.name);
                      }
                    }
                  }
                });
                const ids = [...identifiers];
                const callSiteId = uniqueId ? "id/" + encodeURIComponent(uniqueId) : moduleId + "/" + counter;
                const replacement = t3.arrayExpression([
                  t3.stringLiteral(callSiteId),
                  t3.arrayExpression(ids.map((id) => t3.identifier(id))),
                  t3.memberExpression(
                    t3.identifier("$runServerSide$"),
                    t3.numericLiteral(counter),
                    true
                  )
                ]);
                counter++;
                if (t3.isArrowFunctionExpression(fn.node) || t3.isFunctionExpression(fn.node)) {
                  fn.node.async = true;
                  fn.node.params.unshift(
                    t3.identifier("$runServerSideClosure$")
                  );
                  if (t3.isExpression(fn.node.body)) {
                    fn.node.body = t3.blockStatement([
                      t3.returnStatement(fn.node.body)
                    ]);
                  }
                  fn.node.body.body.unshift(
                    t3.variableDeclaration("let", [
                      t3.variableDeclarator(
                        t3.arrayPattern(ids.map((id) => t3.identifier(id))),
                        t3.identifier("$runServerSideClosure$")
                      )
                    ])
                  );
                }
                hoisted.push(fn.node);
                fn.replaceWith(replacement);
                if (nameRef.name === "runSSM" || nameRef.name === "runServerSideMutation") {
                  call.parentPath.replaceWith(t3.nullLiteral());
                  return;
                }
              }
            }
          });
          if (hoisted.length) {
            program.node.body.push(
              t3.exportNamedDeclaration(
                t3.variableDeclaration("const", [
                  t3.variableDeclarator(
                    t3.identifier("$runServerSide$"),
                    t3.arrayExpression(hoisted)
                  )
                ])
              )
            );
          }
          removeUnreferenced(program, alreadyUnreferenced);
        }
      }
    }
  };
}

// src/features/run-server-side/implementation/transform/transform-client-side.ts
import "@babel/core";
import * as t4 from "@babel/types";
function babelTransformClientSideHooks(args) {
  const { moduleId, uniqueIds } = args;
  return {
    visitor: {
      Program: {
        exit(program) {
          let counter = 0;
          const alreadyUnreferenced = getAlreadyUnreferenced(program);
          program.traverse({
            CallExpression: {
              exit(call) {
                const nameRef = {};
                if (!isRunServerSideCall(call, nameRef)) {
                  return;
                }
                const argNo = nameRef.name === "runSSQ" || nameRef.name === "runServerSideQuery" ? 1 : 0;
                const fn = call.get(`arguments.${argNo}`);
                let uniqueId;
                if (uniqueIds) {
                  const optionsArgNo = argNo + 1;
                  const options = call.get(`arguments.${optionsArgNo}`);
                  uniqueId = options && extractUniqueId(options);
                  if (uniqueId) {
                    uniqueIds[counter] = uniqueId;
                  }
                }
                let body = fn.get("body");
                const identifiers = /* @__PURE__ */ new Set();
                if (body.type !== "BlockStatement") {
                  body = body.replaceWith(
                    t4.blockStatement([
                      t4.returnStatement(body.node)
                    ])
                  )[0];
                  fn.scope.parent.crawl();
                }
                body.traverse({
                  Identifier: {
                    exit(identifier3) {
                      const binding = fn.scope.parent.getBinding(
                        identifier3.node.name
                      );
                      if (program.scope.getBinding(identifier3.node.name)?.referencePaths.includes(identifier3)) {
                        return;
                      }
                      if (binding?.path.get("id") === identifier3 || binding?.referencePaths.includes(identifier3)) {
                        identifiers.add(identifier3.node.name);
                      }
                    }
                  }
                });
                args.modified = true;
                const callSiteId = uniqueId ? "id/" + encodeURIComponent(uniqueId) : moduleId + "/" + counter;
                counter++;
                fn.replaceWith(
                  t4.arrayExpression([
                    t4.stringLiteral(callSiteId),
                    t4.arrayExpression(
                      [...identifiers].map((id) => t4.identifier(id))
                    )
                  ])
                );
              }
            }
          });
          if (!args.modified) {
            return;
          }
          removeUnreferenced(program, alreadyUnreferenced);
        }
      }
    }
  };
}

// src/features/run-server-side/vite-plugin.ts
function runServerSide() {
  let idCounter = 0;
  const moduleIdMap = /* @__PURE__ */ Object.create(null);
  const uniqueIdMap = /* @__PURE__ */ Object.create(null);
  let resolvedConfig;
  let moduleManifest;
  return [
    {
      name: "rakkasjs:run-server-side:manifest",
      enforce: "pre",
      config() {
        return {
          ssr: {
            noExternal: ["rakkasjs:run-server-side:manifest"]
          }
        };
      },
      resolveId(id) {
        if (id === "rakkasjs:run-server-side:manifest") {
          return "\0virtual:" + id;
        }
      },
      async load(id) {
        if (id === "\0virtual:rakkasjs:run-server-side:manifest") {
          if (resolvedConfig.command === "serve") {
            return `export const moduleMap = new Proxy({}, { get: (_, name) => () => import(/* @vite-ignore */ "/" + name) });`;
          } else if (!moduleManifest) {
            return `throw new Error("[virtual:rakkasjs:run-server-side:manifest]: Module manifest is not available on the client");`;
          }
          let code = "export const moduleMap = {";
          for (const [filePath, moduleId] of Object.entries(
            moduleManifest.moduleIdMap
          )) {
            code += `
	${JSON.stringify(
              moduleId
            )}: () => import(${JSON.stringify("/" + filePath)}),`;
          }
          code += "\n};\n";
          code += "export const idMap = {";
          for (const [uniqueId, callSiteId] of Object.entries(
            moduleManifest.uniqueIdMap
          )) {
            code += `
	${JSON.stringify(uniqueId)}: ${JSON.stringify(
              callSiteId
            )},`;
          }
          code += "\n};";
          return code;
        }
      }
    },
    {
      name: "rakkasjs:run-server-side:transform",
      enforce: "post",
      configResolved(config) {
        resolvedConfig = config;
      },
      async transform(code, id, options) {
        const uniqueIds = resolvedConfig.command === "build" && !options?.ssr ? [] : void 0;
        const plugins = [];
        const ref = {
          moduleId: "",
          modified: false,
          uniqueIds
        };
        let moduleId;
        if (code.match(
          /\buseServerSideQuery|useServerSentEvents|useServerSideMutation|useSSQ|useSSM|useSSE|runServerSideQuery|runServerSideMutation|runSSQ|runSSM|useFormMutation\b/
        ) && code.includes(`"rakkasjs"`) && !code.includes(`'rakkasjs'`)) {
          if (resolvedConfig.command === "serve") {
            moduleId = id.slice(resolvedConfig.root.length + 1);
          } else if (moduleManifest) {
            moduleId = moduleManifest.moduleIdMap[id];
          } else {
            moduleId = (idCounter++).toString(36);
          }
          moduleId = encodeURIComponent(moduleId);
          if (moduleId) {
            ref.moduleId = process.env.RAKKAS_BUILD_ID + "/" + moduleId;
            plugins.push(
              options?.ssr ? babelTransformServerSideHooks(ref) : babelTransformClientSideHooks(ref)
            );
          }
        }
        if (!plugins.length) {
          return;
        }
        const result = await transformAsync2(code, {
          filename: id,
          code: true,
          plugins,
          sourceMaps: resolvedConfig.command === "serve" || !!resolvedConfig.build.sourcemap
        }).catch((error) => {
          this.error(error.message);
        });
        if (!result) {
          return null;
        }
        if (ref.modified) {
          moduleIdMap[id] = moduleId;
          if (uniqueIds) {
            for (const [i, uniqueId] of uniqueIds.entries()) {
              if (uniqueId) {
                if (uniqueIdMap[uniqueId]) {
                  this.error(`Duplicate unique ID ${uniqueId} in ${id}`);
                }
                uniqueIdMap[uniqueId] = moduleId + "/" + i;
              }
            }
          }
        }
        return {
          code: result.code,
          map: result.map
        };
      },
      buildStepStart(_info, forwarded) {
        moduleManifest = forwarded;
      },
      buildStepEnd() {
        return { moduleIdMap, uniqueIdMap };
      }
    }
  ];
}

// src/vite-plugin/adapters.ts
import path3 from "path";
import fs2 from "fs";
import hattipCloudflareWorkers from "@hattip/bundler-cloudflare-workers";
import { bundle as netlify } from "@hattip/bundler-netlify";
import { bundle as vercel } from "@hattip/bundler-vercel";
import deno from "@hattip/bundler-deno";
import { builtinModules } from "module";
var nodePrefixedModules = builtinModules.map((m) => "node:" + m);
function defineAdapters(adapters2) {
  return adapters2;
}
var adapters = defineAdapters({
  node: {
    name: "node"
  },
  "cloudflare-workers": cloudflareWorkers(),
  "cloudflare-workers-node-compat": {
    name: "cloudflare-workers",
    async bundle(root) {
      let entry = findEntry(root, "src/entry-cloudflare-workers");
      if (!entry) {
        entry = path3.resolve(root, "dist/server/entry-cloudflare-workers.js");
        await fs2.promises.writeFile(entry, CLOUDFLARE_WORKERS_ENTRY);
      }
      await hattipCloudflareWorkers(
        {
          output: path3.resolve(
            root,
            "dist/server/cloudflare-workers-bundle.js"
          ),
          cfwEntry: entry
        },
        (options) => {
          options.define = options.define || {};
          options.define["process.env.RAKKAS_PRERENDER"] = "undefined";
          options.define["global"] = "globalThis";
          options.external = [
            ...options.external ?? [],
            ...nodePrefixedModules
          ];
        }
      );
    }
  },
  vercel: {
    name: "vercel",
    disableStreaming: true,
    async bundle(root) {
      let entry = findEntry(root, "src/entry-vercel");
      if (!entry) {
        entry = path3.resolve(root, "dist/server/entry-vercel.js");
        await fs2.promises.writeFile(entry, VERCEL_ENTRY);
      }
      await vercel({
        serverlessEntry: entry,
        staticDir: path3.resolve(root, "dist/client"),
        manipulateEsbuildOptions(options) {
          options.define = options.define || {};
          options.define["process.env.NODE_ENV"] = '"production"';
          options.define["process.env.RAKKAS_PRERENDER"] = "undefined";
        }
      });
    }
  },
  "vercel-edge": {
    name: "vercel-edge",
    async bundle(root) {
      let entry = findEntry(root, "src/entry-vercel-edge");
      if (!entry) {
        entry = path3.resolve(root, "dist/server/entry-vercel-edge.js");
        await fs2.promises.writeFile(entry, VERCEL_EDGE_ENTRY);
      }
      await vercel({
        edgeEntry: entry,
        staticDir: path3.resolve(root, "dist/client"),
        manipulateEsbuildOptions(options) {
          options.define = options.define || {};
          options.define["process.env.RAKKAS_PRERENDER"] = "undefined";
          options.define["global"] = "globalThis";
          options.external = [
            ...options.external ?? [],
            ...nodePrefixedModules
          ];
        }
      });
    }
  },
  netlify: {
    name: "netlify",
    disableStreaming: true,
    async bundle(root) {
      let entry = findEntry(root, "src/entry-netlify");
      if (!entry) {
        entry = path3.resolve(root, "dist/server/entry-netlify.js");
        await fs2.promises.writeFile(entry, NETLIFY_ENTRY);
      }
      await netlify({
        functionEntry: entry,
        staticDir: path3.resolve(root, "dist/client"),
        manipulateEsbuildOptions(options) {
          options.define = options.define || {};
          options.define["process.env.NODE_ENV"] = '"production"';
          options.define["process.env.RAKKAS_PRERENDER"] = "undefined";
        }
      });
    }
  },
  "netlify-edge": {
    name: "netlify-edge",
    async bundle(root) {
      let entry = findEntry(root, "src/entry-netlify-edge");
      if (!entry) {
        entry = path3.resolve(root, "dist/server/entry-netlify-edge.js");
        await fs2.promises.writeFile(entry, NETLIFY_EDGE_ENTRY);
      }
      await generateStaticAssetManifest(root);
      await netlify({
        edgeEntry: entry,
        staticDir: path3.resolve(root, "dist/client"),
        manipulateEsbuildOptions(options) {
          options.define = options.define || {};
          options.define["process.env.RAKKAS_PRERENDER"] = "undefined";
          options.define["global"] = "globalThis";
          options.external = [
            ...options.external ?? [],
            ...nodePrefixedModules
          ];
        }
      });
    }
  },
  deno: {
    name: "deno",
    async bundle(root) {
      let input = findEntry(root, "src/entry-deno");
      if (!input) {
        input = path3.resolve(root, "dist/server/entry-deno.js");
        await fs2.promises.writeFile(input, DENO_ENTRY);
      }
      await generateStaticAssetManifest(root);
      await deno(
        {
          input,
          output: path3.resolve(root, "dist/deno/mod.js"),
          staticDir: "dist/client"
        },
        (options) => {
          options.define = options.define || {};
          options.define["process.env.NODE_ENV"] = '"production"';
          options.define["process.env.RAKKAS_PRERENDER"] = "undefined";
          options.define["global"] = "globalThis";
        }
      );
    }
  },
  bun: {
    name: "bun",
    disableStreaming: true,
    async bundle(root) {
      let input = findEntry(root, "src/entry-bun");
      if (!input) {
        input = path3.resolve(root, "dist/server/entry-bun.js");
        await fs2.promises.writeFile(input, BUN_ENTRY);
      }
    }
  },
  lagon: {
    name: "lagon",
    disableStreaming: true,
    async bundle(root) {
      let entry = findEntry(root, "src/entry-lagon");
      if (!entry) {
        entry = path3.resolve(root, "dist/server/entry-lagon.js");
        await fs2.promises.writeFile(entry, LAGON_ENTRY);
      }
      await hattipCloudflareWorkers(
        {
          output: path3.resolve(root, "dist/server/lagon-bundle.js"),
          cfwEntry: entry
        },
        (options) => {
          options.define = options.define || {};
          options.define["process.env.RAKKAS_PRERENDER"] = "undefined";
          options.define["global"] = "globalThis";
          options.plugins = options.plugins || [];
          options.plugins.push({
            name: "async-hooks-stub",
            setup(build) {
              build.onResolve({ filter: /^node:async_hooks$/ }, () => ({
                namespace: "node",
                path: "async_hooks"
              }));
              build.onLoad(
                { namespace: "node", filter: /^async_hooks$/ },
                () => ({
                  contents: ASYNC_HOOKS_STUB
                })
              );
            }
          });
        }
      );
    }
  }
});
function cloudflareWorkers() {
  return {
    name: "cloudflare-workers",
    async bundle(root) {
      let entry = findEntry(root, "src/entry-cloudflare-workers");
      if (!entry) {
        entry = path3.resolve(root, "dist/server/entry-cloudflare-workers.js");
        await fs2.promises.writeFile(entry, CLOUDFLARE_WORKERS_ENTRY);
      }
      await hattipCloudflareWorkers(
        {
          output: path3.resolve(
            root,
            "dist/server/cloudflare-workers-bundle.js"
          ),
          cfwEntry: entry
        },
        (options) => {
          options.define = options.define || {};
          options.define["process.env.RAKKAS_PRERENDER"] = "undefined";
          options.define["global"] = "globalThis";
          options.plugins = options.plugins || [];
          options.plugins.push({
            name: "async-hooks-stub",
            setup(build) {
              build.onResolve({ filter: /^node:async_hooks$/ }, () => ({
                namespace: "node",
                path: "async_hooks"
              }));
              build.onLoad(
                { namespace: "node", filter: /^async_hooks$/ },
                () => ({
                  contents: ASYNC_HOOKS_STUB
                })
              );
            }
          });
        }
      );
    }
  };
}
function findEntry(root, name) {
  const entries = [
    path3.resolve(root, name) + ".ts",
    path3.resolve(root, name) + ".js",
    path3.resolve(root, name) + ".tsx",
    path3.resolve(root, name) + ".jsx"
  ];
  return entries.find((entry) => fs2.existsSync(entry));
}
async function generateStaticAssetManifest(root) {
  const files = walk(path3.resolve(root, "dist/client"));
  await fs2.promises.writeFile(
    path3.resolve(root, "dist/server/static-manifest.js"),
    `export default new Set(${JSON.stringify([...files])})`
  );
}
function walk(dir, root = dir, entries = /* @__PURE__ */ new Set()) {
  const files = fs2.readdirSync(dir);
  for (const file of files) {
    const filepath = path3.join(dir, file);
    const stat = fs2.statSync(filepath);
    if (stat.isDirectory()) {
      walk(filepath, root, entries);
    } else {
      entries.add("/" + path3.relative(root, filepath).replace(/\\/g, "/"));
    }
  }
  return entries;
}
var CLOUDFLARE_WORKERS_ENTRY = `
	import cloudflareWorkersAdapter from "@hattip/adapter-cloudflare-workers";

	let handler;

	export default {
		async fetch(req, env, ctx) {
			if (!globalThis.process?.env) {
				globalThis.process = globalThis.process || {};
				globalThis.process.env = new Proxy({}, {
					get(_, key) {
						if (typeof env[key] === "string") {
							return env[key];
						}
						return undefined;
					}
				});
			}

			if (!handler) {
				const hattipHandler = await import("./hattip.js");
				handler = cloudflareWorkersAdapter(hattipHandler.default);
			}

			return handler(req, env, ctx);
		}
	};
`;
var NETLIFY_ENTRY = `
	import adapter from "@hattip/adapter-netlify-functions";
	import hattipHandler from "./hattip.js";

	export const handler = adapter(hattipHandler);
`;
var NETLIFY_EDGE_ENTRY = `
	import adapter from "@hattip/adapter-netlify-edge";
	import staticFiles from "./static-manifest.js";

	export default adapter(async (ctx) => {
		globalThis.process = { env: Deno.env.toObject() };
		const path = new URL(ctx.request.url).pathname;
		if (staticFiles.has(path) || staticFiles.has(path + "/index.html")) {
			ctx.passThrough();
			return new Response("", { status: 404 });
		}

		const handler = await import("./hattip.js");

		return handler.default(ctx);
	});
`;
var VERCEL_ENTRY = `
	import { createMiddleware } from "rakkasjs/node-adapter";
	import handler from "./hattip.js";

	export default createMiddleware(handler, { origin: "", trustProxy: true });
`;
var VERCEL_EDGE_ENTRY = `
	import { ReadableStream } from 'web-streams-polyfill/ponyfill';
	Object.assign(globalThis, { ReadableStream });

	import adapter from "@hattip/adapter-vercel-edge";

	export default adapter(async ctx => {
		const handler = await import("./hattip.js");
		return handler.default(ctx);
	});
`;
var DENO_ENTRY = `
	import { createServeHandler } from "@hattip/adapter-deno";
	import * as path from "https://deno.land/std@0.201.0/path/mod.ts";
	import { serveDir } from "https://deno.land/std@0.201.0/http/file_server.ts";
	import { serve } from "https://deno.land/std@0.201.0/http/server.ts";
	import handler from "./hattip.js";
	import staticFiles from "./static-manifest.js";
	import process from "node:process";

	globalThis.process = process;

	const staticDir = path.join(path.dirname(path.fromFileUrl(import.meta.url)), "public");

	const denoHandler = createServeHandler(handler);

	serve(
		async (request, connInfo) => {
			const url = new URL(request.url);
			const path = url.pathname;
			if (staticFiles.has(path)) {
				return serveDir(request, { fsRoot: staticDir });
			} else if (staticFiles.has(path + "/index.html")) {
				url.pathname = path + "/index.html";
				return serveDir(new Request(url, request), { fsRoot: staticDir });
			}

			return denoHandler(request, connInfo);
		},
		{
			port: Number(process.env.PORT) || 3000,
		},
	);
`;
var BUN_ENTRY = `
	import url from "node:url";
	import path from "node:path";
	import bunAdapter from "@hattip/adapter-bun";
	import handler from "./hattip.js";

	const dir = path.resolve(
		path.dirname(url.fileURLToPath(new URL(import.meta.url))),
		"../client",
	);

	export default bunAdapter(handler, { staticDir: dir });
`;
var LAGON_ENTRY = `
	import lagonAdapter from "@hattip/adapter-lagon";
	import hattipHandler from "./hattip.js";

	const originalFormData = Request.prototype.formData;
	Request.prototype.formData = async function () {
		if (this.headers.get("content-type")?.startsWith("multipart/form-data")) {
			return originalFormData.call(this);
		} else {
			return new URLSearchParams(await this.text());
		}
	};

	export const handler = lagonAdapter(hattipHandler);
`;
var ASYNC_HOOKS_STUB = `
export const AsyncLocalStorage = undefined;
`;

// src/vite-plugin/server-only-client-only.ts
import { createFilter } from "vite";
import { init as init2, parse as parse2 } from "es-module-lexer";
import path4 from "path";
function serverOnlyClientOnly(options = {}) {
  const serverOnlyFilter = createFilter(
    options.serverOnlyFiles?.include ?? ["**/*.server.*", "**/server/**"],
    [
      ...normalizeFilterPattern(options.serverOnlyFiles?.exclude),
      "**/node_modules/**"
    ]
  );
  const clientOnlyFilter = createFilter(
    options.clientOnlyFiles?.include ?? ["**/*.client.*", "**/client/**"],
    [
      ...normalizeFilterPattern(options.clientOnlyFiles?.exclude),
      "**/node_modules/**"
    ]
  );
  let root;
  return {
    name: "rakkasjs:server-only-client-only",
    enforce: "post",
    config(config) {
      root = path4.posix.normalize(config.root ?? process.cwd()).replace(/\\/g, "/");
      if (!root.endsWith("/")) {
        root += "/";
      }
    },
    async transform(code, id, options2) {
      await init2;
      if (options2?.ssr && clientOnlyFilter(id) || !options2?.ssr && serverOnlyFilter(id)) {
        if (!id.startsWith(root) || id.match(/\.(?:css|scss|sass|less|styl|stylus)(?:\?|$)/)) {
          return;
        }
        id = id.slice(root.length);
        const [, exports] = parse2(code);
        let output = "// This file is excluded from the " + (options2?.ssr ? "server" : "client") + " bundle\n";
        for (const { n } of exports) {
          output += n === "default" ? "export default undefined;\n" : `export const ${n} = undefined;
`;
        }
        return {
          code: output
        };
      }
    }
  };
}
function normalizeFilterPattern(pattern) {
  return Array.isArray(pattern) ? pattern : pattern ? [pattern] : [];
}

// src/vite-plugin/rakkas-plugins.ts
import { uneval } from "devalue";
function rakkasPlugins() {
  const rakkasApis = [];
  return {
    name: "rakkasjs:rakkas-plugins",
    configResolved(config) {
      for (const plugin of config.plugins) {
        if (plugin.api?.rakkas) {
          rakkasApis.push(plugin.api.rakkas);
        }
      }
    },
    resolveId(source) {
      if ([
        "rakkasjs:plugin-server-hooks",
        "rakkasjs:plugin-client-hooks",
        "rakkasjs:plugin-common-hooks"
      ].includes(source)) {
        return "\0virtual:" + source;
      }
    },
    load(id) {
      if (id === "\0virtual:rakkasjs:plugin-server-hooks") {
        return makeModule(rakkasApis.map((api) => api.serverHooks));
      }
      if (id === "\0virtual:rakkasjs:plugin-client-hooks") {
        return makeModule(rakkasApis.map((api) => api.clientHooks));
      }
      if (id === "\0virtual:rakkasjs:plugin-common-hooks") {
        return makeModule(rakkasApis.map((api) => api.commonHooks));
      }
    }
  };
}
function makeModule(hooks) {
  const normalizedHooks = hooks.filter((hook) => hook !== void 0).flat();
  let result = "";
  let i = 1;
  const serializedOptions = [];
  for (const hook of normalizedHooks) {
    const specifier = typeof hook === "string" ? hook : hook.specifier;
    result += `import p${i++} from ${JSON.stringify(specifier)};
`;
    const options = typeof hook === "string" ? void 0 : hook.options;
    if (options === void 0) {
      serializedOptions.push(`	, // undefined (p${i - 1})
`);
    } else {
      serializedOptions.push("	" + uneval(options) + `, // p${i = 1}
`);
    }
  }
  result += `

export default [
`;
  normalizedHooks.forEach((_hook, i2) => {
    result += `	p${i2 + 1},
`;
  });
  result += "];\n";
  result += `
export const options = [
${serializedOptions.join("")}];
`;
  return result;
}

// src/vite-plugin/fs-routes.ts
import glob from "fast-glob";
import path5 from "path";
import micromatch from "micromatch";
import { pathToFileURL } from "url";
import pico from "picocolors";
function fsRoutes() {
  let resolveConfigResolvedPromise;
  const configResolvedPromise = new Promise((resolve) => {
    resolveConfigResolvedPromise = resolve;
  });
  let root;
  let configs;
  const isPage = micromatch.matcher("**/*.page.*");
  const isLayout = createMatcher("layout");
  const isGuard = micromatch.matcher("**/*.guard.*");
  const isDirGuard = createMatcher("$guard");
  const isApi = micromatch.matcher("**/*.api.*");
  const isMiddleware = createMatcher("middleware");
  const isDottedRouteFile = micromatch.matcher(
    "**/*.(page|layout|guard|$guard|api|middleware|404).*"
  );
  const isUndottedRouteFile = micromatch.matcher(
    "**/(layout|middleware|$guard).*"
  );
  const isCssFile = micromatch.matcher(
    "**/*.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)"
  );
  const isRouteFile = (filename) => {
    filename = toPosix(filename);
    return filename.startsWith(path5.posix.join(root, "src/routes/")) && (isDottedRouteFile(filename) || isUndottedRouteFile(filename)) && !isCssFile(filename);
  };
  let routesChanged;
  const result = {
    name: "rakkasjs:fs-routes",
    api: {
      rakkas: {
        async getRoutes() {
          await configResolvedPromise;
          let files = await glob(
            [
              "**/*.(page|layout|guard|$guard|api|middleware|404).*",
              "**/(layout|middleware|$guard).*",
              "!**/*.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)"
            ],
            { cwd: path5.join(root, "src/routes") }
          );
          if (path5.sep !== "/") {
            files = files.map((x) => x.replaceAll(path5.sep, "/"));
          }
          const pages2 = files.filter((x) => isPage(x));
          const layouts = files.filter((x) => isLayout(x)).sort(shortToLong);
          const guards = files.filter((x) => isGuard(x));
          const dirGuards = files.filter((x) => isDirGuard(x)).sort(shortToLong);
          const apis = files.filter((x) => isApi(x));
          const middlewares = files.filter((x) => isMiddleware(x)).sort(shortToLong);
          function getRenderMode(filename) {
            const defaults = {};
            for (const config of configs) {
              if (filename.startsWith(config.dir)) {
                if (config.value.disabled) {
                  return false;
                }
                if (config.value.renderingMode) {
                  return config.value.renderingMode;
                }
                Object.assign(defaults, config.value.defaults);
              }
            }
            return defaults.disabled === false ? false : defaults.renderingMode ?? "hydrate";
          }
          return [
            ...pages2.map((page) => {
              const path7 = filenameToPathPattern(page);
              return {
                type: "page",
                path: path7,
                page: "/src/routes/" + page,
                layouts: layouts.filter((layout) => wraps(layout, page)).map((x) => "/src/routes/" + x),
                guards: [
                  ...dirGuards.filter((guard) => wraps(guard, page)).map((x) => "/src/routes/" + x),
                  ...guards.filter((guard) => isCompanion(guard, page)).map((x) => "/src/routes/" + x)
                ],
                renderingMode: getRenderMode("/src/routes/" + page),
                is404: path7.endsWith("/$404")
              };
            }).filter((x) => x.renderingMode !== false),
            ...apis.map((api) => ({
              type: "api",
              path: filenameToPathPattern(api),
              handler: "/src/routes/" + api,
              middleware: middlewares.filter((middleware) => wraps(middleware, api)).map((x) => "/src/routes/" + x)
            })).filter((x) => getRenderMode(x.handler) !== false)
          ];
        }
      }
    },
    async configResolved(config) {
      root = config.root;
      const routeConfigFiles = await glob(
        root + "/src/routes/**/route.config.js"
      );
      const routeConfigContents = await Promise.allSettled(
        routeConfigFiles.map((file) => {
          const specifier = pathToFileURL(file) + `?${cacheBuster}`;
          return import(specifier).then((module) => module.default);
        })
      );
      cacheBuster++;
      const routeConfigs = routeConfigContents.map((result2, i) => ({
        file: routeConfigFiles[i].slice(root.length),
        ...result2
      }));
      const failed = routeConfigs.find(
        (c) => c.status === "rejected"
      );
      if (failed) {
        const message = `Failed to load ${failed.file}: ${failed.reason.stack}`;
        if (config.command === "build") {
          throw new Error(message);
        } else {
          config.logger.error(pico.red(message));
        }
      }
      config.configFileDependencies.push(...routeConfigFiles);
      configs = [];
      for (const routeConfig of routeConfigs) {
        if (routeConfig.status === "fulfilled") {
          try {
            const value = typeof routeConfig.value === "function" ? routeConfig.value(config) : routeConfig.value;
            configs.push({
              dir: routeConfig.file.slice(0, -"route.config.js".length).replace(/\\/g, "/"),
              value
            });
          } catch (error) {
            const message = `Failed to evaluate ${routeConfig.file}: ${error?.stack}`;
            if (config.command === "build") {
              throw new Error(message);
            } else {
              config.logger.error(pico.red(message));
            }
          }
        }
      }
      configs.sort((a, b) => a.dir.length - b.dir.length);
      routesChanged = () => {
        for (const plugin of config.plugins) {
          plugin.api?.rakkas?.routesChanged?.();
        }
      };
      resolveConfigResolvedPromise();
    },
    configureServer(server) {
      const isRouteConfig = micromatch.matcher(
        "/src/routes/**/route.config.js"
      );
      server.watcher.addListener("all", (ev, file) => {
        if (isRouteConfig(file) && (ev === "add" || ev === "unlink")) {
          server.config.logger.info(
            pico.green(
              `${path5.relative(
                process.cwd(),
                file
              )} changed, restarting server...`
            ),
            { clear: true, timestamp: true }
          );
          server.restart().catch(() => {
          });
        }
        if (isRouteFile(file) && (ev === "add" || ev === "unlink")) {
          routesChanged();
        }
      });
    }
  };
  return result;
}
function createMatcher(keyword) {
  const isUnnamed = micromatch.matcher(`**/${keyword}.*`);
  const isNamed = micromatch.matcher(`**/*.${keyword}.*`);
  return (filename) => isUnnamed(filename) || isNamed(filename);
}
function isCompanion(companion, target) {
  return withoutExtension(companion) === withoutExtension(target);
}
function wraps(wrapper, target) {
  const wrapperDir = path5.dirname(wrapper);
  const targetDir = path5.dirname(target);
  return wrapperDir === "." || wrapperDir === targetDir || targetDir.startsWith(wrapperDir + "/");
}
function withoutExtension(filename) {
  return filename.replace(
    /\.(?:page|layout|guard|\$guard|api|middleware|404)\.[^/.]+$/,
    ""
  );
}
function filenameToPathPattern(filename) {
  return "/" + withoutExtension(filename).split(/(?:--|\/)/).filter(
    (s) => s[0] !== "_" && s !== "index" && !(s[0] === "(" && s.endsWith(")"))
  ).join("/");
}
function shortToLong(a, b) {
  return a.length - b.length;
}
function toPosix(name) {
  if (path5.sep !== "/") {
    return name.replaceAll(path5.sep, "/");
  }
  return name;
}
var cacheBuster = 0;

// src/vite-plugin/routes.ts
import path6 from "path";
import { transformAsync as transformAsync3 } from "@babel/core";

// src/features/pages/babel-remove-exports.ts
import "@babel/core";
import * as t5 from "@babel/types";
function babelRemoveExports(mode, exportNames) {
  const nameSet = new Set(exportNames);
  function shouldRemove(name) {
    return mode === "remove" ? nameSet.has(name) : !nameSet.has(name);
  }
  return {
    visitor: {
      Program: {
        exit(program) {
          const alreadyUnreferenced = getAlreadyUnreferenced2(program);
          let modified = false;
          program.traverse({
            ExportNamedDeclaration: {
              enter(path7) {
                if (t5.isFunctionDeclaration(path7.node.declaration) && shouldRemove(path7.node.declaration.id.name)) {
                  path7.remove();
                  modified = true;
                } else if (t5.isVariableDeclaration(path7.node.declaration)) {
                  const declarations = path7.get("declaration").get("declarations");
                  for (const declaration of declarations) {
                    if (t5.isIdentifier(declaration.node.id) && shouldRemove(declaration.node.id.name)) {
                      declaration.remove();
                      modified = true;
                    }
                  }
                } else if (path7.node.specifiers.length) {
                  const specifiers = path7.get("specifiers");
                  for (const specifier of specifiers) {
                    if (specifier.isExportSpecifier() && t5.isIdentifier(specifier.node.exported) && shouldRemove(specifier.node.exported.name)) {
                      specifier.remove();
                      modified = true;
                    }
                  }
                }
              }
            },
            ExportDefaultDeclaration: {
              enter(path7) {
                if (shouldRemove("default")) {
                  path7.remove();
                  modified = true;
                }
              }
            }
          });
          if (modified) {
            removeUnreferenced2(program, alreadyUnreferenced);
          }
        }
      }
    }
  };
}
function getAlreadyUnreferenced2(program) {
  const alreadyUnreferenced = /* @__PURE__ */ new Set();
  for (const [name, binding] of Object.entries(program.scope.bindings)) {
    if (!binding.referenced) {
      alreadyUnreferenced.add(name);
    }
  }
  return alreadyUnreferenced;
}
function removeUnreferenced2(program, alreadyUnreferenced) {
  for (; ; ) {
    program.scope.crawl();
    let removed = false;
    for (const [name, binding] of Object.entries(program.scope.bindings)) {
      if (alreadyUnreferenced.has(name)) {
        continue;
      }
      if (binding.referenced) {
        if (binding.referencePaths.every(isTopLevelMemberAssignment)) {
          for (const path7 of binding.referencePaths) {
            path7.parentPath.parentPath.remove();
          }
          removed = true;
        } else {
          continue;
        }
      }
      const parent = binding.path.parentPath;
      if (parent?.isImportDeclaration() && parent.node.specifiers.length === 1) {
        parent.remove();
      } else {
        binding.path.remove();
      }
      removed = true;
    }
    if (!removed) break;
  }
}
function isTopLevelMemberAssignment(path7) {
  return path7.isIdentifier() && path7.key === "object" && path7.parentPath.isMemberExpression() && path7.parentPath.key === "left" && path7.parentPath.parentPath.isAssignmentExpression() && path7.parentPath.parentPath.parentPath.isExpressionStatement() && path7.parentPath.parentPath.parentPath.parentPath.isProgram();
}

// src/vite-plugin/routes.ts
function routes() {
  let plugins;
  let server;
  let root;
  let isBuild = false;
  let resolvedConfig;
  let routes2 = [];
  let clientOnlyFiles;
  function invalidateModuleByName(name) {
    const module = server.moduleGraph.getModuleById(name);
    if (module) {
      server.moduleGraph.invalidateModule(module);
    }
  }
  let debouncing = false;
  async function routesResolved() {
    routes2 = sortRoutes(routes2.map((route) => [route.path, route])).map(
      (r) => r[1]
    );
    for (const plugin of plugins) {
      await plugin.api?.rakkas?.routesResolved?.(routes2);
    }
  }
  return [
    {
      name: "rakkasjs:routes",
      resolveId(source) {
        if (routeFileNames.includes(source)) {
          return "\0virtual:" + source;
        }
      },
      api: {
        rakkas: {
          async routesChanged() {
            if (debouncing) {
              return;
            }
            try {
              debouncing = true;
              await new Promise((resolve) => setTimeout(resolve, 100));
            } finally {
              debouncing = false;
            }
            routes2 = await collectRoutes(plugins);
            invalidateModuleByName("\0virtual:rakkasjs:server-page-routes");
            invalidateModuleByName("\0virtual:rakkasjs:client-page-routes");
            invalidateModuleByName("\0virtual:rakkasjs:api-routes");
            await routesResolved();
            const hot = server.hot ?? server.ws;
            if (hot) {
              hot.send({
                type: "full-reload",
                path: "*"
              });
            }
          }
        }
      },
      async configResolved(config) {
        resolvedConfig = config;
        plugins = config.plugins;
        isBuild = config.command === "build";
        root = config.root;
        routes2 = await collectRoutes(plugins);
        await routesResolved();
      },
      async load(id, options) {
        if (id === "\0virtual:rakkasjs:server-page-routes") {
          const [module, cof] = generateServerPageRoutesModule(routes2);
          clientOnlyFiles = cof;
          return module;
        } else if (id === "\0virtual:rakkasjs:client-page-routes") {
          if (isBuild && options?.ssr) {
            return `export default [];
export const notFoundRoutes = [];
`;
          }
          return generateClientPageRoutesModule(routes2);
        } else if (id === "\0virtual:rakkasjs:api-routes") {
          return generateApiRoutesModule(routes2);
        }
      },
      configureServer(devServer) {
        server = devServer;
      }
    },
    {
      name: "rakkasjs:remove-client-only-files",
      enforce: "post",
      async transform(code, id, options) {
        if (!options?.ssr || !isBuild) {
          return;
        }
        if (!clientOnlyFiles?.has(path6.posix.join(id.slice(root.length)))) {
          return;
        }
        const result = await transformAsync3(code, {
          filename: id,
          code: true,
          plugins: [babelRemoveExports("remove", ["default"])],
          sourceMaps: resolvedConfig.command === "serve" || !!resolvedConfig.build.sourcemap
        });
        if (result) {
          return {
            code: result.code,
            map: result.map
          };
        } else {
          this.error(`Failed to remove exports from layout or page ${id}`);
        }
      }
    }
  ];
}
var routeFileNames = [
  "rakkasjs:server-page-routes",
  "rakkasjs:client-page-routes",
  "rakkasjs:api-routes"
];
async function collectRoutes(plugins) {
  const routes2 = [];
  for (const plugin of plugins) {
    const newRoutes = await plugin.api?.rakkas?.getRoutes?.();
    if (newRoutes) {
      routes2.push(...newRoutes);
    }
  }
  return routes2;
}
function generateServerPageRoutesModule(routes2) {
  const possibleClientOnlyFiles = /* @__PURE__ */ new Set();
  const notClientOnlyFiles = /* @__PURE__ */ new Set();
  const pages2 = routes2.filter(
    (route) => route.type === "page"
  );
  const layouts = /* @__PURE__ */ new Set();
  const guards = /* @__PURE__ */ new Set();
  for (const page of pages2) {
    for (const layout of page.layouts || []) {
      if (page.renderingMode === "client") {
        possibleClientOnlyFiles.add(layout);
      } else {
        notClientOnlyFiles.add(layout);
      }
      layouts.add(layout);
    }
    for (const guard of page.guards || []) {
      guards.add(guard);
    }
  }
  let result = "";
  let li = 0;
  const layoutNameMap = /* @__PURE__ */ new Map();
  for (const layout of layouts) {
    layoutNameMap.set(layout, li);
    result += `const l${li} = () => import(${JSON.stringify(layout)});
`;
    li++;
  }
  let gi = 0;
  const guardNameMap = /* @__PURE__ */ new Map();
  for (const guard of guards) {
    guardNameMap.set(guard, gi);
    result += `import { pageGuard as g${gi} } from ${JSON.stringify(guard)};
`;
    gi++;
  }
  const pageNameMap = /* @__PURE__ */ new Map();
  for (const [pi, page] of pages2.entries()) {
    if (page.renderingMode === "client") {
      possibleClientOnlyFiles.add(page.page);
    }
    result += `const p${pi} = () => import(${JSON.stringify(page.page)});
`;
    pageNameMap.set(page.page, pi);
  }
  function generateExports(pages3) {
    for (const page of pages3) {
      const pi = pageNameMap.get(page.page);
      result += "  [";
      const [re, restName] = routeToRegExp(page.path);
      result += re.toString() + ", ";
      const importers = [
        `p${pi}`,
        ...(page.layouts?.map((layout) => "l" + layoutNameMap.get(layout)) || []).reverse()
      ];
      result += "[" + importers.join(", ") + "], ";
      const guards2 = page.guards?.map(
        (guard) => "g" + guardNameMap.get(guard)
      );
      if (guards2) {
        result += "[" + guards2.join(", ") + "], ";
      } else {
        result += ", ";
      }
      if (restName) {
        result += JSON.stringify(restName) + ", ";
      } else {
        result += ", ";
      }
      const ids = "[" + [page.page, ...page.layouts || []].map((name) => JSON.stringify(name)).join(", ") + "],\n";
      result += ids;
      if (page.renderingMode === "server") {
        result += "1, ";
      } else if (page.renderingMode === "client") {
        result += "2, ";
      }
      result += "],\n";
    }
  }
  result += "export default [";
  generateExports(pages2.filter((page) => !page.is404));
  result += "];\n";
  result += "export const notFoundRoutes = [";
  generateExports(pages2.filter((page) => page.is404));
  result += "];\n";
  const clientOnlyFiles = /* @__PURE__ */ new Set();
  for (const file of possibleClientOnlyFiles) {
    if (!notClientOnlyFiles.has(file)) {
      clientOnlyFiles.add(file);
    }
  }
  return [result, clientOnlyFiles];
}
function generateClientPageRoutesModule(routes2) {
  const pages2 = routes2.filter(
    (route) => route.type === "page" && route.renderingMode !== "server"
  );
  const layouts = /* @__PURE__ */ new Set();
  const guards = /* @__PURE__ */ new Set();
  for (const page of pages2) {
    for (const layout of page.layouts || []) {
      layouts.add(layout);
    }
    for (const guard of page.guards || []) {
      guards.add(guard);
    }
  }
  let result = "";
  let li = 0;
  const layoutNameMap = /* @__PURE__ */ new Map();
  for (const layout of layouts) {
    layoutNameMap.set(layout, li);
    result += `const l${li} = () => import(${JSON.stringify(layout)});
`;
    li++;
  }
  let gi = 0;
  const guardNameMap = /* @__PURE__ */ new Map();
  for (const guard of guards) {
    guardNameMap.set(guard, gi);
    result += `import { pageGuard as g${gi} } from ${JSON.stringify(guard)};
`;
    gi++;
  }
  const pageNameMap = /* @__PURE__ */ new Map();
  for (const [pi, page] of pages2.entries()) {
    result += `const p${pi} = () => import(${JSON.stringify(page.page)});
`;
    pageNameMap.set(page.page, pi);
  }
  function generateExports(pages3) {
    for (const page of pages3) {
      const pi = pageNameMap.get(page.page);
      result += "  [";
      const [re, restName] = routeToRegExp(page.path);
      result += re.toString() + ", ";
      const importers = [
        `p${pi}`,
        ...(page.layouts?.map((layout) => "l" + layoutNameMap.get(layout)) || []).reverse()
      ];
      result += "[" + importers.join(", ") + "], ";
      const guards2 = page.guards?.map(
        (guard) => "g" + guardNameMap.get(guard)
      );
      if (guards2) {
        result += "[" + guards2.join(", ") + "], ";
      } else {
        result += ", ";
      }
      if (restName) {
        result += JSON.stringify(restName) + ", ";
      } else {
        result += ", ";
      }
      result += "],\n";
    }
  }
  result += "export default [";
  generateExports(pages2.filter((page) => !page.is404));
  result += "];\n";
  result += "export const notFoundRoutes = [";
  generateExports(pages2.filter((page) => page.is404));
  result += "];\n";
  return result;
}
function generateApiRoutesModule(routes2) {
  const apiRoutes = routes2.filter(
    (route) => route.type === "api"
  );
  const middlewares = /* @__PURE__ */ new Set();
  for (const route of apiRoutes) {
    for (const middleware of route.middleware || []) {
      middlewares.add(middleware);
    }
  }
  let result = "";
  let mi = 0;
  const middlewareNameMap = /* @__PURE__ */ new Map();
  for (const middleware of middlewares) {
    middlewareNameMap.set(middleware, mi);
    result += `const m${mi} = () => import(${JSON.stringify(middleware)});
`;
    mi++;
  }
  for (const [ei, route] of apiRoutes.entries()) {
    result += `const e${ei} = () => import(${JSON.stringify(route.handler)});
`;
  }
  result += "export default [";
  for (const [ei, route] of apiRoutes.entries()) {
    result += "  [";
    const [re, restName] = routeToRegExp(route.path);
    result += re.toString() + ", ";
    const importers = route.middleware?.map((middleware) => "m" + middlewareNameMap.get(middleware)).reverse() || [];
    importers.unshift(`e${ei}`);
    result += "[" + importers.join(", ") + "], ";
    if (restName) {
      result += JSON.stringify(restName) + ", ";
    }
    result += "],\n";
  }
  result += "];\n";
  return result;
}

// src/vite-plugin/index.ts
function rakkas(options = {}) {
  const { fsRoutes: enableFsRoutes = true, routes: customRoutes } = options;
  let { prerender = [], adapter = "node" } = options;
  if (prerender === true) {
    prerender = ["/"];
  } else if (prerender === false) {
    prerender = [];
  }
  if (typeof adapter === "string") {
    adapter = adapters[adapter];
  }
  const [routesPre, routesPost] = routes();
  const result = [
    globalThis.__vavite_loader__ && nodeLoaderPlugin(),
    ...vaviteConnect({
      handlerEntry: "/rakkasjs:node-entry",
      clientAssetsDir: "dist/client",
      serveClientAssetsInDev: true
    }),
    exposeViteDevServer(),
    preventViteBuild(),
    injectConfig({
      prerender,
      adapter,
      strictMode: options.strictMode ?? true
    }),
    enableFsRoutes && fsRoutes(),
    customRoutes && {
      name: "rakkasjs:custom-routes",
      api: {
        rakkas: {
          getRoutes() {
            return customRoutes;
          }
        }
      }
    },
    routesPre,
    pages(),
    virtualDefaultEntry({
      entry: "/src/entry-node",
      virtualName: "node-entry",
      defaultContent: DEFAULT_NODE_ENTRY_CONTENTS
    }),
    virtualDefaultEntry({
      entry: "/src/entry-hattip",
      virtualName: "hattip-entry",
      defaultContent: DEFAULT_HATTIP_ENTRY_CONTENTS
    }),
    virtualDefaultEntry({
      entry: "/src/entry-client",
      virtualName: "client-entry",
      defaultContent: DEFAULT_CLIENT_ENTRY_CONTENTS,
      resolveName: false
    }),
    virtualDefaultEntry({
      entry: "/src/common-hooks",
      virtualName: "common-hooks",
      defaultContent: DEFAULT_COMMON_HOOKS_CONTENTS,
      resolveName: false
    }),
    virtualDefaultEntry({
      entry: "/src/routes/$error",
      virtualName: "error-page",
      defaultContent: DEFAULT_ERROR_PAGE_CONTENTS
    }),
    resolveClientManifest(),
    ...runServerSide(),
    routesPost,
    serverOnlyClientOnly(options),
    rakkasPlugins()
  ];
  return result.filter(Boolean);
}
var DEFAULT_NODE_ENTRY_CONTENTS = `
	import { createMiddleware } from "rakkasjs/node-adapter";
	export default createMiddleware(
		(req, res, next) => import("rakkasjs:hattip-entry").then((m) => m.default(req, res, next)),
	);
`;
var DEFAULT_HATTIP_ENTRY_CONTENTS = `
	import { createRequestHandler } from "rakkasjs/server";
	export default createRequestHandler();
`;
var DEFAULT_CLIENT_ENTRY_CONTENTS = `
	import { startClient } from "rakkasjs/client";
	startClient();
`;
var DEFAULT_COMMON_HOOKS_CONTENTS = `
	export default {};
`;
var DEFAULT_ERROR_PAGE_CONTENTS = `
	export { DefaultErrorPage as default } from "rakkasjs";
`;

// src/cli/serve.ts
async function serve(root, options) {
  const serverOptions = cleanOptions(options);
  const inlineConfig = {
    root,
    base: options.base,
    mode: options.mode,
    configFile: options.config,
    logLevel: options.logLevel,
    clearScreen: options.clearScreen,
    server: serverOptions
  };
  const initialConfig = await resolveConfig(inlineConfig, "serve").catch(
    (error) => {
      console.error(pico2.red(`error resolving config:
${error.stack}`), {
        error
      });
      process.exit(1);
    }
  );
  if (!initialConfig.plugins.some((p) => p.name === "rakkasjs:inject-config")) {
    inlineConfig.plugins = [rakkas()];
  }
  try {
    const server = await createServer(inlineConfig);
    if (!server.httpServer) {
      throw new Error("HTTP server not available");
    }
    await server.listen();
    const info = server.config.logger.info;
    const startupDurationString = startTime ? pico2.dim(
      `(ready in ${pico2.white(
        pico2.bold(Math.ceil(performance.now() - startTime))
      )} ms)`
    ) : "";
    info(
      `
  ${pico2.green(
        pico2.black(pico2.bgMagenta(" RAKKAS ")) + " " + pico2.magenta(version) + " development server is running \u{1F483}"
      )} ${startupDurationString}
`,
      { clear: !server.config.logger.hasWarned }
    );
    server.printUrls();
  } catch (e) {
    initialConfig.logger.error(
      pico2.red(`error when starting dev server:
${e.stack}`),
      { error: e }
    );
    process.exit(1);
  }
}
export {
  serve
};

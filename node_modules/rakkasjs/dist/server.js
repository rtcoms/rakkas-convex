import {
  EventStreamContentType,
  Head,
  HeadContext,
  IsomorphicContext,
  LocationContext,
  QueryCacheContext,
  Redirect,
  RenderedUrlContext,
  ResponseContext,
  RouteParamsContext,
  ServerSideContext,
  composableActionData,
  createNamedContext,
  createQueryClient,
  decodeFileNameSafe,
  defaultHeadProps,
  escapeCss,
  escapeHtml,
  mergeHeadProps,
  navigationResolve,
  prefetcher,
  requestContextStorage,
  require_types,
  restoreScrollPosition,
  sortHeadTags,
  sortHooks,
  useLocation
} from "./chunk-53EWDOCE.js";
import {
  __commonJS,
  __toESM
} from "./chunk-JSBRDJBE.js";

// ../../node_modules/.pnpm/@brillout+json-serializer@0.5.13/node_modules/@brillout/json-serializer/dist/cjs/parse.js
var require_parse = __commonJS({
  "../../node_modules/.pnpm/@brillout+json-serializer@0.5.13/node_modules/@brillout/json-serializer/dist/cjs/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTransform = exports.parse = void 0;
    var types_1 = require_types();
    function parse2(str) {
      const value = JSON.parse(str);
      return parseTransform(value);
    }
    exports.parse = parse2;
    function parseTransform(value) {
      if (typeof value === "string") {
        return reviver(value);
      }
      if (
        // Also matches arrays
        typeof value === "object" && value !== null
      ) {
        Object.entries(value).forEach(([key, val]) => {
          ;
          value[key] = parseTransform(val);
        });
      }
      return value;
    }
    exports.parseTransform = parseTransform;
    function reviver(value) {
      for (const { match, deserialize } of types_1.types) {
        if (match(value)) {
          return deserialize(value, parse2);
        }
      }
      return value;
    }
  }
});

// src/runtime/hattip-handler.ts
import {
  compose
} from "@hattip/compose";

// src/features/api-routes/middleware.ts
import {
  composePartial
} from "@hattip/compose";

// src/runtime/feature-common-hooks.ts
import * as commonHooksModule from "rakkasjs:common-hooks";
import pluginFactories, {
  options as configOptions
} from "rakkasjs:plugin-common-hooks";
var commonHooks = [
  ...pluginFactories.map((factory, i) => {
    const { commonPluginOptions = {} } = commonHooksModule;
    return factory(commonPluginOptions, configOptions[i]);
  }),
  commonHooksModule.default
];

// src/internal/find-page.tsx
var beforePageLookupHandlers = sortHooks(
  commonHooks.map((hook) => hook.beforePageLookup)
);
async function findPage(routes, url, path, pageContext, notFound2) {
  let rewritten;
  let renderedUrl = url;
  const lookupContext = { ...pageContext, url, renderedUrl };
  if (!notFound2) {
    for (const handler of beforePageLookupHandlers) {
      let result = handler(lookupContext);
      if (result instanceof Promise) {
        result = await result;
      }
      if (!result) return void 0;
      if (result === true) continue;
      if ("redirect" in result) {
        const location2 = String(result.redirect);
        return { redirect: location2 };
      } else {
        renderedUrl = new URL(result.rewrite, renderedUrl);
        path = renderedUrl.pathname;
      }
    }
  }
  do {
    rewritten = false;
    outer: for (const route of routes) {
      const re = route[0];
      const match = path.match(re);
      if (!match) continue;
      const params = unescapeParams(match.groups || {}, route[3]);
      const guardContext = { ...pageContext, url, renderedUrl, params };
      const guards = route[2] || [];
      for (const guard of guards) {
        let result = guard(guardContext);
        if (result instanceof Promise) {
          result = await result;
        }
        if (!result) {
          continue outer;
        } else if (result === true) {
          continue;
        } else if ("rewrite" in result) {
          renderedUrl = new URL(result.rewrite, renderedUrl);
          path = renderedUrl.pathname;
          if (url.href !== renderedUrl.href) {
            rewritten = true;
          }
          break outer;
        } else {
          return result;
        }
      }
      return {
        route,
        params,
        renderedUrl
      };
    }
  } while (rewritten);
}
function unescapeParams(params, rest) {
  for (const [key, value] of Object.entries(params)) {
    if (key === rest) continue;
    params[key] = decodeURIComponent(value);
  }
  return params;
}

// src/features/api-routes/middleware.ts
async function renderApiRoute(ctx) {
  const apiRoutes = await import("rakkasjs:api-routes");
  for (const [regex, importers, rest] of apiRoutes.default) {
    const match = regex.exec(ctx.url.pathname);
    if (!match) continue;
    ctx.params = unescapeParams(match.groups || {}, rest);
    const [endpointImporter, ...middlewareImporters] = importers;
    let endpoint = await endpointImporter();
    if (endpoint.default) endpoint = endpoint.default;
    let method = ctx.method.toLowerCase();
    if (method === "delete") method = "del";
    const endpointHandler = endpoint[method] || endpoint.all;
    if (!endpointHandler) return;
    const middlewares = await Promise.all(
      middlewareImporters.map(
        (importer) => importer().then((module) => module.default)
      )
    );
    const handler = composePartial([...middlewares, endpointHandler]);
    return handler(ctx);
  }
}

// src/features/pages/middleware.tsx
import React4, { StrictMode } from "react";
import {
  renderToReadableStream,
  renderToStaticMarkup
} from "react-dom/server.browser";
import clientManifest from "rakkasjs:client-manifest";

// src/runtime/App.tsx
import React2, {
  useContext,
  useDeferredValue,
  useEffect,
  useReducer,
  useState
} from "react";

// src/features/pages/Default404Page.tsx
import React from "react";
function Default404Page() {
  return import.meta.env.DEV ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Head, { title: "Not Found" }), /* @__PURE__ */ React.createElement("h1", null, "Not Found"), /* @__PURE__ */ React.createElement("p", null, "This is Rakkas's default 404 page. It will ", /* @__PURE__ */ React.createElement("b", null, "not be available"), " ", "when you build your application for production and a bare \u201CNot Found\u201D message will be displayed instead."), /* @__PURE__ */ React.createElement("p", null, "Create a ", /* @__PURE__ */ React.createElement("code", null, "$404.page.jsx"), " in your ", /* @__PURE__ */ React.createElement("code", null, "routes"), " ", "directory to provide a custom 404 page.")) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Head, { title: "Not Found" }), /* @__PURE__ */ React.createElement("h1", null, "Not Found"));
}

// src/runtime/App.tsx
function useCurrentUrl() {
  const ssrHref = useContext(LocationContext);
  return new URL(import.meta.env.SSR ? ssrHref : location.href);
}
function App(props) {
  const [id, setId] = useState("initial");
  const currentUrl = useCurrentUrl();
  if (typeof rakkas !== "undefined") {
    rakkas.setNextId = setId;
  }
  const lastRoute = useContext(RouteContext);
  const [updateCounter, update] = useReducer(
    (old) => old + 1 & 268435455,
    0
  );
  const forcedUpdate = (lastRoute.updateCounter || 0) !== updateCounter;
  const actionData = import.meta.env.SSR ? props.ssrActionData : history.state?.actionData;
  if (!import.meta.env.SSR) rakkas.update = update;
  const pageContext = useContext(IsomorphicContext);
  pageContext.actionData = actionData;
  if (!import.meta.env.SSR) {
    prefetcher.prefetch = function prefetch(location2, preload) {
      const url = new URL(location2, currentUrl);
      url.hash = "";
      if (url.origin !== window.location.origin) return;
      loadRoute(
        pageContext,
        url,
        lastRoute.found,
        false,
        actionData,
        props.ssrMeta,
        props.ssrPreloaded,
        props.ssrModules,
        preload ? "preload" : true
      ).catch((e) => {
        console.error(e);
      });
    };
  }
  if ("error" in lastRoute) {
    throw lastRoute.error;
  }
  if (!lastRoute.last || lastRoute.last.id !== void 0 && lastRoute.last.id !== id || forcedUpdate) {
    lastRoute.updateCounter = updateCounter;
    throw loadRoute(
      pageContext,
      currentUrl,
      lastRoute.found,
      false,
      actionData,
      props.ssrMeta,
      props.ssrPreloaded,
      props.ssrModules
    ).then((route) => {
      lastRoute.last = route && { id, ...route };
    }).catch(async () => {
      window.location.reload();
      await new Promise(() => {
      });
    });
  }
  lastRoute.last.id = id;
  const app = lastRoute.last.app;
  return app;
}
var RouteContext = createNamedContext(
  "RouteContext",
  {
    updateCounter: 0
  }
);
async function loadRoute(pageContext, url, lastFound, try404, actionData, ssrMeta, ssrPreloaded, ssrModules, prefetchOnly = false) {
  let found = lastFound;
  const { pathname: originalPathname } = url;
  let updatedComponents;
  if (!found || import.meta.hot) {
    const prodModule = await import("rakkasjs:client-page-routes");
    const routes = prodModule.default;
    const notFoundRoutes = prodModule.notFoundRoutes;
    let pathname = url.pathname;
    const result = await findPage(routes, url, pathname, pageContext, false);
    if (result && "redirect" in result) {
      const location2 = String(result.redirect);
      return {
        pathname: originalPathname,
        search: url.search,
        actionData,
        app: /* @__PURE__ */ React2.createElement(
          Redirect,
          {
            href: location2,
            status: result.status,
            permanent: result.permanent
          }
        )
      };
    }
    found = result;
    while (!found) {
      if (prefetchOnly) return;
      if (!try404) {
        location.assign(url.href);
        await new Promise(() => {
        });
      }
      if (!pathname.endsWith("/")) {
        pathname += "/";
      }
      const result2 = await findPage(
        notFoundRoutes,
        url,
        pathname + "$404",
        pageContext,
        true
      );
      if (result2 && "redirect" in result2) {
        location.assign(result2.redirect);
        await new Promise(() => {
        });
      }
      found = result2;
      if (!found && pathname === "/") {
        found = {
          params: {},
          route: [
            /^\/$/,
            [async () => ({ default: Default404Page })],
            [],
            void 0,
            []
          ],
          renderedUrl: url
        };
      }
      pathname = pathname.split("/").slice(0, -2).join("/") || "/";
    }
  }
  const importers = found.route[1];
  const preloadContext = {
    ...pageContext,
    url,
    renderedUrl: found.renderedUrl,
    params: found.params
  };
  const promises = importers.map(
    async (importer, i) => Promise.resolve(ssrModules?.[importers.length - 1 - i] || importer()).then(
      async (module) => {
        if (prefetchOnly === true) return;
        const preload = import.meta.hot && updatedComponents ? updatedComponents[i]?.preload : module.default?.preload;
        try {
          if (!import.meta.env.SSR && i === rakkas.actionErrorIndex) {
            delete rakkas.actionErrorIndex;
            throw new Error("Action error");
          }
          const preloaded2 = ssrPreloaded?.[i] ?? await preload?.(preloadContext);
          return [module.default, preloaded2];
        } catch (preloadError) {
          return [
            () => {
              throw preloadError;
            }
          ];
        }
      }
    )
  );
  const layoutStack = await Promise.all(promises);
  if (prefetchOnly) return;
  let meta;
  let preloaded = ssrPreloaded;
  if (import.meta.env.SSR) {
    meta = ssrMeta;
  } else {
    preloaded = layoutStack.map((r) => r[1]).reverse();
    meta = {};
    preloaded.forEach(
      (p) => typeof p?.meta === "function" ? p.meta(meta) : Object.assign(meta, p?.meta)
    );
  }
  const components = layoutStack.map(
    (m) => m[0] || (({ children }) => children)
  );
  const errorFiles = /* @__PURE__ */ new Set();
  let app = components.reduce(
    (prev, Component, i) => {
      if (import.meta.env.DEV && typeof Component === "object") {
        errorFiles.add(Component.moduleId);
        Component = ({ children }) => children;
      }
      const preloadResult = preloaded[components.length - i - 1];
      return /* @__PURE__ */ React2.createElement(React2.Fragment, null, preloadResult?.head && /* @__PURE__ */ React2.createElement(Head, { ...preloadResult.head }), /* @__PURE__ */ React2.createElement(
        Component,
        {
          url,
          renderedUrl: found.renderedUrl,
          params: found.params,
          meta,
          actionData
        },
        prev
      ));
    },
    null
  );
  if (import.meta.env.DEV && !import.meta.env.SSR && errorFiles.size) {
    const message = `The following files don't have a default export:

${[
      ...errorFiles
    ].join("\n")}`;
    await (0, eval)(`(async (message) => {
			const { ErrorOverlay } = await import("/@vite/client");
			document.querySelectorAll("vite-error-overlay").forEach((n) => n.close());
			const error = new Error(message);
			error.stack = message;
			document.body.appendChild(new ErrorOverlay(error))
		})`)(message);
  }
  const preloadedRedirect = preloaded.find((p) => p?.redirect)?.redirect;
  app = /* @__PURE__ */ React2.createElement(RenderedUrlContext.Provider, { value: found.renderedUrl }, /* @__PURE__ */ React2.createElement(RouteParamsContext.Provider, { value: found.params }, preloadedRedirect && /* @__PURE__ */ React2.createElement(Redirect, { ...preloadedRedirect }), app, /* @__PURE__ */ React2.createElement(Finish, null)));
  return {
    pathname: originalPathname,
    search: url.search,
    actionData,
    app
  };
}
var initialNavigationEventEmitted = false;
function Finish() {
  const resolve = navigationResolve;
  useEffect(() => {
    resolve?.();
    if (!initialNavigationEventEmitted) {
      initialNavigationEventEmitted = true;
      rakkas.emitNavigationEvent?.(new URL(location.href));
    }
  }, [resolve]);
  return /* @__PURE__ */ React2.createElement(Scroll, null);
}
function Scroll() {
  const { pending } = useLocation();
  const href = useDeferredValue(pending?.href);
  useEffect(() => {
    if (!href) {
      restoreScrollPosition();
    }
  }, [href]);
  return null;
}
if (import.meta.hot) {
  import.meta.hot.accept("/@id/rakkasjs:client-page-routes", () => {
  });
}

// src/runtime/isbot.ts
var BOT_REGEX = /bot|check|cloud|crawler|curl|download|facebookexternalhit|flipboard|google|heritrix|ia_archiver|monitor|perl|preview|python|qwantify|scan|spider|tumblr|vkshare|wget|whatsapp|yahoo/i;
function isBot(agent) {
  return BOT_REGEX.test(agent);
}

// src/features/pages/middleware.tsx
import { uneval } from "devalue";
import viteDevServer from "@vavite/expose-vite-dev-server/vite-dev-server";

// src/features/head/server-hooks.tsx
import React3 from "react";
var headServerHooks = {
  createPageHooks(ctx) {
    return {
      wrapApp: (app) => {
        return /* @__PURE__ */ React3.createElement(HeadContext.Provider, { value: { stack: ctx.rakkas.head } }, app);
      }
    };
  }
};
var server_hooks_default = headServerHooks;
function renderHeadContent(href, stack) {
  const tags = {
    keyed: {
      base: {
        tagName: "base",
        href
      }
    },
    unkeyed: []
  };
  mergeHeadProps(tags, defaultHeadProps);
  for (const props of stack) {
    mergeHeadProps(tags, props);
  }
  const specialAttributes = {
    htmlAttributes: {},
    headAttributes: {},
    bodyAttributes: {}
  };
  let result = "";
  const elements = sortHeadTags(tags);
  for (const element of elements) {
    const tagName = element.tagName;
    if (tagName === "head") {
      specialAttributes.headAttributes = element;
      continue;
    } else if (tagName === "body") {
      specialAttributes.bodyAttributes = element;
      continue;
    } else if (tagName === "html") {
      specialAttributes.htmlAttributes = element;
      continue;
    }
    result += renderElement(element);
  }
  result += "<!-- head end -->";
  return {
    specialAttributes,
    content: result
  };
}
function renderElement(attributes) {
  const tagName = attributes.tagName ?? "meta";
  let result = "<" + tagName;
  for (const [attr, value] of Object.entries(attributes)) {
    if (["key", "textContent", "innerHTML", "children", "tagName"].includes(attr)) {
      continue;
    }
    if (value === false || value === void 0) continue;
    if (value === true) {
      result += ` ${attr}`;
      continue;
    }
    result += ` ${attr}="${escapeHtml(String(value))}"`;
  }
  if (attributes.textContent) {
    const value = attributes.textContent;
    const escaped = tagName === "style" || tagName === "script" ? escapeCss(String(value)) : escapeHtml(String(value));
    result += `>${escaped}</${tagName}>`;
  } else if (attributes.innerHTML) {
    result += `>${String(attributes.innerHTML)}</${tagName}>`;
  } else if (attributes.children) {
    const children = attributes.children.map((child) => renderElement(child)).join("");
    result += `>${children}</${tagName}>`;
  } else {
    result += ">";
    if (!["base", "link", "meta"].includes(tagName)) {
      result += `</${tagName}>`;
    }
  }
  return result;
}

// src/features/pages/middleware.tsx
import ErrorComponent from "rakkasjs:error-page";

// src/internal/accepts-devalue.ts
function acceptsDevalue(ctx) {
  const accept = ctx.request.headers.get("accept");
  return accept === "text/javascript; devalue" || // It is conceivable that some CDNs may strip the parameter, just to be safe
  accept === "text/javascript" || // TODO: Remove this (kept for backward compatibility)
  accept === "application/javascript";
}

// src/features/pages/middleware.tsx
var assetPrefix = import.meta.env.BASE_URL ?? "/";
var pageContextMap = /* @__PURE__ */ new WeakMap();
async function renderPageRoute(ctx) {
  if (ctx.method === "POST" && ctx.url.searchParams.get("_action")) {
    return;
  }
  const pageHooks = ctx.rakkas.hooks.map((hook) => hook.createPageHooks?.(ctx));
  const extendPageContextHandlers = sortHooks([
    ...pageHooks.map((hook) => hook?.extendPageContext),
    ...commonHooks.map((hook) => hook.extendPageContext)
  ]);
  const { default: routes, notFoundRoutes } = await import("rakkasjs:server-page-routes");
  let {
    url: { pathname }
  } = ctx;
  let pageContext = pageContextMap.get(ctx.request);
  if (!pageContext) {
    pageContext = { url: ctx.url, locals: {} };
    for (const handler of extendPageContextHandlers) {
      await handler(pageContext);
    }
    pageContextMap.set(ctx.request, pageContext);
  }
  let found;
  if (ctx.rakkas.notFound) {
    do {
      if (!pathname.endsWith("/")) {
        pathname += "/";
      }
      found = await findPage(
        notFoundRoutes,
        ctx.url,
        pathname + "$404",
        pageContext,
        true
      );
      if (found) {
        break;
      }
      if (pathname === "/") {
        found = {
          params: {},
          route: [
            /^\/$/,
            [async () => ({ default: Default404Page })],
            [],
            void 0,
            []
          ],
          renderedUrl: ctx.url
        };
      }
      pathname = pathname.split("/").slice(0, -2).join("/") || "/";
    } while (!found);
  } else {
    pathname = ctx.url.pathname;
    const result = await findPage(
      routes,
      ctx.url,
      pathname,
      pageContext,
      false
    );
    found = result;
    if (!found) return;
  }
  if (found && "redirect" in found) {
    const location2 = String(found.redirect);
    return new Response(redirectBody(location2), {
      status: found.status ?? found.permanent ? 301 : 302,
      headers: makeHeaders(
        {
          location: new URL(location2, ctx.url.origin).href,
          "content-type": "text/html; charset=utf-8"
        },
        found.headers
      )
    });
  }
  let renderMode = ["hydrate", "server", "client"][found.route[5] ?? 0];
  const headers = new Headers({
    "Content-Type": "text/html; charset=utf-8"
  });
  let scriptId;
  let scriptPath;
  if (import.meta.env.PROD) {
    for (const [id, entry] of Object.entries(clientManifest)) {
      if (entry.isEntry) {
        scriptId = "/" + id;
        scriptPath = entry.file;
        break;
      }
    }
    if (!scriptId) throw new Error("Entry not found in client manifest");
  } else {
    scriptId = "rakkasjs:client-entry";
  }
  if (renderMode === "client" && ctx.method === "GET") {
    const prefetchOutput2 = await createPrefetchTags(ctx, [scriptId]);
    const head2 = renderHead(
      ctx,
      prefetchOutput2,
      renderMode,
      void 0,
      void 0,
      pageHooks
    );
    let html = head2 + `<div id="root"></div></body>`;
    html += `<script type="module" src="${scriptPath ? [assetPrefix + scriptPath] : ["/" + scriptId]}"></script>`;
    html += `</html>`;
    return new Response(html, {
      status: 200,
      headers
    });
  }
  let redirected;
  let status;
  let hold = process.env.RAKKAS_PRERENDER === "true" || import.meta.env.RAKKAS_DISABLE_STREAMING === "true" ? true : 0;
  function updateHeaders(props) {
    if (props.status) {
      status = typeof props.status === "function" ? props.status(status) : props.status;
    }
    if (hold !== true && import.meta.env.RAKKAS_DISABLE_STREAMING !== "true" && props.throttleRenderStream !== void 0) {
      hold = props.throttleRenderStream;
    }
    if (typeof props.headers === "function") {
      props.headers(headers);
    } else if (props.headers) {
      for (const [key, value] of Object.entries(props.headers)) {
        const values = Array.isArray(value) ? value : [value];
        for (const v of values) {
          headers.append(key, v);
        }
      }
    }
    if (props.redirect) {
      redirected = redirected ?? props.redirect;
      reactStream.cancel().catch(() => {
      });
    }
  }
  const importers = found.route[1];
  const preloadContext = {
    ...pageContext,
    params: found.params
  };
  const modules = await Promise.all(importers.map((importer) => importer()));
  let actionResult;
  let actionErrorIndex = -1;
  let actionError;
  if (ctx.method !== "GET") {
    const composable = composableActionData.get(ctx);
    if (composable) {
      actionResult = composable[1];
    } else {
      for (const [i, module] of modules.entries()) {
        if (module.action) {
          try {
            actionResult = await module.action(preloadContext);
          } catch (error) {
            actionError = error;
            actionErrorIndex = i;
          }
          break;
        }
      }
    }
  }
  if (acceptsDevalue(ctx)) {
    if (actionResult && "redirect" in actionResult) {
      actionResult.redirect = String(actionResult.redirect);
    }
    return new Response(uneval(actionResult), {
      status: actionErrorIndex >= 0 ? 500 : actionResult?.status ?? 200,
      headers: makeHeaders(
        { "content-type": "text/javascript; devalue" },
        actionResult?.headers
      )
    });
  }
  if (actionResult && actionResult.redirect) {
    const location2 = new URL(actionResult.redirect, ctx.url.origin).href;
    return new Response(redirectBody(location2), {
      status: actionResult.status ?? 302,
      headers: makeHeaders(
        {
          location: location2,
          "content-type": "text/html; charset=utf-8"
        },
        actionResult.headers
      )
    });
  }
  status = actionResult?.status ?? (ctx.rakkas.notFound ? 404 : 200);
  pageContext.actionData = actionResult?.data;
  preloadContext.actionData = actionResult?.data;
  const reverseModules = modules.reverse();
  const preloaded = await Promise.all(
    reverseModules.map(async (m, i) => {
      try {
        if (i === modules.length - 1 - actionErrorIndex) {
          throw new Error(actionError);
        }
        const preloaded2 = await m.default?.preload?.(preloadContext);
        return preloaded2;
      } catch (preloadError) {
        modules[i] = {
          default() {
            throw preloadError;
          }
        };
      }
    })
  );
  const meta = {};
  preloaded.forEach(
    (p) => typeof p?.meta === "function" ? p.meta(meta) : Object.assign(meta, p?.meta)
  );
  let app = /* @__PURE__ */ React4.createElement(
    App,
    {
      ssrActionData: actionResult?.data,
      ssrMeta: meta,
      ssrPreloaded: preloaded,
      ssrModules: modules
    }
  );
  const wrapAppHandlers = sortHooks([
    ...pageHooks.map((hook) => hook?.wrapApp),
    ...commonHooks.map((hook) => hook.wrapApp)
  ]).reverse();
  for (const handler of wrapAppHandlers) {
    app = handler(app);
  }
  app = /* @__PURE__ */ React4.createElement(ServerSideContext.Provider, { value: ctx }, /* @__PURE__ */ React4.createElement(IsomorphicContext.Provider, { value: pageContext }, app));
  for (const m of modules) {
    const headers2 = await m.headers?.(preloadContext, meta);
    if (headers2) {
      updateHeaders(headers2);
    }
    if (process.env.RAKKAS_PRERENDER === "true") {
      let prerender2 = { links: [] };
      for (const m2 of modules) {
        const value = await m2.prerender?.(preloadContext, meta);
        if (value) {
          prerender2 = {
            ...prerender2,
            ...value,
            links: [...prerender2.links, ...value.links ?? []]
          };
        }
      }
      ctx.platform.prerenderOptions = prerender2;
    }
  }
  app = /* @__PURE__ */ React4.createElement("div", { id: "root" }, /* @__PURE__ */ React4.createElement(ResponseContext.Provider, { value: updateHeaders }, /* @__PURE__ */ React4.createElement(
    RouteContext.Provider,
    {
      value: {
        found
      }
    },
    app
  )));
  if (import.meta.env.DEV && process.env.RAKKAS_STRICT_MODE === "true") {
    app = /* @__PURE__ */ React4.createElement(StrictMode, null, app);
  }
  const bootstrapModules = renderMode === "server" ? [] : scriptPath ? [assetPrefix + scriptPath] : ["/" + scriptId];
  let onErrorCalled = false;
  const reactStream = await renderToReadableStream(app, {
    // TODO: AbortController
    bootstrapModules,
    onError(error) {
      onErrorCalled = true;
      if (!redirected) {
        status = 500;
        if (error && typeof error.toResponse === "function") {
          void Promise.resolve(error.toResponse()).then(
            (response) => {
              status = response.status;
            }
          );
        } else if (process.env.RAKKAS_PRERENDER) {
          ctx.platform.reportError(error);
        } else {
          console.error(error);
        }
      }
    }
  }).catch(async (error) => {
    if (!onErrorCalled && !redirected) {
      status = 500;
      if (error && typeof error.toResponse === "function") {
        const response = await error.toResponse();
        status = response.status;
      } else if (process.env.RAKKAS_PRERENDER) {
        ctx.platform.reportError(error);
      } else {
        console.error(error);
      }
    }
    renderMode = "client";
    return renderToReadableStream(
      /* @__PURE__ */ React4.createElement(ServerSideContext.Provider, { value: ctx }, /* @__PURE__ */ React4.createElement(IsomorphicContext.Provider, { value: pageContext }, /* @__PURE__ */ React4.createElement("div", { id: "root" }, /* @__PURE__ */ React4.createElement(
        ErrorComponent,
        {
          error: new Error("Internal Error"),
          resetErrorBoundary: () => {
          }
        }
      )))),
      {
        bootstrapModules
      }
    );
  });
  try {
    const userAgent = ctx.request.headers.get("user-agent");
    if (hold === true || userAgent && isBot(userAgent)) {
      await reactStream.allReady;
    } else if (hold > 0) {
      await Promise.race([
        reactStream.allReady,
        new Promise((resolve) => {
          setTimeout(resolve, hold);
        })
      ]);
    }
  } catch (error) {
    if (!redirected) {
      if (error && typeof error.toResponse === "function") {
        const response = await error.toResponse();
        status = response.status;
      } else if (process.env.RAKKAS_PRERENDER) {
        ctx.platform.reportError(error);
      } else {
        console.error(error);
        status = 500;
      }
    }
  }
  if (redirected) {
    return new Response(redirectBody(headers.get("location")), {
      status,
      headers
    });
  }
  const prefetchOutput = await createPrefetchTags(ctx, [
    scriptId,
    ...found.route[4]
  ]);
  const head = renderHead(
    ctx,
    prefetchOutput,
    renderMode,
    actionResult?.data,
    actionErrorIndex,
    pageHooks
  );
  const wrapSsrStreamHandlers = sortHooks(
    pageHooks.map((hook) => hook?.wrapSsrStream)
  );
  let wrapperStream = reactStream;
  for (const handler of wrapSsrStreamHandlers) {
    wrapperStream = handler(wrapperStream);
  }
  const textEncoder = new TextEncoder();
  const { readable, writable } = new TransformStream();
  const bufferedChunks = [];
  const writer = hold === true ? {
    write(chunk) {
      bufferedChunks.push(chunk);
    },
    close() {
    }
  } : writable.getWriter();
  const emitBeforeSsrChunkHandlers = sortHooks(
    pageHooks.map((hook) => hook?.emitBeforeSsrChunk)
  );
  async function pipe() {
    await writer.write(textEncoder.encode(head));
    for await (const chunk of wrapperStream) {
      for (const handler of emitBeforeSsrChunkHandlers) {
        const text = handler();
        if (text) {
          await writer.write(textEncoder.encode(text));
        }
      }
      await writer.write(chunk);
    }
    await writer.write(textEncoder.encode("</body></html>"));
    await writer.close();
  }
  const pipePromise = pipe().catch(() => {
  });
  if (hold === true) {
    await pipePromise;
    const output = new Uint8Array(
      bufferedChunks.reduce((acc, chunk) => acc + chunk.length, 0)
    );
    let offset = 0;
    for (const chunk of bufferedChunks) {
      output.set(chunk, offset);
      offset += chunk.length;
    }
    return new Response(output, { status, headers });
  }
  ctx.waitUntil(pipePromise);
  return new Response(readable, { status, headers });
}
var REACT_FAST_REFRESH_PREAMBLE = `import RefreshRuntime from '/@react-refresh'
RefreshRuntime.injectIntoGlobalHook(window)
window.$RefreshReg$ = () => {}
window.$RefreshSig$ = () => (type) => type
window.__vite_plugin_react_preamble_installed__ = true`;
function redirectBody(href) {
  const escaped = escapeHtml(href);
  return `<!DOCTYPE html><html><head><meta http-equiv="refresh" content="0; url=${escaped}"></head><body><a href="${escaped}">${escaped}</a></body></html>`;
}
function makeHeaders(init2, headers) {
  const result = new Headers(init2);
  if (typeof headers === "function") {
    headers(result);
  } else if (headers) {
    for (const [header, value] of Object.entries(headers)) {
      if (Array.isArray(value)) {
        for (const v of value) {
          result.append(header, v);
        }
      } else {
        result.set(header, value);
      }
    }
  }
  return result;
}
async function createPrefetchTags(ctx, moduleIds) {
  const pageUrl = ctx.url;
  let result = "";
  if (!viteDevServer) {
    moduleIds = moduleIds.map((id) => id.slice(1));
    moduleIds.push("virtual:rakkasjs:client-page-routes");
    const moduleSet = new Set(moduleIds);
    const cssSet = /* @__PURE__ */ new Set();
    const elements = [];
    for (const moduleId of moduleSet) {
      const manifestEntry = clientManifest?.[moduleId];
      if (!manifestEntry) continue;
      manifestEntry.imports?.forEach((id) => moduleSet.add(id));
      manifestEntry.css?.forEach((id) => cssSet.add(id));
      const script = clientManifest?.[moduleId].file;
      if (script) {
        elements.push({
          tagName: "link",
          rel: "modulepreload",
          href: assetPrefix + script,
          crossorigin: "",
          "data-sr": true
        });
      }
    }
    for (const cssFile of cssSet) {
      elements.push({
        tagName: "link",
        rel: "stylesheet",
        href: assetPrefix + cssFile,
        "data-sr": true
      });
    }
    ctx.rakkas.head.push({ elements });
  } else {
    await viteDevServer.transformRequest("rakkasjs:client-entry").catch(() => null);
    const moduleSet = new Set(moduleIds);
    const cssSet = /* @__PURE__ */ new Map();
    for (const moduleUrl of moduleSet) {
      const module = await viteDevServer.moduleGraph.getModuleByUrl(moduleUrl);
      if (!module) continue;
      const importedModules = [
        ...module.ssrImportedModules ?? [],
        ...module.clientImportedModules ?? []
      ].map((m) => ({ id: m.id, url: m.url }));
      for (const imported of importedModules) {
        const url = new URL(imported.url, pageUrl);
        url.searchParams.delete("v");
        url.searchParams.delete("t");
        if (url.href.match(/\.(css|scss|sass|less|styl|stylus)$/)) {
          if (imported.id) cssSet.set(imported.id, imported.url);
        } else if (url.href.match(/\.(js|jsx|ts|tsx)$/)) {
          moduleSet.add(imported.url);
        }
      }
    }
    for (const [id, url] of cssSet) {
      const directUrl = url + (url.includes("?") ? "&" : "?") + "direct";
      const transformed = await viteDevServer.transformRequest(directUrl);
      if (!transformed) continue;
      result += `<style type="text/css" data-vite-dev-id=${JSON.stringify(
        id
      )}>${escapeCss(transformed.code)}</style>`;
    }
  }
  return result;
}
function renderHead(ctx, prefetchOutput, renderMode, actionData = void 0, actionErrorIndex = -1, pageHooks = []) {
  const browserGlobal = { headTagStack: [], headOrder: 0 };
  if (actionErrorIndex >= 0 && renderMode !== "server") {
    browserGlobal.actionErrorIndex = actionErrorIndex;
  }
  if (actionData !== void 0 && renderMode !== "server") {
    browserGlobal.actionData = actionData;
  }
  if (renderMode === "client") {
    browserGlobal.clientRender = true;
  }
  const script = {
    tagName: "script",
    "data-sr": true,
    textContent: `rakkas=${uneval(browserGlobal)};`
  };
  const emitToSyncHeadScriptHandlers = sortHooks(
    pageHooks.map((hook) => hook?.emitToSyncHeadScript)
  );
  for (const handler of emitToSyncHeadScriptHandlers) {
    const body = handler();
    if (!body) continue;
    script.textContent += body;
  }
  ctx.rakkas.head.push({ elements: [script] });
  const emitServerOnlyHeadElementsHandlers = sortHooks(
    pageHooks.map((hook) => hook?.emitServerOnlyHeadElements)
  );
  for (const handler of emitServerOnlyHeadElementsHandlers) {
    const head = handler();
    if (!head) continue;
    ctx.rakkas.head.push({
      elements: head.map((e) => ({ ...e, "data-sr": true }))
    });
  }
  const { specialAttributes, content: managedHead } = renderHeadContent(
    ctx.url.pathname + ctx.url.search,
    ctx.rakkas.head
  );
  let result = managedHead;
  const emitToDocumentHeadHandlers = sortHooks(
    // eslint-disable-next-line deprecation/deprecation
    pageHooks.map((hook) => hook?.emitToDocumentHead)
  );
  for (const handler of emitToDocumentHeadHandlers) {
    const head = handler();
    if (!head) continue;
    const headStr = typeof head === "string" ? head : renderToStaticMarkup(head);
    result += headStr;
  }
  result = `<!DOCTYPE html><html${stringifyAttributes(
    specialAttributes.htmlAttributes
  )}><head${stringifyAttributes(specialAttributes.headAttributes)}>` + result;
  result += prefetchOutput;
  if (import.meta.env.DEV) {
    result += `<script type="module" src="/@vite/client"></script><script type="module" async>${REACT_FAST_REFRESH_PREAMBLE}</script>`;
  }
  result += `</head><body${stringifyAttributes(
    specialAttributes.bodyAttributes
  )}>`;
  return result;
}
function stringifyAttributes(attributes) {
  let result = "";
  for (const [key, value] of Object.entries(attributes)) {
    if (["key", "textContent", "innerHTML", "children", "tagName"].includes(
      key
    ) || value === false || value === void 0) {
      continue;
    }
    if (value === true) {
      result += ` ${escapeHtml(key)}`;
      continue;
    }
    result += ` ${escapeHtml(key)}="${escapeHtml(String(value))}"`;
  }
  return result;
}

// src/features/async-local-request-context/server-hooks.ts
var asyncLocalRequestContextServerHooks = {
  middleware: {
    beforeAll: [(ctx) => requestContextStorage?.run(ctx, ctx.next)]
  }
};
var server_hooks_default2 = asyncLocalRequestContextServerHooks;

// src/features/use-query/server-hooks.tsx
import React5 from "react";
import { uneval as uneval2 } from "devalue";
var useQueryServerHooks = {
  createPageHooks() {
    const cache = {
      _items: /* @__PURE__ */ Object.create(null),
      _newItems: /* @__PURE__ */ Object.create(null),
      _hasNewItems: false,
      _errorItems: /* @__PURE__ */ Object.create(null),
      _getNewItems() {
        const items = this._newItems;
        this._newItems = /* @__PURE__ */ Object.create(null);
        this._hasNewItems = false;
        return items;
      },
      setTags() {
      },
      has(key) {
        return key in this._items;
      },
      get(key) {
        if (key in this._errorItems) {
          throw this._errorItems[key];
        }
        if (!this.has(key)) {
          return void 0;
        }
        const content = this._items[key];
        const result = content instanceof Promise ? { promise: content } : { value: content };
        return result;
      },
      set(key, valueOrPromise) {
        this._items[key] = valueOrPromise;
        if (valueOrPromise instanceof Promise) {
          valueOrPromise.then(
            (value) => {
              this._items[key] = this._newItems[key] = value;
              this._hasNewItems = true;
            },
            (error) => {
              delete this._items[key];
              this._errorItems[key] = error;
            }
          );
        } else {
          this._newItems[key] = valueOrPromise;
          this._hasNewItems = true;
        }
      },
      subscribe() {
        throw new Error("Cannot subscribe on the server");
      },
      invalidate() {
        throw new Error("Cannot invalidate on the server");
      },
      enumerate() {
        throw new Error("Cannot enumerate on the server");
      }
    };
    return {
      wrapApp: (app) => {
        return /* @__PURE__ */ React5.createElement(QueryCacheContext.Provider, { value: cache }, app);
      },
      extendPageContext(ctx) {
        ctx.queryClient = createQueryClient(cache, ctx);
      },
      emitToSyncHeadScript() {
        const newItemsString = uneval2(cache._getNewItems());
        return `rakkas.cache=${newItemsString};`;
      },
      emitBeforeSsrChunk() {
        if (cache._hasNewItems) {
          const newItemsString = uneval2(cache._getNewItems());
          return `<script>Object.assign(rakkas.cache,${newItemsString})</script>`;
        }
      }
    };
  }
};
var server_hooks_default3 = useQueryServerHooks;

// src/features/run-server-side/server-hooks.ts
var import_parse = __toESM(require_parse(), 1);
import { uneval as uneval3 } from "devalue";
var runServerSideServerHooks = {
  middleware: {
    beforePages: [
      async (ctx) => {
        const prefix = `/_app/data/`;
        let action = ctx.method !== "POST" ? void 0 : ctx.url.searchParams.get("_action");
        if (!ctx.url.pathname.startsWith(prefix) && !action) {
          return;
        }
        action = action || ctx.url.pathname.slice(prefix.length);
        const [buildId = "", ...rest] = action.split("/");
        let uniqueId;
        let moduleId;
        let counter;
        let closure;
        const manifest = await import("rakkasjs:run-server-side:manifest");
        if (buildId === "id") {
          [uniqueId, ...closure] = rest;
          const callSiteId = manifest.idMap[uniqueId] || "";
          [moduleId = "", counter = ""] = callSiteId.split("/");
        } else if (buildId !== import.meta.env.RAKKAS_BUILD_ID) {
          return new Response("Outdated client", { status: 404 });
        } else {
          [moduleId = "", counter = "", ...closure] = rest;
        }
        let closureContents;
        let vars;
        let isFormMutation = true;
        try {
          if (ctx.method === "POST" && typeIsBrilloutJsonSerializer(ctx)) {
            isFormMutation = false;
            const text = await ctx.request.text();
            const data = (0, import_parse.parse)(text);
            if (!Array.isArray(data)) {
              return new Response("Parse error", { status: 400 });
            }
            closureContents = data[0];
            if (!Array.isArray(closureContents)) {
              return new Response("Parse error", { status: 400 });
            }
            vars = data[1];
          } else {
            if (ctx.method === "GET") {
              closure.length = Math.max(0, closure.length - 1);
              isFormMutation = false;
            }
            closureContents = closure.map((s) => (0, import_parse.parse)(decodeFileNameSafe(s)));
          }
        } catch {
          return new Response("Parse error", { status: 400 });
        }
        const importer = manifest.moduleMap[decodeURIComponent(moduleId)];
        if (!importer) return;
        const module = await importer();
        if (!module.$runServerSide$) return;
        const fn = module.$runServerSide$[Number(counter)];
        const headers = new Headers();
        const ssCtx = Object.assign(ctx, { headers });
        const result = await fn(closureContents, ssCtx, vars);
        if (ctx.request.headers.get("accept") === EventStreamContentType && result instanceof ReadableStream) {
          const { readable, writable } = new TransformStream({
            transform(chunk, controller) {
              controller.enqueue(`data: ${uneval3(chunk)}

`);
            }
          });
          ctx.waitUntil(
            result.pipeTo(writable).catch(() => {
            })
          );
          headers.set("Content-Type", EventStreamContentType);
          headers.set("Cache-Control", "no-cache");
          headers.set("Connection", "keep-alive");
          return new Response(readable, {
            status: 200,
            headers
          });
        }
        if (isFormMutation) {
          for (const [key, value] of Object.entries(
            result.headers || {}
          )) {
            headers.set(key, value);
          }
          if (acceptsDevalue(ctx)) {
            headers.set("Content-Type", "text/javascript; devalue");
            if (result.redirect) {
              delete result.headers;
              return new Response(uneval3(result), { headers });
            }
            return new Response(uneval3({ data: result.data }), {
              status: result.status,
              headers
            });
          } else {
            if (result.redirect) {
              headers.set("location", new URL(result.redirect, ctx.url).href);
              return new Response(null, {
                status: 302,
                headers
              });
            }
            ctx.url.searchParams.delete("_action");
            composableActionData.set(ctx, [action, result]);
            return renderPageRoute(ctx);
          }
        }
        headers.set("Content-Type", "text/javascript; devalue");
        if (!headers.has("Cache-Control")) {
          headers.set("Cache-Control", "no-store");
        }
        return new Response(uneval3(result), { headers });
      }
    ]
  },
  createPageHooks(requestContext) {
    return {
      extendPageContext(pageContext) {
        pageContext.requestContext = requestContext;
      }
    };
  }
};
var server_hooks_default4 = runServerSideServerHooks;
function typeIsBrilloutJsonSerializer(ctx) {
  const type = ctx.request.headers.get("Content-Type");
  return type === "application/x.brillout-json-serializer+json" || // TODO: Remove this (kept for backward compatibility)
  type === "application/json";
}

// src/features/isomorphic-fetch/server-hooks.ts
import hattipHandler from "rakkasjs:hattip-entry";
var isomorphicFetchServerHooks = {
  middleware: {
    beforePages: [
      (ctx) => {
        ctx.fetch = async (input, init2) => {
          let url;
          if (typeof input === "string" || input instanceof URL) {
            url = new URL(input, ctx.url);
            input = url.href;
          }
          let newRequest;
          try {
            newRequest = new Request(input, init2);
          } catch {
            const newInit = { ...init2 };
            delete newInit?.credentials;
            newRequest = new Request(input, newInit);
          }
          url = url || new URL(newRequest.url, ctx.url);
          const sameOrigin = url.origin === ctx.url.origin;
          let requestCredentials;
          try {
            requestCredentials = init2?.credentials ?? newRequest.credentials;
          } catch {
          }
          const credentials = requestCredentials ?? "same-origin";
          const includeCredentials = credentials === "include" || credentials === "same-origin" && sameOrigin;
          if (includeCredentials) {
            const cookie = ctx.request.headers.get("cookie");
            if (cookie !== null) {
              newRequest.headers.set("cookie", cookie);
            }
            const authorization = ctx.request.headers.get("authorization");
            if (authorization !== null) {
              newRequest.headers.set("authorization", authorization);
            }
          } else {
            newRequest.headers.delete("cookie");
            newRequest.headers.delete("authorization");
          }
          let response;
          if (sameOrigin) {
            response = await hattipHandler({
              request: newRequest,
              ip: ctx.ip,
              waitUntil: ctx.waitUntil,
              passThrough: ctx.passThrough,
              platform: ctx.platform,
              env: ctx.env
            });
          }
          return response ?? fetch(newRequest);
        };
      }
    ]
  },
  createPageHooks(ctx) {
    return {
      extendPageContext(pageContext) {
        pageContext.fetch = ctx.fetch;
      }
    };
  }
};
var server_hooks_default5 = isomorphicFetchServerHooks;

// src/features/client-side-navigation/server-hooks.tsx
import React6 from "react";
var clientSideNavigationServerHooks = {
  createPageHooks(ctx) {
    return {
      wrapApp(app) {
        return /* @__PURE__ */ React6.createElement(LocationContext.Provider, { value: ctx.url.href }, app);
      }
    };
  }
};
var server_hooks_default6 = clientSideNavigationServerHooks;

// src/runtime/feature-server-hooks.tsx
var serverFeatureHooks = [
  server_hooks_default2,
  server_hooks_default,
  server_hooks_default3,
  server_hooks_default4,
  server_hooks_default5,
  server_hooks_default6
];
var feature_server_hooks_default = serverFeatureHooks;

// src/runtime/hattip-handler.ts
import pluginFactories2, {
  options as configOptions2
} from "rakkasjs:plugin-server-hooks";
import * as commonHooksModule2 from "rakkasjs:common-hooks";
function createRequestHandler(userHooks = {}, pluginOptions = {}) {
  const hooks = [
    ...pluginFactories2.map((factory, i) => {
      const { commonPluginOptions = {} } = commonHooksModule2;
      return factory(pluginOptions, commonPluginOptions, configOptions2[i]);
    }),
    ...feature_server_hooks_default,
    userHooks
  ];
  const beforeAll = sortHooks(
    hooks.map((hook) => hook.middleware?.beforeAll).flat()
  );
  const beforePages = sortHooks(
    hooks.map((hook) => hook.middleware?.beforePages).flat()
  );
  const beforeApiRoutes = sortHooks(
    hooks.map((hook) => hook.middleware?.beforeApiRoutes).flat()
  );
  const beforeNotFound = sortHooks(
    hooks.map((hook) => hook.middleware?.beforeNotFound).flat()
  );
  return compose(
    [
      // Disable compose's default error handling in development
      // so that we can forward errors to Vite for a nice error overlay
      import.meta.env.DEV && ((ctx) => {
        ctx.handleError = (error) => {
          throw error;
        };
      }),
      process.env.RAKKAS_PRERENDER === "true" && prerender,
      init(hooks),
      beforeAll,
      beforePages,
      async (ctx) => {
        try {
          return await renderPageRoute(ctx);
        } catch (error) {
          if (!process.env.RAKKAS_PRERENDER) {
            console.error(error);
          }
        }
      },
      beforeApiRoutes,
      renderApiRoute,
      beforeNotFound,
      notFound,
      async (ctx) => {
        try {
          return await renderPageRoute(ctx);
        } catch (error) {
          if (!process.env.RAKKAS_PRERENDER) {
            console.error(error);
          }
        }
      }
    ].flat()
  );
}
function init(hooks) {
  return (ctx) => {
    ctx.rakkas = {
      hooks,
      notFound: false,
      head: []
    };
  };
}
function notFound(ctx) {
  ctx.rakkas.notFound = true;
}
async function prerender(ctx) {
  if (ctx.method !== "GET") return;
  let caught;
  ctx.platform.reportError = (error) => {
    caught = error;
  };
  const response = await ctx.next();
  await ctx.platform.render(
    ctx.url.pathname,
    response.clone(),
    ctx.platform.prerenderOptions,
    caught
  );
  return response;
}
export {
  createRequestHandler
};

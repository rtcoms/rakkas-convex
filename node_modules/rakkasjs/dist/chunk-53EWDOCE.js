import {
  __commonJS,
  __toESM
} from "./chunk-JSBRDJBE.js";

// ../../node_modules/.pnpm/@brillout+json-serializer@0.5.13/node_modules/@brillout/json-serializer/dist/cjs/types.js
var require_types = __commonJS({
  "../../node_modules/.pnpm/@brillout+json-serializer@0.5.13/node_modules/@brillout/json-serializer/dist/cjs/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.types = void 0;
    var types = [
      ts({
        is: (val) => val === void 0,
        match: (str) => str === "!undefined",
        serialize: () => "!undefined",
        deserialize: () => void 0
      }),
      ts({
        is: (val) => val === Infinity,
        match: (str) => str === "!Infinity",
        serialize: () => "!Infinity",
        deserialize: () => Infinity
      }),
      ts({
        is: (val) => val === -Infinity,
        match: (str) => str === "!-Infinity",
        serialize: () => "!-Infinity",
        deserialize: () => -Infinity
      }),
      ts({
        is: (val) => typeof val === "number" && isNaN(val),
        match: (str) => str === "!NaN",
        serialize: () => "!NaN",
        deserialize: () => NaN
      }),
      ts({
        is: (val) => val instanceof Date,
        match: (str) => str.startsWith("!Date:"),
        serialize: (val) => "!Date:" + val.toISOString(),
        deserialize: (str) => new Date(str.slice("!Date:".length))
      }),
      ts({
        is: (val) => typeof val === "bigint",
        match: (str) => str.startsWith("!BigInt:"),
        serialize: (val) => "!BigInt:" + val.toString(),
        deserialize: (str) => {
          if (typeof BigInt === "undefined") {
            throw new Error("Your JavaScript environement does not support BigInt. Consider adding a polyfill.");
          }
          return BigInt(str.slice("!BigInt:".length));
        }
      }),
      ts({
        is: (val) => val instanceof RegExp,
        match: (str) => str.startsWith("!RegExp:"),
        serialize: (val) => "!RegExp:" + val.toString(),
        deserialize: (str) => {
          str = str.slice("!RegExp:".length);
          const args = str.match(/\/(.*)\/(.*)?/);
          const pattern = args[1];
          const flags = args[2];
          return new RegExp(pattern, flags);
        }
      }),
      ts({
        is: (val) => val instanceof Map,
        match: (str) => str.startsWith("!Map:"),
        serialize: (val, serializer) => "!Map:" + serializer(Array.from(val.entries())),
        deserialize: (str, deserializer) => new Map(deserializer(str.slice("!Map:".length)))
      }),
      ts({
        is: (val) => val instanceof Set,
        match: (str) => str.startsWith("!Set:"),
        serialize: (val, serializer) => "!Set:" + serializer(Array.from(val.values())),
        deserialize: (str, deserializer) => new Set(deserializer(str.slice("!Set:".length)))
      }),
      // Avoid collisions with the special strings defined above
      ts({
        is: (val) => typeof val === "string" && val.startsWith("!"),
        match: (str) => str.startsWith("!"),
        serialize: (val) => "!" + val,
        deserialize: (str) => str.slice(1)
      })
    ];
    exports.types = types;
    function ts(t) {
      return t;
    }
  }
});

// ../../node_modules/.pnpm/@brillout+json-serializer@0.5.13/node_modules/@brillout/json-serializer/dist/cjs/utils/isReactElement.js
var require_isReactElement = __commonJS({
  "../../node_modules/.pnpm/@brillout+json-serializer@0.5.13/node_modules/@brillout/json-serializer/dist/cjs/utils/isReactElement.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isReactElement = void 0;
    function isReactElement(value) {
      return typeof value === "object" && value !== null && String(value["$$typeof"]) === "Symbol(react.element)";
    }
    exports.isReactElement = isReactElement;
  }
});

// ../../node_modules/.pnpm/@brillout+json-serializer@0.5.13/node_modules/@brillout/json-serializer/dist/cjs/utils/isCallable.js
var require_isCallable = __commonJS({
  "../../node_modules/.pnpm/@brillout+json-serializer@0.5.13/node_modules/@brillout/json-serializer/dist/cjs/utils/isCallable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isCallable = void 0;
    function isCallable(thing) {
      return thing instanceof Function || typeof thing === "function";
    }
    exports.isCallable = isCallable;
  }
});

// ../../node_modules/.pnpm/@brillout+json-serializer@0.5.13/node_modules/@brillout/json-serializer/dist/cjs/utils/isObject.js
var require_isObject = __commonJS({
  "../../node_modules/.pnpm/@brillout+json-serializer@0.5.13/node_modules/@brillout/json-serializer/dist/cjs/utils/isObject.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isObject = void 0;
    function isObject(value) {
      if (typeof value !== "object" || value === null) {
        return false;
      }
      if (Array.isArray(value)) {
        return false;
      }
      return true;
    }
    exports.isObject = isObject;
  }
});

// ../../node_modules/.pnpm/@brillout+json-serializer@0.5.13/node_modules/@brillout/json-serializer/dist/cjs/utils/replacerWithPath.js
var require_replacerWithPath = __commonJS({
  "../../node_modules/.pnpm/@brillout+json-serializer@0.5.13/node_modules/@brillout/json-serializer/dist/cjs/utils/replacerWithPath.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.replacerWithPath = void 0;
    function replacerWithPath(replacer) {
      const pathMap = /* @__PURE__ */ new WeakMap();
      return function(key, value) {
        var _a;
        const pathPrevious = (_a = pathMap.get(this)) !== null && _a !== void 0 ? _a : [];
        const path = [...pathPrevious];
        if (key !== "") {
          const pathEntry = !Array.isArray(this) ? key : parseInt(key, 10);
          path.push(pathEntry);
        }
        if (isIterable(value))
          pathMap.set(value, path);
        return replacer.call(this, key, value, path);
      };
    }
    exports.replacerWithPath = replacerWithPath;
    function isIterable(value) {
      return value === Object(value);
    }
  }
});

// ../../node_modules/.pnpm/@brillout+json-serializer@0.5.13/node_modules/@brillout/json-serializer/dist/cjs/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/.pnpm/@brillout+json-serializer@0.5.13/node_modules/@brillout/json-serializer/dist/cjs/stringify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isJsonSerializerError = exports.stringify = void 0;
    var types_1 = require_types();
    var isReactElement_1 = require_isReactElement();
    var isCallable_1 = require_isCallable();
    var isObject_1 = require_isObject();
    var replacerWithPath_1 = require_replacerWithPath();
    function stringify3(value, {
      forbidReactElements,
      space,
      valueName,
      sortObjectKeys,
      // Used by Vike: https://github.com/vikejs/vike/blob/b4ba6b70e6bdc2e1f460c0d2e4c3faae5d0a733c/vike/node/plugin/plugins/importUserCode/v1-design/getConfigValuesSerialized.ts#L78
      replacer: replacerUserProvided
    } = {}) {
      const serializer = (val) => JSON.stringify(val, (0, replacerWithPath_1.replacerWithPath)(replacer), space);
      return serializer(value);
      function replacer(key, value2, path) {
        {
          const ret = replacerUserProvided === null || replacerUserProvided === void 0 ? void 0 : replacerUserProvided.call(this, key, value2);
          if (ret)
            return ret.replacement;
        }
        if (forbidReactElements && (0, isReactElement_1.isReactElement)(value2)) {
          throw genErr({
            value: value2,
            valueType: "React element",
            path,
            rootValueName: valueName
          });
        }
        if ((0, isCallable_1.isCallable)(value2)) {
          const functionName = value2.name;
          throw genErr({
            value: value2,
            valueType: "function",
            path,
            rootValueName: valueName,
            problematicValueName: path.length === 0 ? functionName : void 0
          });
        }
        const valueOriginal = this[key];
        for (const { is, serialize } of types_1.types.slice().reverse()) {
          if (is(valueOriginal)) {
            return serialize(valueOriginal, serializer);
          }
        }
        if (sortObjectKeys && (0, isObject_1.isObject)(value2)) {
          const copy = {};
          Object.keys(value2).sort().forEach((key2) => {
            copy[key2] = value2[key2];
          });
          value2 = copy;
        }
        return value2;
      }
    }
    exports.stringify = stringify3;
    function genErr({ value, valueType, path, rootValueName, problematicValueName }) {
      const subjectName = getSubjectName({ path, rootValueName, problematicValueName });
      const messageCore = `cannot serialize ${subjectName} because it's a ${valueType}`;
      const err = new Error(`[@brillout/json-serializer](https://github.com/brillout/json-serializer) ${messageCore}.`);
      const pathString = getPathString(path, true);
      const errAddendum = {
        [stamp]: true,
        messageCore,
        value,
        path,
        pathString,
        subjectName
      };
      Object.assign(err, errAddendum);
      return err;
    }
    var stamp = "_isJsonSerializerError";
    function isJsonSerializerError(thing) {
      return (0, isObject_1.isObject)(thing) && thing[stamp] === true;
    }
    exports.isJsonSerializerError = isJsonSerializerError;
    function getSubjectName({ path, rootValueName, problematicValueName }) {
      const pathString = getPathString(path, !rootValueName);
      let subjectName;
      if (!pathString) {
        subjectName = rootValueName || problematicValueName || "value";
      } else {
        if (problematicValueName) {
          subjectName = problematicValueName + " at ";
        } else {
          subjectName = "";
        }
        subjectName = subjectName + (rootValueName || "") + pathString;
      }
      return subjectName;
    }
    function getPathString(path, canBeFirstKey) {
      const pathString = path.map((key, i) => {
        if (typeof key === "number") {
          return `[${key}]`;
        }
        if (i === 0 && canBeFirstKey && isKeyDotNotationCompatible(key)) {
          return key;
        }
        return getPropAccessNotation(key);
      }).join("");
      return pathString;
    }
    function getPropAccessNotation(key) {
      return typeof key === "string" && isKeyDotNotationCompatible(key) ? `.${key}` : `[${JSON.stringify(key)}]`;
    }
    function isKeyDotNotationCompatible(key) {
      return /^[a-z0-9\$_]+$/i.test(key);
    }
  }
});

// src/features/head/implementation/Head.tsx
import { useContext, useEffect, useRef } from "react";

// src/runtime/named-context.ts
import { createContext } from "react";
function createNamedContext(name, defaultValue) {
  if (process.env.NODE_ENV === "production") {
    return createContext(defaultValue);
  }
  name = `__rakkasjs_context_${name}__`;
  const existing = globalThis[name];
  if (existing) {
    return existing;
  }
  const context = createContext(defaultValue);
  globalThis[name] = context;
  return context;
}

// src/features/head/implementation/context.ts
var HeadContext = createNamedContext(
  "ServerHeadContext",
  { stack: [] }
);

// src/features/head/implementation/merge.ts
function mergeHeadProps(target, props) {
  const { keyed, unkeyed } = target;
  for (const [key, def] of Object.entries(autoKeys)) {
    if (props[key] === void 0) {
      continue;
    }
    if (def === "og") {
      keyed[key] = {
        property: key,
        content: props[key]
      };
      continue;
    }
    if (def === "twitter") {
      keyed[key] = {
        name: key,
        content: props[key]
      };
      continue;
    }
    const [attributes, target2] = def;
    if (target2) {
      keyed[key] = {
        ...attributes,
        [target2]: props[key]
      };
    } else {
      if (["html", "head", "body"].includes(attributes.tagName)) {
        if (keyed[key]) {
          assign(keyed[key], props[key]);
          continue;
        }
      }
      keyed[key] = {
        ...attributes,
        ...props[key]
      };
    }
  }
  for (const element of props.elements ?? []) {
    const key = getKey(element);
    if (!key) {
      unkeyed.push(element);
      continue;
    }
    if (["html", "head", "body"].includes(key)) {
      assign(keyed[key], element);
      continue;
    }
    if (keyed[key]) {
      if (element.tagName === "remove") {
        delete keyed[key];
        continue;
      }
      assign(keyed[key], element);
    } else {
      if (element.tagName === "remove") {
        continue;
      }
      keyed[key] = element;
    }
  }
}
function getKey(attributes) {
  const tagName = attributes.tagName ?? "meta";
  if (attributes.key) {
    return attributes.key;
  } else if (tagName === "title") {
    return "title";
  } else if (tagName === "meta" && attributes.charset) {
    return "charset";
  } else if (tagName === "meta") {
    if ([
      "name",
      "description",
      "viewport",
      "twitter:card",
      "twitter:title",
      "twitter:description",
      "twitter:image"
    ].includes(attributes.name)) {
      return attributes.name;
    }
    if (["og:title", "og:description", "og:image", "og:url", "og:type"].includes(
      attributes.property
    )) {
      return attributes.property;
    }
  } else if (tagName === "link" && attributes.rel === "canonical") {
    return "canonical";
  } else if (tagName === "html") {
    return "html";
  } else if (tagName === "head") {
    return "head";
  } else if (tagName === "body") {
    return "body";
  }
}
function assign(target, source) {
  for (const key in source) {
    if (source[key] === void 0) {
      continue;
    }
    target[key] = source[key];
  }
}
var autoKeys = {
  title: [{ tagName: "title" }, "textContent"],
  viewport: [{ tagName: "meta", name: "viewport" }, "content"],
  description: [{ tagName: "meta", name: "description" }, "content"],
  canonical: [{ tagName: "link", rel: "canonical" }, "href"],
  "og:title": "og",
  "og:description": "og",
  "og:image": "og",
  "og:url": "og",
  "og:type": "og",
  "twitter:card": "twitter",
  "twitter:title": "twitter",
  "twitter:description": "twitter",
  "twitter:image": "twitter",
  htmlAttributes: [{ tagName: "html" }],
  headAttributes: [{ tagName: "head" }],
  bodyAttributes: [{ tagName: "body" }]
};

// src/features/head/implementation/defaults.ts
var defaultHeadProps = {
  title: import.meta.env.RAKKAS_DEFAULT_APP_TITLE || "Rakkas App",
  viewport: "width=device-width, initial-scale=1",
  htmlAttributes: { lang: "en" },
  elements: [{ charset: "utf-8" }]
};

// src/features/head/implementation/sort.ts
function sortHeadTags(tags) {
  const merged = [...Object.values(tags.keyed), ...tags.unkeyed];
  function rank(tag) {
    switch (tag.tagName) {
      case "meta":
      case void 0:
        if (tag.charset) return 0;
        if (metaEquiv.has(tag["http-equiv"])) return 1;
        if (tag.name === "viewport") return 2;
        return 16;
      case "base":
        return 3;
      case "title":
        return 4;
      case "link":
        if (tag.rel === "preconnect") return 5;
        if (tag.rel === "stylesheet") return 11;
        if (tag.rel === "preload") return 12;
        if (tag.rel === "prefetch" || tag.rel === "prerender") return 15;
        return 16;
      case "script":
        if (tag.async && !tag.type) return 6;
        if (tag.type === "importmap") {
          if (merged.some((t) => t.async && t.type === "module")) return 7;
          return 13;
        }
        if (tag.async && tag.type === "module") return 8;
        if (!tag.type) return tag.defer ? 14 : 10;
        if (tag.type === "module") return 14;
        return 16;
      case "style":
        if (tag.textContent?.includes("@import"))
          return 9;
        return 11;
      case "noscript":
        return Math.min(
          ...tag.children.map(rank),
          16
        );
      default:
        return 16;
    }
  }
  return merged.sort((a, b) => rank(a) - rank(b));
}
var metaEquiv = /* @__PURE__ */ new Set([
  "accept-ch",
  "content-security-policy",
  "content-type",
  "default-style",
  "delegate-ch",
  "origin-trial",
  "x-dns-prefetch-control"
]);

// src/features/head/implementation/Head.tsx
function useHead(props) {
  const { stack: ssrStack } = useContext(HeadContext);
  const ref = useRef(void 0);
  if (import.meta.env.SSR) {
    ssrStack.push({ ...props });
  } else if (!ref.current) {
    ref.current = { ...props, order: rakkas.headOrder++ };
  }
  useEffect(() => {
    const { current } = ref;
    return () => {
      const index = rakkas.headTagStack.indexOf(current);
      if (index !== -1) {
        rakkas.headTagStack.splice(index, 1);
      }
    };
  }, []);
  useEffect(() => {
    const { current } = ref;
    for (const key of Object.keys(current)) {
      if (key === "order") continue;
      delete current[key];
    }
    Object.assign(current, props);
    if (!rakkas.headTagStack.includes(current)) {
      rakkas.headTagStack.push(current);
    }
    scheduleUpdate();
    return () => {
      for (const key of Object.keys(props)) {
        if (key === "order") continue;
        delete current[key];
      }
      scheduleUpdate();
    };
  });
}
function Head(props) {
  useHead(props);
  return null;
}
var scheduled = false;
function scheduleUpdate() {
  if (scheduled) return;
  scheduled = true;
  requestAnimationFrame(updateHead);
}
function updateHead() {
  scheduled = false;
  const tags = {
    keyed: {
      base: {
        tagName: "base",
        href: document.head.querySelector("base")?.href
      }
    },
    unkeyed: []
  };
  mergeHeadProps(tags, defaultHeadProps);
  rakkas.headTagStack.sort((a, b) => a.order - b.order);
  for (const props of rakkas.headTagStack) {
    mergeHeadProps(tags, props);
  }
  let newElements = sortHeadTags(tags);
  for (const element of newElements) {
    const { tagName, ...attributes } = element;
    if (tagName === "head") {
      setAttributes(document.head, attributes, true);
      continue;
    }
    if (tagName === "body") {
      setAttributes(document.body, attributes, true);
      continue;
    }
    if (tagName === "html") {
      setAttributes(document.documentElement, attributes, true);
      continue;
    }
  }
  newElements = newElements.filter(
    (elt) => !["head", "body", "html"].includes(elt.tagName)
  );
  const currentElements = [];
  let endNode = null;
  for (const node of document.head.childNodes) {
    if (node.nodeType === Node.COMMENT_NODE && node.nodeValue === " head end ") {
      endNode = node;
      break;
    }
    if (node.nodeType === Node.ELEMENT_NODE && !node.hasAttribute?.("data-sr")) {
      currentElements.push(node);
    }
  }
  let iNew = 0;
  let iCur = 0;
  while (iNew < newElements.length || iCur < currentElements.length) {
    const newElement = newElements[iNew];
    let currentElement = currentElements[iCur];
    if (!newElement) {
      do {
        currentElement?.remove();
        currentElement = currentElements[++iCur];
      } while (currentElement);
      break;
    }
    if (!currentElement) {
      do {
        const { tagName: tagName2 = "meta", ...attributes2 } = newElement;
        iNew++;
        const el = document.createElement(tagName2);
        setAttributes(el, attributes2);
        document.head.insertBefore(el, endNode);
      } while (newElements[iNew]);
      break;
    }
    const { tagName = "meta", ...attributes } = newElement;
    if (tagName === currentElement.tagName.toLowerCase()) {
      setAttributes(currentElement, attributes, true);
      iNew++;
      iCur++;
      continue;
    }
    if (newElements.length - iNew > currentElements.length - iCur) {
      const el = document.createElement(tagName);
      setAttributes(el, attributes);
      document.head.insertBefore(el, currentElement);
      iNew++;
    } else {
      currentElement.remove();
      iCur++;
    }
  }
}
function setAttributes(el, attributes, remove = false) {
  for (const [attr, value] of Object.entries(attributes)) {
    if (attr === "key") {
      continue;
    }
    if (attr === "textContent") {
      el.textContent = value;
      continue;
    }
    if (attr === "innerHTML") {
      el.innerHTML = value;
      continue;
    }
    if (attr === "children") {
      continue;
    }
    if (value === false || value === void 0) {
      if (remove) {
        el.removeAttribute(attr);
      }
      continue;
    }
    if (value === true) {
      el.setAttribute(attr, attr);
      continue;
    }
    el.setAttribute(attr, String(value));
  }
  if (remove) {
    for (const attr of el.attributes) {
      if (!(attr.name in attributes)) {
        el.removeAttribute(attr.name);
      }
    }
  }
}

// src/features/use-query/implementation.ts
import {
  useCallback as useCallback3,
  useContext as useContext7,
  useEffect as useEffect5,
  useMemo as useMemo3,
  useRef as useRef6,
  useState as useState5
} from "react";

// src/features/use-mutation/lib.ts
import { useCallback, useMemo, useRef as useRef2, useState } from "react";
function useMutation(mutationFn, options = {}) {
  const [status, setStatus] = useState("idle");
  const [data, setData] = useState(void 0);
  const [error, setError] = useState(void 0);
  const resetRef = useRef2(false);
  const {
    onMutate,
    onError,
    onSettled,
    onSuccess,
    invalidateKeys: unstableInvalidateKeys = [],
    invalidateTags: unstableInvalidateTags = []
  } = options;
  const queryClient = useQueryClient();
  const invalidateKeys = useMemo(
    () => unstableInvalidateKeys,
    // eslint-disable-next-line react-hooks/exhaustive-deps
    unstableInvalidateKeys
  );
  const invalidateTags = useMemo(
    () => unstableInvalidateTags,
    // eslint-disable-next-line react-hooks/exhaustive-deps
    unstableInvalidateTags
  );
  const doMutate = useCallback(
    async function doMutate2(vars) {
      setStatus("loading");
      await onMutate?.(vars);
      try {
        const result = await mutationFn(vars);
        if (!resetRef.current) {
          onSuccess?.(result);
          setData(result);
          setStatus("success");
        }
        return result;
      } catch (err) {
        if (!resetRef.current) {
          onError?.(err);
          setError(err);
          setStatus("error");
        }
        throw err;
      } finally {
        if (!resetRef.current) {
          onSettled?.(data, error);
        }
        queryClient.invalidateQueries(invalidateKeys);
        queryClient.invalidateTags(invalidateTags);
      }
    },
    [
      data,
      error,
      mutationFn,
      onError,
      onMutate,
      onSettled,
      onSuccess,
      invalidateKeys,
      invalidateTags,
      queryClient
    ]
  );
  const mutateAsync = useCallback(
    function mutateAsync2(vars) {
      resetRef.current = false;
      return doMutate(vars);
    },
    [doMutate]
  );
  const reset = useCallback(function reset2() {
    setStatus("idle");
    setData(void 0);
    setError(void 0);
    resetRef.current = true;
  }, []);
  const mutate = useCallback(
    function mutate2(vars) {
      mutateAsync(vars).catch(() => {
      });
    },
    [mutateAsync]
  );
  return {
    status,
    data,
    error,
    isError: status === "error",
    isIdle: status === "idle",
    isLoading: status === "loading",
    isSuccess: status === "success",
    reset,
    mutateAsync,
    mutate
  };
}
function useMutations(mutationFn, options = {}) {
  const [pending, setPending] = useState([]);
  const idRef = useRef2(0);
  const queryClient = useQueryClient();
  async function mutate(vars) {
    const id = idRef.current++;
    setPending((pending2) => [...pending2, { id, vars }]);
    await options.onMutate?.(id, vars);
    let data;
    let error;
    try {
      data = await mutationFn(vars);
      options.onSuccess?.(id, data);
      return data;
    } catch (err) {
      error = err;
      options.onError?.(id, err);
    } finally {
      try {
        options.onSettled?.(id, data, error);
        if (options.invalidateTags) {
          const tags = typeof options.invalidateTags === "function" ? options.invalidateTags(id, data, error) : options.invalidateTags;
          queryClient.invalidateTags(tags);
        }
      } finally {
        setPending((pending2) => pending2.filter((p) => p.id !== id));
      }
    }
    throw error;
  }
  return {
    mutate(vars) {
      mutate(vars).catch(() => {
      });
    },
    mutateAsync: mutate,
    pending
  };
}

// src/features/client-side-navigation/implementation/link.tsx
import React, {
  forwardRef,
  useCallback as useCallback2,
  useEffect as useEffect3,
  useState as useState3,
  useRef as useRef4
} from "react";

// src/features/client-side-navigation/implementation/history.ts
import { startTransition, useContext as useContext2, useSyncExternalStore } from "react";

// src/features/client-side-navigation/implementation/blocker.ts
import { useEffect as useEffect2, useRef as useRef3, useState as useState2 } from "react";
function findBlocker() {
  for (const blocker of blockers) {
    if (blocker.enabled) {
      return blocker;
    }
  }
}
function handleBeforeUnload(e) {
  if (findBlocker()) {
    e.preventDefault();
    e.returnValue = "";
  }
}
var blockers = /* @__PURE__ */ new Set();
function useNavigationBlocker(condition) {
  const [isBlocking, setIsBlocking] = useState2(false);
  const blocker = useRef3({
    notify() {
      setIsBlocking(true);
    },
    enabled: true
  });
  useEffect2(() => {
    if (!condition && !isBlocking) {
      return;
    }
    const current = blocker.current;
    blockers.add(current);
    if (blockers.size === 1) {
      addEventListener("beforeunload", handleBeforeUnload);
    }
    return () => {
      blockers.delete(current);
      if (blockers.size === 0) {
        removeEventListener("beforeunload", handleBeforeUnload);
      }
    };
  }, [condition, isBlocking]);
  if (isBlocking) {
    return {
      isBlocking,
      leave() {
        const current = blocker.current;
        current.enabled = false;
        current.redo?.();
        setIsBlocking(false);
      },
      stay() {
        setIsBlocking(false);
      }
    };
  }
  return { isBlocking: false };
}

// src/features/pages/contexts.ts
import { createContext as createContext2 } from "react";
var RouteParamsContext = createContext2({});
var RenderedUrlContext = createContext2(void 0);

// src/features/client-side-navigation/implementation/history.ts
var lastRenderedId;
var lastRenderedHref;
var navigationPromise;
var navigationResolve;
async function navigate(to, options) {
  const blocker = findBlocker();
  if (blocker) {
    blocker.redo = () => navigate(to, options);
    blocker.notify();
    return false;
  }
  const url = new URL(to, location.href);
  if (url.origin !== location.origin) {
    location.href = url.href;
    return new Promise(() => {
    });
  }
  const { replace = false, data, actionData, scroll = true } = options || {};
  const historyEntry = getHistoryEntry();
  const navEntry = getNavigationEntry(historyEntry.id);
  let scrollGroupId;
  if (!scroll) {
    scrollGroupId = navEntry.scrollGroupId ??= createUniqueId();
  }
  saveScrollPosition(historyEntry.id);
  const newId = createUniqueId();
  setNavigationEntry(newId, {
    index: navEntry.index + (replace ? 0 : 1),
    scrollGroupId
  });
  setHistoryEntry({ id: newId, userData: data, actionData }, url.href, replace);
  return finishNavigation(newId);
}
function finishNavigation(targetId) {
  const { promise, resolve } = Promise.withResolvers();
  navigationPromise = promise.then(() => {
    rakkas.emitNavigationEvent?.(new URL(location.href));
  });
  navigationResolve = resolve;
  startTransition(() => {
    rakkas.setNextId?.(targetId);
  });
  listeners.forEach((listener) => listener());
  return navigationPromise.then(() => {
    const complete = getHistoryEntry().id === targetId;
    if (complete) {
      lastRenderedId = getHistoryEntry().id;
      lastRenderedHref = location.href;
      base().href = location.href;
      listeners.forEach((listener) => listener());
    }
    return complete;
  });
}
function base() {
  const result = document.head.querySelector("base");
  if (result) return result;
  return document.head.insertBefore(
    document.createElement("base"),
    document.head.firstChild
  );
}
function createUniqueId() {
  try {
    return crypto.randomUUID();
  } catch {
    return Math.random().toString(36).slice(2);
  }
}
function getHistoryEntry() {
  const entry = history.state;
  if (entry && typeof entry.id === "string") {
    return entry;
  }
  const lastNavEntry = getNavigationEntry(lastRenderedId);
  const newId = createUniqueId();
  setNavigationEntry(newId, {
    index: lastNavEntry.index + 1
  });
  const newEntry = { id: newId };
  setHistoryEntry(newEntry, location.href, true);
  return newEntry;
}
function setHistoryEntry(entry, href, replace) {
  if (replace) {
    history.replaceState(entry, "", href);
  } else {
    history.pushState(entry, "", href);
  }
}
var memoryEntries = /* @__PURE__ */ new Map();
function setNavigationEntry(id, entry) {
  memoryEntries.set(id, entry);
  try {
    sessionStorage.setItem(`rakkas:nav:${id}`, JSON.stringify(entry));
  } catch {
  }
}
function getNavigationEntry(id) {
  const entry = memoryEntries.get(id);
  if (entry) {
    return entry;
  }
  try {
    const data = sessionStorage.getItem(`rakkas:nav:${id}`);
    if (!data) {
      return;
    }
    const parsed = JSON.parse(data);
    validatedNavigationEntry(parsed);
    memoryEntries.set(id, parsed);
    return parsed;
  } catch {
  }
}
function validatedNavigationEntry(entry) {
  if (!entry || typeof entry !== "object" || typeof entry.index !== "number" || !isUndefinedOrOfType(entry.scrollX, "number") || !isUndefinedOrOfType(entry.scrollY, "number") || !isUndefinedOrOfType(entry.scrollGroupId, "string")) {
    throw new Error("Invalid navigation entry");
  }
}
function isUndefinedOrOfType(value, type) {
  return value === void 0 || typeof value === type;
}
function restoreScrollPosition() {
  const entry = getNavigationEntry(getHistoryEntry().id);
  if (lastSavedGroupId && entry.scrollGroupId && lastSavedGroupId === entry.scrollGroupId) {
    return;
  }
  const { scrollX: scrollX2, scrollY: scrollY2 } = entry;
  if (scrollX2 === void 0 || scrollY2 === void 0) {
    if (location.hash) {
      const hashElement = document.querySelector(location.hash);
      if (hashElement) {
        hashElement.scrollIntoView();
      } else {
        scrollTo(0, 0);
      }
    } else {
      scrollTo(0, 0);
    }
  } else {
    scrollTo(scrollX2, scrollY2);
  }
  for (const el of document.querySelectorAll("[data-rakkas-scroll-id]")) {
    const id = el.getAttribute("data-rakkas-scroll-id");
    const pos = entry.elements?.get(id);
    if (pos) {
      el.scrollTo(pos.x, pos.y);
    } else {
      el.scrollTo(0, 0);
    }
  }
}
var lastSavedGroupId;
function saveScrollPosition(id) {
  const entry = getNavigationEntry(id);
  lastSavedGroupId = entry.scrollGroupId;
  const elements = /* @__PURE__ */ new Map();
  for (const el of document.querySelectorAll("[data-rakkas-scroll-id]")) {
    const id2 = el.getAttribute("data-rakkas-scroll-id");
    elements.set(id2, { x: el.scrollLeft, y: el.scrollTop });
  }
  setNavigationEntry(id, {
    ...entry,
    scrollX,
    scrollY,
    elements
  });
}
var listeners = /* @__PURE__ */ new Set([() => {
}]);
function useLocation() {
  const ssrLocation = useContext2(LocationContext);
  const state = useSyncExternalStore(
    (onChange) => {
      listeners.add(onChange);
      return () => {
        listeners.delete(onChange);
      };
    },
    () => {
      if (!lastRenderedHref) {
        lastRenderedHref = location.href;
      }
      const snapshot = JSON.stringify({
        current: lastRenderedHref,
        pending: location.href === lastRenderedHref ? void 0 : location.href
      });
      return snapshot;
    },
    () => {
      const ssrSnapshot = JSON.stringify({
        current: ssrLocation
      });
      return ssrSnapshot;
    }
  );
  const parsed = JSON.parse(state);
  const rendered = useContext2(RenderedUrlContext);
  return {
    current: new URL(parsed.current),
    rendered,
    pending: parsed.pending ? new URL(parsed.pending) : void 0
  };
}
function cancelLastNavigation() {
  const last = getNavigationEntry(lastRenderedId).index;
  const next = getNavigationEntry(getHistoryEntry().id).index;
  const delta = last - next;
  history.go(delta);
  return -delta;
}
if (!import.meta.env.SSR) {
  rakkas.navigate = navigate;
}

// src/features/client-side-navigation/implementation/link.tsx
var LocationContext = createNamedContext(
  "LocationContext",
  void 0
);
var prefetchRanks = {
  never: 0,
  tap: 1,
  hover: 2,
  idle: 3,
  viewport: 4,
  eager: 5
};
var Link = forwardRef(
  ({
    onClick,
    historyState,
    noScroll,
    replaceState,
    onNavigationStart,
    onNavigationEnd,
    onMouseEnter,
    onTouchStart,
    onMouseDown,
    prefetch = "hover",
    preload = "never",
    ...props
  }, ref) => {
    const { ref: a, inView } = useInView();
    if (typeof requestIdleCallback === "undefined") {
      if (prefetch === "idle") {
        prefetch = "hover";
      }
      if (preload === "idle") {
        preload = "hover";
      }
    }
    const prefetchRank = prefetchRanks[prefetch] ?? 0;
    const preloadRank = prefetchRanks[preload === true ? prefetch : preload] ?? 0;
    const rank = Math.max(prefetchRank, preloadRank);
    const shouldAct = useCallback2(
      function shouldPrefetch(action) {
        return prefetchRank === prefetchRanks[action] || preloadRank === prefetchRanks[action];
      },
      [prefetchRank, preloadRank]
    );
    const shouldPreload = useCallback2(
      function shouldPreload2(action) {
        return preloadRank === prefetchRanks[action];
      },
      [preloadRank]
    );
    useEffect3(() => {
      if (props.href === void 0) {
        return;
      } else if (shouldAct("eager")) {
        prefetchRoute(props.href, shouldPreload("eager"));
      } else if (inView && shouldAct("viewport")) {
        prefetchRoute(props.href, shouldPreload("viewport"));
      } else if (inView && shouldAct("idle")) {
        requestIdleCallback(
          () => prefetchRoute(props.href, shouldPreload("idle"))
        );
      }
    }, [inView, preloadRank, props.href, rank, shouldAct, shouldPreload]);
    return /* @__PURE__ */ React.createElement(
      "a",
      {
        ...props,
        ref: (el) => {
          a.current = el;
          if (typeof ref === "function") {
            ref(el);
          } else if (ref) {
            ref.current = el;
          }
        },
        onClick: (e) => {
          onClick?.(e);
          if (!shouldHandleClick(e)) {
            return;
          }
          onNavigationStart?.();
          e.preventDefault();
          navigate(e.currentTarget.href, {
            data: historyState,
            replace: replaceState,
            scroll: !noScroll
          }).then((completed) => {
            onNavigationEnd?.(completed);
          }).catch(() => {
            onNavigationEnd?.(false);
          });
        },
        onMouseEnter: shouldAct("hover") ? (e) => {
          onMouseEnter?.(e);
          if (!e.defaultPrevented) {
            prefetchRoute(props.href, shouldPreload("hover"));
          }
        } : onMouseEnter,
        onMouseDown: shouldAct("tap") ? (e) => {
          onMouseDown?.(e);
          if (!e.defaultPrevented) {
            prefetchRoute(props.href, shouldPreload("tap"));
          }
        } : onMouseDown,
        onTouchStart: shouldAct("tap") || shouldAct("hover") ? (e) => {
          onTouchStart?.(e);
          if (!e.defaultPrevented) {
            prefetchRoute(
              props.href,
              shouldPreload("tap") || shouldPreload("hover")
            );
          }
        } : onTouchStart
      }
    );
  }
);
Link.displayName = "Link";
var StyledLink = forwardRef(
  ({
    activeClass,
    pendingClass,
    pendingStyle,
    activeStyle,
    onCompareUrls = defaultCompareUrls,
    onNavigationStart,
    className,
    style,
    ...props
  }, ref) => {
    const [navigating, setNavigating] = useState3(false);
    const { current, pending } = useLocation();
    const hasPending = !!pending;
    useEffect3(() => {
      if (!hasPending) {
        setNavigating(false);
      }
    }, [hasPending]);
    const classNames = className ? [className] : [];
    if (props.href !== void 0 && (activeClass || pendingClass || activeStyle || pendingStyle)) {
      const url = new URL(props.href, current);
      if (navigating) {
        if (pendingClass) classNames.push(pendingClass);
        if (pendingStyle) style = { ...style, ...pendingStyle };
      }
      if (current && onCompareUrls(new URL(current), url)) {
        if (activeClass) classNames.push(activeClass);
        if (activeStyle) style = { ...style, ...activeStyle };
      }
    }
    return /* @__PURE__ */ React.createElement(
      Link,
      {
        ...props,
        ref,
        className: classNames.join(" ") || void 0,
        style,
        onNavigationStart: () => {
          setNavigating(true);
          onNavigationStart?.();
        }
      }
    );
  }
);
StyledLink.displayName = "StyledLink";
function defaultCompareUrls(a, b) {
  return a.href === b.href;
}
function shouldHandleClick(e) {
  const t = e.currentTarget;
  return (t instanceof HTMLAnchorElement || t instanceof SVGAElement || t instanceof HTMLAreaElement) && !e.defaultPrevented && t.href !== void 0 && e.button === 0 && !e.shiftKey && !e.altKey && !e.ctrlKey && !e.metaKey && (!t.target || t.target === "_self") && !t.hasAttribute("download") && !t.relList.contains("external");
}
function useSubmit(options) {
  const { current } = useLocation();
  const pageContext = usePageContext();
  const mutation = useMutation(
    async ({ form, formData }) => {
      let body = formData;
      if (form.enctype === "application/x-www-form-urlencoded") {
        const entries = Array.from(formData.entries()).filter(
          ([, v]) => typeof v === "string"
        );
        body = new URLSearchParams(entries);
      }
      const response = await fetch(new URL(form.action ?? "", current), {
        method: "POST",
        body,
        headers: {
          "Content-Type": form.enctype || "application/x-www-form-urlencoded",
          Accept: "text/javascript; devalue"
        }
      });
      const text = await response.text();
      const value = (0, eval)("(" + text + ")");
      return value;
    },
    {
      ...options,
      onSuccess(value) {
        options?.onSuccess?.(value.data);
        if ("redirect" in value) {
          navigate(value.redirect, {
            ...options
          }).catch(ignore);
        } else {
          navigate(current, {
            replace: true,
            ...options,
            actionData: value.data
          }).catch(ignore);
        }
      }
    }
  );
  function submitHandler(e) {
    e.preventDefault();
    mutation.mutate({
      form: e.currentTarget,
      formData: new FormData(e.currentTarget)
    });
  }
  mutation.data = mutation.data?.data ?? pageContext.actionData;
  const { data, error, isError, isIdle, isLoading, isSuccess, status } = mutation;
  return {
    submitHandler,
    data,
    error,
    isError,
    isIdle,
    isLoading,
    isSuccess,
    status
  };
}
function ignore() {
}
var prefetcher = {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  prefetch(location2, preload) {
  }
};
function prefetchRoute(location2, preload = false) {
  if (location2 === void 0) return;
  prefetcher.prefetch(location2, preload);
}
function useInView() {
  const ref = useRef4();
  const [inView, setInView] = useState3(false);
  const observerRef = useRef4();
  useEffect3(() => {
    const { current } = ref;
    if (!current) {
      return;
    }
    if (!observerRef.current) {
      observerRef.current = new IntersectionObserver((entries) => {
        entries.forEach((entry) => setInView(entry.isIntersecting));
      });
    }
    const observer = observerRef.current;
    observer.observe(current);
    return () => observer.unobserve(current);
  });
  return { ref, inView };
}
Promise.withResolvers ??= function withResolvers() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
};

// src/features/client-only/implementation.tsx
import React2, { Suspense, useSyncExternalStore as useSyncExternalStore2 } from "react";
function ClientOnly(props) {
  const isHydrated = useSyncExternalStore2(
    () => () => {
    },
    () => true,
    () => false
  );
  return /* @__PURE__ */ React2.createElement(Suspense, { fallback: props.fallback }, isHydrated ? props.children : props.fallback);
}
var ClientSuspense = ClientOnly;

// src/features/response-manipulation/implementation.tsx
import React3, {
  useContext as useContext3,
  useLayoutEffect,
  useRef as useRef5
} from "react";

// src/runtime/utils.ts
function escapeJson(json) {
  return json.replace(/</g, "\\u003c");
}
function encodeFileNameSafe(s) {
  return Array.from(new TextEncoder().encode(s)).map(
    (x) => (x < 48 || x > 57) && (x < 97 || x > 122) ? "_" + x.toString(16).toUpperCase().padStart(2, "0") : String.fromCharCode(x)
  ).join("");
}
function decodeFileNameSafe(s) {
  return decodeURIComponent(s.replace(/_/g, "%"));
}
function escapeHtml(text) {
  return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function escapeCss(text) {
  return text.replace(/</g, "\\<");
}
function sortHooks(hooks) {
  const filtered = hooks.filter(Boolean);
  return filtered.sort((a, b) => orderRank(a) - orderRank(b)).map((x) => typeof x === "object" ? x.handler : x);
}
function orderRank(x) {
  const order = typeof x === "object" ? x.order : void 0;
  return order === "pre" ? -1 : order === "post" ? 1 : 0;
}

// src/features/response-manipulation/implementation.tsx
var Redirect = import.meta.env.SSR ? function Redirect2(props) {
  const redirect = useContext3(ResponseContext);
  redirect({
    redirect: true,
    status: props.status || (props.permanent ? 301 : 302),
    headers: { location: props.href }
  });
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement(
    "script",
    {
      dangerouslySetInnerHTML: {
        __html: `window.location.href=${escapeJson(
          JSON.stringify(props.href)
        )};`
      }
    }
  ));
} : function Redirect3(props) {
  const redirected = useRef5(false);
  useLayoutEffect(() => {
    if (redirected.current) return;
    redirected.current = true;
    navigate(props.href, { replace: true }).catch(() => {
    });
  });
  return null;
};
var ResponseHeaders = import.meta.env.SSR ? function ResponseHeaders2(props) {
  const response = useContext3(ResponseContext);
  response({
    status: props.status,
    headers: props.headers,
    throttleRenderStream: props.throttleRenderStream
  });
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null);
} : (
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function ResponseHeaders3(props) {
    return null;
  }
);
var ResponseContext = createNamedContext("ResponseContext", () => void 0);

// ../../node_modules/.pnpm/react-error-boundary@4.0.13_react@18.3.1/node_modules/react-error-boundary/dist/react-error-boundary.esm.js
import { createContext as createContext3, Component, createElement, isValidElement, useContext as useContext4, useState as useState4, useMemo as useMemo2, forwardRef as forwardRef2 } from "react";
var ErrorBoundaryContext = createContext3(null);
var initialState = {
  didCatch: false,
  error: null
};
var ErrorBoundary = class extends Component {
  constructor(props) {
    super(props);
    this.resetErrorBoundary = this.resetErrorBoundary.bind(this);
    this.state = initialState;
  }
  static getDerivedStateFromError(error) {
    return {
      didCatch: true,
      error
    };
  }
  resetErrorBoundary() {
    const {
      error
    } = this.state;
    if (error !== null) {
      var _this$props$onReset, _this$props;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 ? void 0 : _this$props$onReset.call(_this$props, {
        args,
        reason: "imperative-api"
      });
      this.setState(initialState);
    }
  }
  componentDidCatch(error, info) {
    var _this$props$onError, _this$props2;
    (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props2, error, info);
  }
  componentDidUpdate(prevProps, prevState) {
    const {
      didCatch
    } = this.state;
    const {
      resetKeys
    } = this.props;
    if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {
      var _this$props$onReset2, _this$props3;
      (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 ? void 0 : _this$props$onReset2.call(_this$props3, {
        next: resetKeys,
        prev: prevProps.resetKeys,
        reason: "keys"
      });
      this.setState(initialState);
    }
  }
  render() {
    const {
      children,
      fallbackRender,
      FallbackComponent,
      fallback
    } = this.props;
    const {
      didCatch,
      error
    } = this.state;
    let childToRender = children;
    if (didCatch) {
      const props = {
        error,
        resetErrorBoundary: this.resetErrorBoundary
      };
      if (typeof fallbackRender === "function") {
        childToRender = fallbackRender(props);
      } else if (FallbackComponent) {
        childToRender = createElement(FallbackComponent, props);
      } else if (fallback === null || isValidElement(fallback)) {
        childToRender = fallback;
      } else {
        throw error;
      }
    }
    return createElement(ErrorBoundaryContext.Provider, {
      value: {
        didCatch,
        error,
        resetErrorBoundary: this.resetErrorBoundary
      }
    }, childToRender);
  }
};
function hasArrayChanged() {
  let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  let b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return a.length !== b.length || a.some((item, index) => !Object.is(item, b[index]));
}
function assertErrorBoundaryContext(value) {
  if (value == null || typeof value.didCatch !== "boolean" || typeof value.resetErrorBoundary !== "function") {
    throw new Error("ErrorBoundaryContext not found");
  }
}
function useErrorBoundary() {
  const context = useContext4(ErrorBoundaryContext);
  assertErrorBoundaryContext(context);
  const [state, setState] = useState4({
    error: null,
    hasError: false
  });
  const memoized = useMemo2(() => ({
    resetBoundary: () => {
      context.resetErrorBoundary();
      setState({
        error: null,
        hasError: false
      });
    },
    showBoundary: (error) => setState({
      error,
      hasError: true
    })
  }), [context.resetErrorBoundary]);
  if (state.hasError) {
    throw state.error;
  }
  return memoized;
}

// src/features/error-boundary/implementation.tsx
import React5 from "react";

// src/features/use-query/client-hooks.tsx
import React4 from "react";

// src/runtime/client-hooks.ts
function defineClientHooks(hooks) {
  return hooks;
}

// src/features/use-query/client-hooks.tsx
var client_hooks_default = defineClientHooks({
  extendPageContext(ctx) {
    ctx.queryClient = createQueryClient(cache, ctx);
  },
  wrapApp(app) {
    return /* @__PURE__ */ React4.createElement(Wrapper, null, app);
  }
});
var queryCache = /* @__PURE__ */ Object.create(null);
function resetErrors() {
  const subscribers = /* @__PURE__ */ new Set();
  for (const key in queryCache) {
    const item = queryCache[key];
    if ("error" in item) {
      delete item.error;
      item.subscribers.forEach((subscriber) => subscribers.add(subscriber));
    }
  }
  subscribers.forEach((subscriber) => subscriber());
}
function Wrapper({ children }) {
  return /* @__PURE__ */ React4.createElement(QueryCacheContext.Provider, { value: cache }, children);
}
var cache = {
  setTags(key, tags, hash) {
    let item = this.get(key);
    if (!item) {
      this.set(key, void 0);
      item = this.get(key);
    }
    if (item.tagsHash === hash) return;
    item.tags = tags;
    item.tagsHash = hash;
  },
  has(key) {
    return key in queryCache || !!rakkas.cache && key in rakkas.cache;
  },
  get(key) {
    if (!queryCache[key] && rakkas.cache && key in rakkas.cache) {
      queryCache[key] = {
        value: rakkas.cache[key],
        subscribers: /* @__PURE__ */ new Set(),
        date: Date.now(),
        hydrated: true,
        cacheTime: DEFAULT_QUERY_OPTIONS.cacheTime
      };
      delete rakkas.cache[key];
    }
    return queryCache[key];
  },
  set(key, valueOrPromise, cacheTime = DEFAULT_QUERY_OPTIONS.cacheTime) {
    if (valueOrPromise instanceof Promise) {
      queryCache[key] ||= {
        date: Date.now(),
        hydrated: false,
        subscribers: /* @__PURE__ */ new Set(),
        cacheTime
      };
      queryCache[key] = {
        ...queryCache[key],
        promise: valueOrPromise,
        cacheTime: Math.max(queryCache[key].cacheTime, cacheTime)
      };
      valueOrPromise.then((value) => {
        queryCache[key] ||= {
          date: Date.now(),
          hydrated: false,
          subscribers: /* @__PURE__ */ new Set(),
          cacheTime
        };
        queryCache[key] = {
          ...queryCache[key],
          value,
          hydrated: false,
          date: Date.now()
        };
        delete queryCache[key].invalid;
        delete queryCache[key].promise;
      }).catch((error) => {
        queryCache[key] ||= {
          date: Date.now(),
          hydrated: false,
          subscribers: /* @__PURE__ */ new Set(),
          cacheTime
        };
        queryCache[key] = { ...queryCache[key], error };
        delete queryCache[key].promise;
        throw error;
      }).finally(() => {
        queryCache[key].subscribers.forEach((subscriber) => subscriber());
      });
    } else {
      queryCache[key] ||= {
        date: Date.now(),
        hydrated: false,
        subscribers: /* @__PURE__ */ new Set(),
        cacheTime
      };
      queryCache[key] = {
        ...queryCache[key],
        value: valueOrPromise,
        hydrated: false,
        date: Date.now()
      };
      delete queryCache[key].invalid;
      delete queryCache[key].promise;
    }
    queryCache[key].subscribers.forEach((subscriber) => subscriber());
  },
  subscribe(key, fn) {
    queryCache[key] ||= {
      subscribers: /* @__PURE__ */ new Set(),
      date: Date.now(),
      hydrated: false,
      cacheTime: DEFAULT_QUERY_OPTIONS.cacheTime
    };
    queryCache[key].subscribers.add(fn);
    if (queryCache[key].evictionTimeout !== void 0) {
      clearTimeout(queryCache[key].evictionTimeout);
      delete queryCache[key].evictionTimeout;
    }
    return () => {
      if (!queryCache[key]) return;
      queryCache[key].subscribers.delete(fn);
      if (queryCache[key].subscribers.size === 0) {
        delete queryCache[key].error;
        if (queryCache[key].cacheTime === 0 || queryCache[key].invalid) {
          delete queryCache[key];
        } else if (isFinite(queryCache[key].cacheTime)) {
          queryCache[key].evictionTimeout = setTimeout(() => {
            delete queryCache[key];
          }, queryCache[key].cacheTime);
        }
      }
    };
  },
  enumerate() {
    return Object.keys(queryCache);
  },
  invalidate(key) {
    if (queryCache[key]) {
      queryCache[key] = {
        ...queryCache[key],
        invalid: true
      };
      queryCache[key].subscribers.forEach((subscriber) => subscriber());
    }
  }
};

// src/features/error-boundary/implementation.tsx
var ErrorBoundary2 = (props) => /* @__PURE__ */ React5.createElement(
  ErrorBoundary,
  {
    ...props,
    onReset: (details) => {
      resetErrors();
      props.onReset?.(details);
    }
  }
);

// src/features/error-boundary/lib.ts
var useErrorBoundary2 = useErrorBoundary;

// src/features/pages/lib.ts
import { useContext as useContext5 } from "react";

// src/features/pages/DefaultErrorPage.tsx
import React6, { useEffect as useEffect4 } from "react";
function DefaultErrorPage(props) {
  useEffect4(() => {
    document.title = "Internal Error";
  }, []);
  const message = typeof props.error?.stack === "string" ? props.error.stack : typeof props.error?.message === "string" ? props.error.message : typeof props.error === "string" ? props.error : void 0;
  return import.meta.env.DEV ? /* @__PURE__ */ React6.createElement(React6.Fragment, null, /* @__PURE__ */ React6.createElement("h1", null, "Internal Error"), /* @__PURE__ */ React6.createElement("p", null, "This is Rakkas's default error page. It will", " ", /* @__PURE__ */ React6.createElement("b", null, "not be available"), " when you build your application for production and a bare \u201CInternal Error\u201D message will be displayed instead."), /* @__PURE__ */ React6.createElement("p", null, "Use ", /* @__PURE__ */ React6.createElement("code", null, "ErrorBoundary"), " to catch errors and create a", " ", /* @__PURE__ */ React6.createElement("code", null, "$error.jsx"), " in your ", /* @__PURE__ */ React6.createElement("code", null, "routes"), " directory to provide a last resort error page."), message && /* @__PURE__ */ React6.createElement(React6.Fragment, null, /* @__PURE__ */ React6.createElement("h2", null, "Error message"), /* @__PURE__ */ React6.createElement("pre", null, message)), /* @__PURE__ */ React6.createElement("p", null, /* @__PURE__ */ React6.createElement("button", { type: "button", onClick: () => location.reload() }, "Retry"))) : /* @__PURE__ */ React6.createElement(React6.Fragment, null, /* @__PURE__ */ React6.createElement("h1", null, "Internal Error"));
}

// src/features/pages/lib.ts
function useRouteParams() {
  return useContext5(RouteParamsContext);
}

// src/features/run-server-side/lib-common.ts
import { useContext as useContext6 } from "react";

// src/runtime/isomorphic-context.ts
var IsomorphicContext = createNamedContext(
  "IsomorphicContext",
  void 0
);
var ServerSideContext = createNamedContext(
  "ServerSideContext",
  void 0
);

// src/features/run-server-side/lib-common.ts
function useRequestContext() {
  return useContext6(ServerSideContext);
}

// ../../node_modules/.pnpm/@microsoft+fetch-event-source@2.0.1/node_modules/@microsoft/fetch-event-source/lib/esm/fetch.js
var EventStreamContentType = "text/event-stream";

// src/features/use-query/implementation.ts
var QueryCacheContext = createNamedContext(
  "QueryCacheContext",
  void 0
);
var DEFAULT_QUERY_OPTIONS = {
  cacheTime: 5 * 60 * 1e3,
  staleTime: 100,
  refetchOnMount: false,
  refetchOnWindowFocus: false,
  refetchInterval: false,
  refetchIntervalInBackground: false,
  refetchOnReconnect: false,
  enabled: true,
  keepPreviousData: false,
  tags: []
};
function usePageContext() {
  return useContext7(IsomorphicContext);
}
function queryOptions(options) {
  return options;
}
function useQuery(keyOrOptions, maybeFn, maybeOptions) {
  const {
    queryKey: key,
    queryFn: fn,
    ...options
  } = typeof keyOrOptions === "string" ? {
    queryKey: keyOrOptions,
    queryFn: maybeFn,
    ...maybeOptions
  } : keyOrOptions;
  const fullOptions = {
    ...DEFAULT_QUERY_OPTIONS,
    ...options,
    queryKey: key,
    queryFn: fn
  };
  const result = useQueryBase(fullOptions);
  useRefetch(result, fullOptions);
  return result;
}
function useQueryBase(options) {
  const {
    queryKey,
    queryFn,
    cacheTime,
    staleTime,
    refetchOnMount,
    enabled,
    initialData,
    placeholderData,
    keepPreviousData
  } = options;
  const cache2 = useContext7(QueryCacheContext);
  const memoizedTags = useMemo3(
    () => {
      const set = new Set(options.tags);
      const hash = JSON.stringify([...set].sort());
      return { set, hash };
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [...options.tags]
  );
  const [initialEnabled] = useState5(enabled);
  const [, forceUpdate] = useState5(0);
  const item = queryKey === void 0 ? void 0 : cache2.get(queryKey);
  useEffect5(() => {
    if (queryKey === void 0) {
      return;
    }
    return cache2.subscribe(queryKey, () => {
      forceUpdate((c) => c + 1 | 0);
    });
  }, [cache2, queryKey, item]);
  const ctx = usePageContext();
  const previousItem = useRef6(void 0);
  useEffect5(() => {
    if (keepPreviousData && item && "value" in item) {
      previousItem.current = item;
    }
  }, [item, keepPreviousData]);
  useEffect5(() => {
    if (!enabled || queryKey === void 0) {
      return;
    }
    const cacheItem = cache2.get(queryKey);
    if (cacheItem === void 0) {
      return;
    }
    cache2.setTags(queryKey, memoizedTags.set, memoizedTags.hash);
    if (cacheItem.invalid || refetchOnMount && (refetchOnMount === "always" || !cacheItem.date || staleTime <= Date.now() - cacheItem.date) && !cacheItem.promise && !cacheItem.hydrated) {
      const promiseOrValue = queryFn(ctx);
      cache2.set(queryKey, promiseOrValue, cacheTime);
      cache2.setTags(queryKey, memoizedTags.set, memoizedTags.hash);
    }
    cacheItem.hydrated = false;
  }, [queryKey, item?.invalid]);
  const queryResultReference = useMemo3(() => ({}), []);
  const refetch = useCallback3(
    function refetch2() {
      const item2 = cache2.get(queryKey);
      if (!item2?.promise) {
        cache2.set(queryKey, queryFn(ctx), cacheTime);
        cache2.setTags(queryKey, memoizedTags.set, memoizedTags.hash);
      }
    },
    [cache2, cacheTime, ctx, queryFn, queryKey, memoizedTags]
  );
  if (item && "value" in item) {
    if (item.invalid) {
      refetch();
    }
    return Object.assign(queryResultReference, {
      data: item.value,
      isRefetching: !!item.promise,
      refetch,
      dataUpdatedAt: item.date,
      error: item.error
    });
  }
  if (!import.meta.env.SSR && item && "error" in item) {
    const error = item.error;
    throw error;
  }
  if (initialData === void 0 && (placeholderData !== void 0 || !initialEnabled)) {
    return Object.assign(queryResultReference, {
      data: placeholderData,
      isRefetching: enabled,
      refetch,
      dataUpdatedAt: Date.now()
    });
  }
  const returnPreviousOrSuspend = (promise) => {
    if (keepPreviousData && previousItem.current !== void 0) {
      return Object.assign(queryResultReference, {
        data: previousItem.current.value,
        isRefetching: true,
        refetch,
        dataUpdatedAt: previousItem.current.date
      });
    }
    throw promise;
  };
  if (item?.promise) {
    return returnPreviousOrSuspend(item.promise);
  }
  let result = initialData;
  let shouldCache = initialData !== void 0;
  if (initialData === void 0 && enabled) {
    shouldCache = true;
    result = queryFn(ctx);
  }
  if (shouldCache) {
    cache2.set(queryKey, result, cacheTime);
    cache2.setTags(queryKey, memoizedTags.set, memoizedTags.hash);
  }
  if (result instanceof Promise) {
    return returnPreviousOrSuspend(result);
  }
  return Object.assign(queryResultReference, {
    data: result,
    refetch,
    isRefetching: false,
    dataUpdatedAt: item?.date ?? Date.now()
  });
}
function useRefetch(queryResult, options) {
  const {
    refetchOnWindowFocus,
    refetchInterval,
    refetchIntervalInBackground,
    staleTime,
    refetchOnReconnect,
    enabled,
    initialData,
    placeholderData
  } = options;
  const isEmpty = !queryResult;
  const { refetch } = queryResult || {};
  useEffect5(() => {
    if (isEmpty || !refetchOnWindowFocus || !enabled) return;
    function handleVisibilityChange() {
      if (document.visibilityState === "visible" && (refetchOnWindowFocus === "always" || !queryResult.dataUpdatedAt || staleTime <= Date.now() - queryResult.dataUpdatedAt)) {
        refetch();
      }
    }
    document.addEventListener("visibilitychange", handleVisibilityChange);
    window.addEventListener("focus", handleVisibilityChange);
    return () => {
      document.removeEventListener("visibilitychange", handleVisibilityChange);
      window.removeEventListener("focus", handleVisibilityChange);
    };
  }, [refetchOnWindowFocus, isEmpty, staleTime, enabled, queryResult, refetch]);
  const enabledRef = useRef6(enabled);
  useEffect5(() => {
    const prevEnabled = enabledRef.current;
    enabledRef.current = enabled;
    if (isEmpty || !enabled || prevEnabled) return;
    refetch();
  }, [staleTime, enabled, isEmpty, refetch]);
  useEffect5(() => {
    if (queryResult && enabled && (initialData !== void 0 && queryResult.data === initialData || initialData === void 0 && placeholderData !== void 0 && queryResult.data === placeholderData))
      queryResult.refetch();
  }, []);
  useEffect5(() => {
    if (!refetchInterval || isEmpty || !enabled) return;
    const id = setInterval(() => {
      if (refetchIntervalInBackground || document.visibilityState === "visible") {
        refetch();
      }
    }, refetchInterval);
    return () => {
      clearInterval(id);
    };
  }, [refetchInterval, refetchIntervalInBackground, enabled, isEmpty, refetch]);
  useEffect5(() => {
    if (!refetchOnReconnect || isEmpty || !enabled) return;
    function handleReconnect() {
      refetch();
    }
    window.addEventListener("online", handleReconnect);
    return () => {
      window.removeEventListener("online", handleReconnect);
    };
  }, [refetchOnReconnect, enabled, isEmpty, refetch]);
}
function useQueryClient() {
  const ctx = useContext7(IsomorphicContext);
  return ctx.queryClient;
}
function createQueryClient(cache2, ctx) {
  return {
    getQueryData(key) {
      return cache2.get(key)?.value;
    },
    setQueryData(key, data) {
      if (data instanceof Promise) {
        throw new TypeError("data must be synchronous");
      }
      cache2.set(key, data);
    },
    prefetchQuery(options) {
      const {
        queryKey,
        queryFn,
        tags = DEFAULT_QUERY_OPTIONS.tags,
        cacheTime = DEFAULT_QUERY_OPTIONS.cacheTime,
        staleTime = DEFAULT_QUERY_OPTIONS.staleTime
      } = options;
      const current = cache2.get(queryKey);
      if (current && "value" in current && current.invalid !== false && (current.date === void 0 || staleTime > Date.now() - current.date)) {
        return;
      }
      try {
        cache2.set(queryKey, queryFn(ctx), cacheTime);
        const set = new Set(tags);
        cache2.setTags(queryKey, set, JSON.stringify([...set].sort()));
      } catch {
      }
    },
    async ensureQueryData(options) {
      const {
        queryKey,
        queryFn,
        tags = DEFAULT_QUERY_OPTIONS.tags,
        cacheTime = DEFAULT_QUERY_OPTIONS.cacheTime,
        staleTime = DEFAULT_QUERY_OPTIONS.staleTime
      } = options;
      const current = cache2.get(queryKey);
      if (current && "value" in current && current.invalid !== false && (current.date === void 0 || staleTime > Date.now() - current.date)) {
        return current.value;
      }
      const result = queryFn(ctx);
      cache2.set(queryKey, result, cacheTime);
      const set = new Set(tags);
      cache2.setTags(queryKey, set, JSON.stringify([...set].sort()));
      if (!(result instanceof Promise)) {
        return result;
      }
      return cache2.get(queryKey).promise;
    },
    invalidateQueries(keys = () => true) {
      if (typeof keys === "string") {
        cache2.invalidate(keys);
        return;
      } else if (typeof keys === "function") {
        for (const key of cache2.enumerate()) {
          const shouldInvalidate = keys === void 0 || keys(key);
          if (shouldInvalidate) {
            cache2.invalidate(key);
          }
        }
        return;
      } else if (keys) {
        keys.forEach((key) => cache2.invalidate(key));
      }
    },
    invalidateTags(tags) {
      for (const key of cache2.enumerate()) {
        const item = cache2.get(key);
        if (item && item.tags) {
          for (const tag of tags) {
            if (item.tags.has(tag)) {
              cache2.invalidate(key);
              break;
            }
          }
        }
      }
    }
  };
}

// src/features/run-server-side/lib-server.ts
var import_stringify2 = __toESM(require_stringify(), 1);
import { uneval } from "devalue";

// src/features/run-server-side/implementation/use-form-action.ts
var import_stringify = __toESM(require_stringify(), 1);
function useFormAction(desc) {
  const { current: url } = useLocation();
  const [callSiteId, closure] = desc;
  const stringified = closure.map((x) => (0, import_stringify.stringify)(x));
  let closurePath = stringified.map(encodeFileNameSafe).join("/");
  if (closurePath) closurePath = "/" + closurePath;
  const actionPath = callSiteId + closurePath;
  const actionUrl = new URL(url);
  actionUrl.searchParams.set("_action", actionPath);
  return actionUrl;
}

// src/features/run-server-side/lib-server.ts
function runSSQImpl(ctx, desc) {
  if (typeof desc === "function") {
    return Promise.reject(new Error("runSSQ call hasn't been transformed"));
  }
  const [callSiteId, closure, fn] = desc;
  const stringified = closure.map((x) => (0, import_stringify2.stringify)(x));
  return Promise.resolve(fn(closure, ctx)).then(async (result) => {
    if (process.env.RAKKAS_PRERENDER === "true") {
      let closurePath = stringified.map(encodeFileNameSafe).join("/");
      if (closurePath) closurePath = "/" + closurePath;
      const url = "/_app/data/" + callSiteId + closurePath + "/d.js";
      await ctx.platform.render(
        url,
        new Response(uneval(result)),
        ctx.platform.prerenderOptions
      );
    }
    return result;
  });
}
function useSSEImpl() {
  return {};
}
function useSSQImpl(desc, options = {}) {
  if (typeof desc === "function") {
    throw new Error("useSSQ call hasn't been transformed");
  }
  const {
    // eslint-disable-next-line deprecation/deprecation
    key: oldKey,
    queryKey,
    usePostMethod,
    ...useQueryOptions
  } = options;
  const ctx = useRequestContext();
  const [callSiteId, closure, fn] = desc;
  const userKey = queryKey ?? oldKey;
  const stringified = closure.map((x) => (0, import_stringify2.stringify)(x));
  const key = userKey ?? `$ss:${callSiteId}:${stringified}`;
  return useQuery(
    key,
    () => Promise.resolve(fn(closure, ctx)).then(async (result) => {
      if (process.env.RAKKAS_PRERENDER === "true") {
        let closurePath = stringified.map(encodeFileNameSafe).join("/");
        if (closurePath) closurePath = "/" + closurePath;
        const url = "/_app/data/" + callSiteId + closurePath + "/d.js";
        await ctx.platform.render(
          url,
          new Response(uneval(result)),
          ctx.platform.prerenderOptions
        );
      }
      return result;
    }),
    useQueryOptions
  );
}
var runServerSideMutation = () => {
  throw new Error("runServerSideMutation is not available on the server-side");
};
var useServerSideMutation = () => ({
  mutate: throwServerMutationError,
  mutateAsync: throwServerMutationError,
  reset: throwServerMutationError,
  status: "idle",
  isError: false,
  isIdle: true,
  isLoading: false,
  isSuccess: false
});
function throwServerMutationError() {
  throw new Error("Mutations cannot be called on the server");
}
var composableActionData = /* @__PURE__ */ new WeakMap();
function useFormMutationImpl(desc) {
  const action = useFormAction(desc);
  const ctx = useRequestContext();
  const dataContainer = composableActionData.get(ctx);
  const hasData = !!(dataContainer && dataContainer[0] === action.searchParams.get("_action"));
  return {
    action: action.href,
    status: hasData ? "success" : "idle",
    isError: false,
    isIdle: !hasData,
    isLoading: false,
    isSuccess: hasData,
    submitHandler() {
      throw new Error("submitHandler is not available on the server-side");
    },
    data: hasData ? dataContainer[1].data : void 0,
    error: void 0
  };
}
var useFormMutation = useFormMutationImpl;
var useServerSideQuery = useSSQImpl;
var runServerSideQuery = runSSQImpl;
var useServerSentEvents = useSSEImpl;

// src/features/async-local-request-context/implementation.ts
import { AsyncLocalStorage } from "node:async_hooks";
var requestContextStorage = AsyncLocalStorage ? new AsyncLocalStorage() : void 0;

export {
  createNamedContext,
  HeadContext,
  mergeHeadProps,
  defaultHeadProps,
  sortHeadTags,
  useHead,
  Head,
  IsomorphicContext,
  ServerSideContext,
  EventStreamContentType,
  QueryCacheContext,
  usePageContext,
  queryOptions,
  useQuery,
  useQueryClient,
  createQueryClient,
  useMutation,
  useMutations,
  useNavigationBlocker,
  RouteParamsContext,
  RenderedUrlContext,
  navigationResolve,
  navigate,
  restoreScrollPosition,
  useLocation,
  cancelLastNavigation,
  LocationContext,
  Link,
  StyledLink,
  useSubmit,
  prefetcher,
  prefetchRoute,
  ClientOnly,
  ClientSuspense,
  decodeFileNameSafe,
  escapeHtml,
  escapeCss,
  sortHooks,
  Redirect,
  ResponseHeaders,
  ResponseContext,
  ErrorBoundary2 as ErrorBoundary,
  useErrorBoundary2 as useErrorBoundary,
  DefaultErrorPage,
  useRouteParams,
  useRequestContext,
  require_types,
  runServerSideMutation,
  useServerSideMutation,
  composableActionData,
  useFormMutation,
  useServerSideQuery,
  runServerSideQuery,
  useServerSentEvents,
  requestContextStorage
};

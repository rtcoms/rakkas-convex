// src/parser.ts
function parseHeaderValue(value) {
  if (!value) {
    return [];
  }
  const val = value;
  let index = 0;
  const parts = [];
  for (; ; ) {
    const part = parsePart();
    if (!part) {
      return parts;
    }
    parts.push(part);
    eatComment();
    if (val[index] !== ",") {
      return parts;
    }
    index++;
  }
  function parsePart() {
    const text = parseValue();
    if (!text) {
      return null;
    }
    eatComment();
    if (val[index] === ";") {
      index++;
      return { value: text, directives: parseDirectives() };
    }
    return { value: text, directives: {} };
  }
  function parseDirectives() {
    const directives = {};
    for (; ; ) {
      const name = parseValue();
      if (!name) {
        return directives;
      }
      eatWhiteSpace();
      if (val[index] !== "=") {
        directives[name] = null;
        return directives;
      }
      index++;
      directives[name] = parseValue();
      eatWhiteSpace();
      if (val[index] !== ";") {
        return directives;
      }
      index++;
    }
  }
  function parseValue() {
    eatWhiteSpace();
    if (val[index] === '"') {
      const match = val.slice(index + 1).match(/[^"(]*/);
      index += match[0].length + 2;
      return match[0];
    } else {
      const match = val.slice(index).match(/[^=,;(]*/);
      index += match[0].length;
      return match[0].trimEnd();
    }
  }
  function eatWhiteSpace() {
    index = val.slice(index).search(/[^ \t]/) + index;
  }
  function eatComment() {
    eatWhiteSpace();
    if (val[index] !== "(") {
      return;
    }
    const pos = val.indexOf(")", index);
    if (pos === -1) {
      index = val.length;
      return;
    }
    index = pos + 1;
    eatWhiteSpace();
    return;
  }
}

// src/q.ts
function parseQValue(value) {
  if (!value) {
    return 1;
  }
  const q = Number(value);
  return isNaN(q) ? 1 : q;
}

// src/accept.ts
function accept(header, provided) {
  header = header ?? "*";
  const accepts = parseHeaderValue(header).sort(
    (a, b) => parseQValue(b.directives.q) - parseQValue(a.directives.q)
  );
  for (const accept2 of accepts) {
    for (const type of Object.keys(provided)) {
      if (typesMatch(accept2.value, type)) {
        return provided[type];
      }
    }
  }
  return provided["*"] ?? provided["*"];
}
function typesMatch(requested, provided) {
  requested = requested.toLowerCase();
  provided = provided.toLowerCase();
  if (requested === provided || requested === "*/*") {
    return true;
  }
  if (requested.endsWith("/*")) {
    return provided.startsWith(requested.slice(0, -1));
  }
  return false;
}

// src/accept-language.ts
function acceptLanguage(header, provided) {
  header = header ?? "*";
  const accepts = parseHeaderValue(header).sort(
    (a, b) => parseQValue(b.directives.q) - parseQValue(a.directives.q)
  );
  for (const accept2 of accepts) {
    for (const type of Object.keys(provided)) {
      if (languagesMatch(accept2.value, type)) {
        return provided[type];
      }
    }
  }
  return provided["*"];
}
function languagesMatch(requested, provided) {
  if (requested === provided || requested === "*") {
    return true;
  }
  const r = requested.split("-");
  const p = provided.split("-");
  return r.length < p.length && r.every((part, i) => part === p[i]);
}
export {
  accept,
  acceptLanguage,
  parseHeaderValue
};

// src/index.ts
import { lookup } from "mime-types";
import fs from "node:fs";
import path from "node:path";
import { createHash } from "node:crypto";
import { fileURLToPath } from "node:url";

// src/url.ts
var PATH_CHARS = /[A-Za-z0-9-._~!$&'()*+,;=:@[\]|^]/;
function normalizePathSegment(segment) {
  const result = segment.normalize("NFC").replace(
    /%(?:[0-9a-fA-F]{2})|[^A-Za-z0-9-._~!$&'()*+,;=:@[\]|^]/gu,
    (match) => {
      if (match.length < 3) {
        return encodeURIComponent(match);
      } else if (match[1] <= "7") {
        const decoded = decodeURIComponent(match);
        if (decoded.match(PATH_CHARS)) {
          return decoded;
        }
      }
      return match.toUpperCase();
    }
  );
  if (result === ".") {
    return "%2E";
  } else if (result === "..") {
    return "%2E%2E";
  }
  return result;
}

// src/index.ts
import { Buffer } from "node:buffer";
function walk(dir, options = {}) {
  if (dir instanceof URL || dir.startsWith("file:")) {
    dir = fileURLToPath(dir);
  }
  return doWalk(
    /* @__PURE__ */ new Map(),
    dir,
    "",
    "",
    {
      etag: options.etag ?? true,
      prune: options.prune ?? ["node_modules", "dist", /^\.(?!well-known$)/],
      getType: options.getType ?? lookup
    }
  );
}
function doWalk(entries, dir, parent, normalizedParent, options) {
  const files = fs.readdirSync(dir);
  for (const file of files) {
    if (options.prune.some((p) => file === p || file.match(p))) {
      continue;
    }
    const normalizedFile = normalizePathSegment(file);
    let stat;
    const filepath = path.join(dir, file);
    const relativePath = parent + "/" + file;
    try {
      stat = fs.statSync(filepath);
    } catch (error) {
      if (error?.code === "ENOENT") {
        continue;
      }
      throw error;
    }
    if (stat.isSymbolicLink()) {
      continue;
    }
    if (stat.isDirectory()) {
      doWalk(
        entries,
        filepath,
        relativePath,
        normalizedParent + "/" + normalizedFile,
        options
      );
    } else if (stat.isFile()) {
      let etag;
      if (options.etag) {
        etag = hashSync(filepath);
      }
      entries.set(normalizedParent + "/" + normalizedFile, {
        path: relativePath,
        type: options.getType(filepath) || "application/octet-stream",
        size: stat.size,
        etag
      });
    }
  }
  return entries;
}
function createFileSet(dir, options) {
  const files = walk(dir, options);
  return new Set(files.keys());
}
function createFileSetModule(dir, options) {
  const files = createFileSet(dir, options);
  return `export default new Set(${JSON.stringify([...files])});`;
}
function createFileMap(dir, options) {
  const files = walk(dir, options);
  return new Map(
    [...files].map(([name, stat]) => [
      name,
      name === stat.path ? void 0 : stat.path
    ])
  );
}
function createFileMapModule(dir, options) {
  const files = createFileMap(dir, options);
  const joined = [...files].map(stringifyTuple).join(",");
  return `export default new Map([${joined}]);`;
}
function createFileList(dir, options) {
  const files = walk(dir, options);
  if (options?.etag === false) {
    return [...files].map(([name, stat]) => [
      name,
      name === stat.path ? void 0 : stat.path,
      stat.type,
      stat.size
    ]);
  } else {
    return [...files].map(([name, stat]) => [
      name,
      name === stat.path ? void 0 : stat.path,
      stat.type,
      stat.size,
      stat.etag
    ]);
  }
}
function createFileListModule(dir, options) {
  const files = createFileList(dir, options);
  const joined = files.map((file) => stringifyTuple(file)).join(",");
  return `export default [${joined}];`;
}
function createCompressedFileListModule(dir, options) {
  const files = createFileList(dir, options);
  const types = /* @__PURE__ */ new Map();
  const output = [];
  for (const [name, path2, type, size, etag] of files) {
    let typeIndex = types.get(type);
    if (typeIndex === void 0) {
      typeIndex = types.size;
      types.set(type, typeIndex);
    }
    output.push(
      etag ? [name, name === path2 ? void 0 : path2, typeIndex, size, etag] : [name, name === path2 ? void 0 : path2, typeIndex, size]
    );
  }
  const joined = output.map((file) => stringifyTuple(file)).join(",");
  return `export default {types: ${JSON.stringify([
    ...types.keys()
  ])}, files: [${joined}]};`;
}
function stringifyTuple(tuple) {
  return `[${tuple.map((value) => value === void 0 ? "" : JSON.stringify(value)).join(",")}]`;
}
function hashSync(filepath) {
  const hash = createHash("md5");
  const buffer = Buffer.alloc(64 * 1024);
  const fd = fs.openSync(filepath, "r");
  for (; ; ) {
    const bytesRead = fs.readSync(fd, buffer, {});
    if (bytesRead === 0) {
      break;
    }
    hash.update(buffer.subarray(0, bytesRead));
  }
  return hash.digest("hex");
}

export {
  walk,
  createFileSet,
  createFileSetModule,
  createFileMap,
  createFileMapModule,
  createFileList,
  createFileListModule,
  createCompressedFileListModule
};

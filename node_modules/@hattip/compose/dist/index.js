// src/index.ts
function finalHandler(context) {
  context.passThrough();
  return new Response("Not found", { status: 404 });
}
function composePartialOld(handlers, next) {
  const flatHandlers = handlers.flat().filter(Boolean);
  return flatHandlers.map(wrap).reduceRight(
    (prev, current) => {
      return async (context) => {
        context.next = () => prev(context);
        const result = await current(context);
        return result || prev(context);
      };
    },
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    next ? (_) => next() : (_) => void 0
  );
}
function compose(...handlers) {
  return composePartial([
    (context) => {
      context.url = new URL(context.request.url);
      context.method = context.request.method;
      context.locals = {};
      context.handleError = (error) => {
        console.error(error);
        return new Response("Internal Server Error", { status: 500 });
      };
    },
    ...handlers,
    finalHandler
  ]);
}
function composeOld(...handlers) {
  return composePartialOld([
    (context) => {
      context.url = new URL(context.request.url);
      context.method = context.request.method;
      context.locals = {};
      context.handleError = (error) => {
        console.error(error);
        return new Response("Internal Server Error", { status: 500 });
      };
    },
    ...handlers,
    finalHandler
  ]);
}
function composePartial(handlers) {
  const flatHandlers = handlers.flat().filter(Boolean);
  async function call(ctx, start = 0) {
    const next = ctx.next;
    let ref = 0;
    ctx.next = () => call(ctx, ref + 1);
    for (let i = start; i < flatHandlers.length; i++) {
      const handler = flatHandlers[i];
      ref = i;
      try {
        let response = handler(ctx);
        if (response instanceof Promise) {
          response = await response;
        }
        if (response) {
          return toResponse(response);
        }
      } catch (error) {
        if (error instanceof Response) {
          return error;
        }
        if (isResponseConvertible(error)) {
          return error.toResponse();
        }
        if (ctx.handleError) {
          return ctx.handleError(error);
        }
        throw error;
      }
    }
    return next();
  }
  return (ctx) => call(ctx);
}
function toResponse(responseLike) {
  if (responseLike instanceof Response) {
    return Promise.resolve(responseLike);
  }
  return responseLike.toResponse();
}
function wrap(handler) {
  return async (context) => {
    let result;
    try {
      result = await (handler(context) || context.next());
    } catch (error) {
      if (error instanceof Response) {
        return error;
      } else if (isResponseConvertible(error)) {
        return error.toResponse();
      } else if (context.handleError) {
        return context.handleError(error);
      } else {
        throw error;
      }
    }
    if (isResponseConvertible(result)) {
      return result.toResponse();
    }
    return result;
  };
}
function isResponseConvertible(response) {
  return response && "toResponse" in response;
}
export {
  compose,
  composeOld,
  composePartial,
  composePartialOld
};
